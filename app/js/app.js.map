{"version":3,"file":"app.js","sources":["../../node_modules/vue/dist/vue.esm.js","data/priceCurrencies.js","data/priceModes.js","data/deckParts.js","appData.js","methods/uriLocationNoParam.js","methods/utilEachObject.js","methods/apiLoadNames.js","data/apiURLs.js","methods/apiLoadPrices.js","methods/convertFileToDeck.js","methods/deckLoad.js","methods/uriDeckDecode.js","methods/deckLoadUri.js","methods/uriDeckEncode.js","methods/deckUpdate.js","methods/deckCardsWithoutPriceData.js","methods/priceConvert.js","methods/priceForCard.js","methods/priceForSection.js","methods/builderUpdateNames.js","methods/builderDeckAdd.js","methods/builderDeckRemove.js","../../node_modules/file-saver/FileSaver.js","methods/convertDeckToFile.js","methods/fileDownloadDeck.js","appMethods.js","app.js"],"sourcesContent":["/*!\n * Vue.js v2.2.6\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n/*  */\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction _toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Remove an item from an array\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return typeof value === 'string' || typeof value === 'number'\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nvar toString = Object.prototype.toString;\nvar OBJECT_STRING = '[object Object]';\nfunction isPlainObject (obj) {\n  return toString.call(obj) === OBJECT_STRING\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n */\nfunction noop () {}\n\n/**\n * Always return false.\n */\nvar no = function () { return false; };\n\n/**\n * Return same value\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      return JSON.stringify(a) === JSON.stringify(b)\n    } catch (e) {\n      // possible circular reference\n      return a === b\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn();\n    }\n  }\n}\n\n/*  */\n\nvar config = {\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * List of asset types that a component can own.\n   */\n  _assetTypes: [\n    'component',\n    'directive',\n    'filter'\n  ],\n\n  /**\n   * List of lifecycle hooks.\n   */\n  _lifecycleHooks: [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated'\n  ],\n\n  /**\n   * Max circular updates allowed in a scheduler flush cycle.\n   */\n  _maxUpdateCount: 100\n};\n\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    var logError = function (err) { console.error(err); };\n    timerFunc = function () {\n      p.then(nextTickHandler).catch(logError);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n  } else if (typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function () {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) { cb.call(ctx); }\n      if (_resolve) { _resolve(ctx); }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve) {\n        _resolve = resolve;\n      })\n    }\n  }\n})();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\nvar warn = noop;\nvar tip = noop;\nvar formatComponentName;\n\nif (process.env.NODE_ENV !== 'production') {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.error(\"[Vue warn]: \" + msg + \" \" + (\n        vm ? formatLocation(formatComponentName(vm)) : ''\n      ));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + \" \" + (\n        vm ? formatLocation(formatComponentName(vm)) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var name = typeof vm === 'string'\n      ? vm\n      : typeof vm === 'function' && vm.options\n        ? vm.options.name\n        : vm._isVue\n          ? vm.$options.name || vm.$options._componentTag\n          : vm.name;\n\n    var file = vm._isVue && vm.$options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var formatLocation = function (str) {\n    if (str === \"<Anonymous>\") {\n      str += \" - use the \\\"name\\\" option for better debugging messages.\";\n    }\n    return (\"\\n(found in \" + str + \")\")\n  };\n}\n\n/*  */\n\n\nvar uid$1 = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid$1++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var arguments$1 = arguments;\n\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n    while (i--) {\n      args[i] = arguments$1[i];\n    }\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n        inserted = args;\n        break\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true,\n  isSettingProps: false\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value)) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (Array.isArray(target) && typeof key === 'number') {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (hasOwn(target, key)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target ).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (Array.isArray(target) && typeof key === 'number') {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target ).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (process.env.NODE_ENV !== 'production') {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        childVal.call(this),\n        parentVal.call(this)\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nconfig._lifecycleHooks.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal\n    ? extend(res, childVal)\n    : res\n}\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.computed = function (parentVal, childVal) {\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  extend(ret, childVal);\n  return ret\n};\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + key\n      );\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkComponents(child);\n  }\n  normalizeProps(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = typeof extendsFrom === 'function'\n      ? mergeOptions(parent, extendsFrom.options, vm)\n      : mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      var mixin = child.mixins[i];\n      if (mixin.prototype instanceof Vue$3) {\n        mixin = mixin.options;\n      }\n      parent = mergeOptions(parent, mixin, vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (process.env.NODE_ENV !== 'production' && isObject(def)) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      'Invalid prop: type check failed for prop \"' + name + '\".' +\n      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\n/**\n * Assert the type of a value\n */\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (expectedType === 'String') {\n    valid = typeof value === (expectedType = 'string');\n  } else if (expectedType === 'Number') {\n    valid = typeof value === (expectedType = 'number');\n  } else if (expectedType === 'Boolean') {\n    valid = typeof value === (expectedType = 'boolean');\n  } else if (expectedType === 'Function') {\n    valid = typeof value === (expectedType = 'function');\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match && match[1]\n}\n\nfunction isType (type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type)\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true\n    }\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction handleError (err, vm, info) {\n  if (config.errorHandler) {\n    config.errorHandler.call(null, err, vm, info);\n  } else {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Error in \" + info + \":\"), vm);\n    }\n    /* istanbul ignore else */\n    if (inBrowser && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err\n    }\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (process.env.NODE_ENV !== 'production') {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      \"referenced during render. Make sure to declare reactive data \" +\n      \"properties in the data option.\",\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' &&\n    Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\nvar mark;\nvar measure;\n\nif (process.env.NODE_ENV !== 'production') {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      perf.clearMeasures(name);\n    };\n  }\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n};\n\nvar prototypeAccessors = { child: {} };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function () {\n  var node = new VNode();\n  node.text = '';\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isCloned = true;\n  return cloned\n}\n\nfunction cloneVNodes (vnodes) {\n  var len = vnodes.length;\n  var res = new Array(len);\n  for (var i = 0; i < len; i++) {\n    res[i] = cloneVNode(vnodes[i]);\n  }\n  return res\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture\n  }\n});\n\nfunction createFnInvoker (fns) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      for (var i = 0; i < fns.length; i++) {\n        fns[i].apply(null, arguments$1);\n      }\n    } else {\n      // return handler return value for single handlers\n      return fns.apply(null, arguments)\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, cur, old, event;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (!cur) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (!old) {\n      if (!cur.fns) {\n        cur = on[name] = createFnInvoker(cur);\n      }\n      add(event.name, cur, event.once, event.capture);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (!on[name]) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (!oldHook) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (oldHook.fns && oldHook.merged) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (c == null || typeof c === 'boolean') { continue }\n    last = res[res.length - 1];\n    //  nested\n    if (Array.isArray(c)) {\n      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\n    } else if (isPrimitive(c)) {\n      if (last && last.text) {\n        last.text += String(c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (c.text && last && last.text) {\n        res[res.length - 1] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (c.tag && c.key == null && nestedIndex != null) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  return children && children.filter(function (c) { return c && c.componentOptions; })[0]\n}\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn, once$$1) {\n  if (once$$1) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        this$1.$off(event[i$1], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (process.env.NODE_ENV !== 'production') {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        cbs[i].apply(vm, args);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  var slots = {};\n  if (!children) {\n    return slots\n  }\n  var defaultSlot = [];\n  var name, child;\n  for (var i = 0, l = children.length; i < l; i++) {\n    child = children[i];\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) &&\n        child.data && (name = child.data.slot)) {\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore whitespace\n  if (!defaultSlot.every(isWhitespace)) {\n    slots.default = defaultSlot;\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return node.isComment || node.text === ' '\n}\n\nfunction resolveScopedSlots (\n  fns\n) {\n  var res = {};\n  for (var i = 0; i < fns.length; i++) {\n    res[fns[i][0]] = fns[i][1];\n  }\n  return res\n}\n\n/*  */\n\nvar activeInstance = null;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // remove reference to DOM nodes (prevents leak)\n    vm.$options._parentElm = vm.$options._refElm = null;\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  vm._watcher = new Watcher(vm, updateComponent, noop);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren\n  var hasChildren = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    parentVnode.data.scopedSlots || // has new scoped slots\n    vm.$scopedSlots !== emptyObject // has old scoped slots\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    observerState.shouldConvert = false;\n    if (process.env.NODE_ENV !== 'production') {\n      observerState.isSettingProps = true;\n    }\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      props[key] = validateProp(key, vm.$options.props, propsData, vm);\n    }\n    observerState.shouldConvert = true;\n    if (process.env.NODE_ENV !== 'production') {\n      observerState.isSettingProps = false;\n    }\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n  // update listeners\n  if (listeners) {\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n  }\n  // resolve slots + force update if has children\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive == null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm);\n      } catch (e) {\n        handleError(e, vm, (hook + \" hook\"));\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\n\nvar queue = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  queue.length = 0;\n  has = {};\n  if (process.env.NODE_ENV !== 'production') {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n  var watcher, id, vm;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > config._maxUpdateCount) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // reset scheduler before updated hook called\n  var oldQueue = queue.slice();\n  resetSchedulerState();\n\n  // call updated hooks\n  index = oldQueue.length;\n  while (index--) {\n    watcher = oldQueue[index];\n    vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i >= 0 && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(Math.max(i, index) + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options\n) {\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression = process.env.NODE_ENV !== 'production'\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  if (this.user) {\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    }\n  } else {\n    value = this.getter.call(vm, vm);\n  }\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value);\n  }\n  popTarget();\n  this.cleanupDeps();\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse (val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch) { initWatch(vm, opts.watch); }\n}\n\nvar isReservedProp = { key: 1, ref: 1, slot: 1 };\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      if (isReservedProp[key]) {\n        warn(\n          (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (vm.$parent && !observerState.isSettingProps) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  observerState.shouldConvert = true;\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var i = keys.length;\n  while (i--) {\n    if (props && hasOwn(props, keys[i])) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"The data property \\\"\" + (keys[i]) + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(keys[i])) {\n      proxy(vm, \"_data\", keys[i]);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  try {\n    return data.call(vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  var watchers = vm._computedWatchers = Object.create(null);\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (process.env.NODE_ENV !== 'production') {\n      if (getter === undefined) {\n        warn(\n          (\"No getter function has been defined for computed property \\\"\" + key + \"\\\".\"),\n          vm\n        );\n        getter = noop;\n      }\n    }\n    // create internal watcher for the computed property.\n    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    }\n  }\n}\n\nfunction defineComputed (target, key, userDef) {\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = createComputedGetter(key);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? userDef.cache !== false\n        ? createComputedGetter(key)\n        : userDef.get\n      : noop;\n    sharedPropertyDefinition.set = userDef.set\n      ? userDef.set\n      : noop;\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction initMethods (vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods[key] == null) {\n        warn(\n          \"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n    }\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (vm, key, handler) {\n  var options;\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  vm.$watch(key, handler, options);\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (process.env.NODE_ENV !== 'production') {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\n// hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (\n    vnode,\n    hydrating,\n    parentElm,\n    refElm\n  ) {\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance,\n        parentElm,\n        refElm\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    } else if (vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    if (!vnode.componentInstance._isMounted) {\n      vnode.componentInstance._isMounted = true;\n      callHook(vnode.componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      activateChildComponent(vnode.componentInstance, true /* direct */);\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    if (!vnode.componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        vnode.componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(vnode.componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (!Ctor) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  if (typeof Ctor !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  if (!Ctor.cid) {\n    if (Ctor.resolved) {\n      Ctor = Ctor.resolved;\n    } else {\n      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {\n        // it's ok to queue this on every render because\n        // $forceUpdate is buffered by the scheduler.\n        context.$forceUpdate();\n      });\n      if (!Ctor) {\n        // return nothing if this is indeed an async component\n        // wait for the callback to trigger parent update.\n        return\n      }\n    }\n  }\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  data = data || {};\n\n  // transform component v-model data into props & events\n  if (data.model) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractProps(data, Ctor, tag);\n\n  // functional component\n  if (Ctor.options.functional) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  data.on = data.nativeOn;\n\n  if (Ctor.options.abstract) {\n    // abstract components do not keep anything\n    // other than props & listeners\n    data = {};\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }\n  );\n  return vnode\n}\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  context,\n  children\n) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (propOptions) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData);\n    }\n  }\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var _context = Object.create(context);\n  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\n  var vnode = Ctor.options.render.call(null, h, {\n    props: props,\n    data: data,\n    parent: context,\n    children: children,\n    slots: function () { return resolveSlots(children, context); }\n  });\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm,\n  refElm\n) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (inlineTemplate) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options)\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  cb\n) {\n  if (factory.requested) {\n    // pool callbacks\n    factory.pendingCallbacks.push(cb);\n  } else {\n    factory.requested = true;\n    var cbs = factory.pendingCallbacks = [cb];\n    var sync = true;\n\n    var resolve = function (res) {\n      if (isObject(res)) {\n        res = baseCtor.extend(res);\n      }\n      // cache resolved\n      factory.resolved = res;\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          cbs[i](res);\n        }\n      }\n    };\n\n    var reject = function (reason) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n    };\n\n    var res = factory(resolve, reject);\n\n    // handle promise\n    if (res && typeof res.then === 'function' && !factory.resolved) {\n      res.then(resolve, reject);\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.resolved\n  }\n}\n\nfunction extractProps (data, Ctor, tag) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (!propOptions) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  var domProps = data.domProps;\n  if (attrs || props || domProps) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (process.env.NODE_ENV !== 'production') {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && attrs.hasOwnProperty(keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey) ||\n      checkProp(res, domProps, key, altKey);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (hash) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\nfunction mergeHooks (data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = componentVNodeHooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1 (one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  }\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  if (on[event]) {\n    on[event] = [data.model.callback].concat(on[event]);\n  } else {\n    on[event] = data.model.callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (alwaysNormalize) { normalizationType = ALWAYS_NORMALIZE; }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (data && data.__ob__) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n      typeof children[0] === 'function') {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (vnode) {\n    if (ns) { applyNS(vnode, ns); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    return\n  }\n  if (vnode.children) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (child.tag && !child.ns) {\n        applyNS(child, ns);\n      }\n    }\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    ret = new Array(keys.length);\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      ret[i] = render(val[key], key, i);\n    }\n  }\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      extend(props, bindObject);\n    }\n    return scopedSlotFn(props) || fallback\n  } else {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes && process.env.NODE_ENV !== 'production') {\n      slotNodes._rendered && warn(\n        \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n        \"- this will likely cause render errors.\",\n        this\n      );\n      slotNodes._rendered = true;\n    }\n    return slotNodes || fallback\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\n/**\n * Runtime helper for checking keyCodes from config.\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInAlias\n) {\n  var keyCodes = config.keyCodes[key] || builtInAlias;\n  if (Array.isArray(keyCodes)) {\n    return keyCodes.indexOf(eventKeyCode) === -1\n  } else {\n    return keyCodes !== eventKeyCode\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp\n) {\n  if (value) {\n    if (!isObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      for (var key in value) {\n        if (key === 'class' || key === 'style') {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        if (!(key in hash)) {\n          hash[key] = value[key];\n        }\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var tree = this._staticTrees[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree by doing a shallow clone.\n  if (tree && !isInFor) {\n    return Array.isArray(tree)\n      ? cloneVNodes(tree)\n      : cloneVNode(tree)\n  }\n  // otherwise, render a fresh tree.\n  tree = this._staticTrees[index] =\n    this.$options.staticRenderFns[index].call(this._renderProxy);\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm.$vnode = null; // the placeholder node in parent tree\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  var parentVnode = vm.$options._parentVnode;\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n}\n\nfunction renderMixin (Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render function\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        vnode = vm.$options.renderError\n          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n          : vm._vnode;\n      } else {\n        vnode = vm._vnode;\n      }\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n\n  // internal render helpers.\n  // these are exposed on the instance prototype to reduce generated render\n  // code size.\n  Vue.prototype._o = markOnce;\n  Vue.prototype._n = toNumber;\n  Vue.prototype._s = _toString;\n  Vue.prototype._l = renderList;\n  Vue.prototype._t = renderSlot;\n  Vue.prototype._q = looseEqual;\n  Vue.prototype._i = looseIndexOf;\n  Vue.prototype._m = renderStatic;\n  Vue.prototype._f = resolveFilter;\n  Vue.prototype._k = checkKeyCodes;\n  Vue.prototype._b = bindObjectProps;\n  Vue.prototype._v = createTextVNode;\n  Vue.prototype._e = createEmptyVNode;\n  Vue.prototype._u = resolveScopedSlots;\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var inject = vm.$options.inject;\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    // isArray here\n    var isArray = Array.isArray(inject);\n    var keys = isArray\n      ? inject\n      : hasSymbol\n        ? Reflect.ownKeys(inject)\n        : Object.keys(inject);\n\n    var loop = function ( i ) {\n      var key = keys[i];\n      var provideKey = isArray ? key : inject[key];\n      var source = vm;\n      while (source) {\n        if (source._provided && provideKey in source._provided) {\n          /* istanbul ignore else */\n          if (process.env.NODE_ENV !== 'production') {\n            defineReactive$$1(vm, key, source._provided[provideKey], function () {\n              warn(\n                \"Avoid mutating an injected value directly since the changes will be \" +\n                \"overwritten whenever the provided component re-renders. \" +\n                \"injection being mutated: \\\"\" + key + \"\\\"\",\n                vm\n              );\n            });\n          } else {\n            defineReactive$$1(vm, key, source._provided[provideKey]);\n          }\n          break\n        }\n        source = source.$parent;\n      }\n    };\n\n    for (var i = 0; i < keys.length; i++) loop( i );\n  }\n}\n\n/*  */\n\nvar uid = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = \"vue-perf-init:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure(((vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = dedupe(latest[key], sealed[key]);\n    }\n  }\n  return modified\n}\n\nfunction dedupe (latest, sealed) {\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n  // between merges\n  if (Array.isArray(latest)) {\n    var res = [];\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\n    for (var i = 0; i < latest.length; i++) {\n      if (sealed.indexOf(latest[i]) < 0) {\n        res.push(latest[i]);\n      }\n    }\n    return res\n  } else {\n    return latest\n  }\n}\n\nfunction Vue$3 (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue$3)) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return\n    }\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    plugin.installed = true;\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn(\n          'Invalid component name: \"' + name + '\". Component names ' +\n          'can only contain alphanumeric characters and the hyphen, ' +\n          'and must start with a letter.'\n        );\n      }\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    config._assetTypes.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  config._assetTypes.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production') {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn(\n              'Do not use built-in or reserved HTML elements as component ' +\n              'id: ' + id\n            );\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\nvar patternTypes = [String, RegExp];\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (pattern instanceof RegExp) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (cache, filter) {\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        pruneCacheEntry(cachedNode);\n        cache[key] = null;\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (vnode) {\n  if (vnode) {\n    if (!vnode.componentInstance._inactive) {\n      callHook(vnode.componentInstance, 'deactivated');\n    }\n    vnode.componentInstance.$destroy();\n  }\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n  },\n\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this$1.cache) {\n      pruneCacheEntry(this$1.cache[key]);\n    }\n  },\n\n  watch: {\n    include: function include (val) {\n      pruneCache(this.cache, function (name) { return matches(val, name); });\n    },\n    exclude: function exclude (val) {\n      pruneCache(this.cache, function (name) { return !matches(val, name); });\n    }\n  },\n\n  render: function render () {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      if (name && (\n        (this.include && !matches(this.include, name)) ||\n        (this.exclude && matches(this.exclude, name))\n      )) {\n        return vnode\n      }\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (this.cache[key]) {\n        vnode.componentInstance = this.cache[key].componentInstance;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (process.env.NODE_ENV !== 'production') {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  config._assetTypes.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nVue$3.version = '2.2.6';\n\n/*  */\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (childNode.componentInstance) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return genClassFromData(data)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: child.class\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction genClassFromData (data) {\n  var dynamicClass = data.class;\n  var staticClass = data.staticClass;\n  if (staticClass || dynamicClass) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  var res = '';\n  if (!value) {\n    return res\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  if (Array.isArray(value)) {\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (value[i]) {\n        if ((stringified = stringifyClass(value[i]))) {\n          res += stringified + ' ';\n        }\n      }\n    }\n    return res.slice(0, -1)\n  }\n  if (isObject(value)) {\n    for (var key in value) {\n      if (value[key]) { res += key + ' '; }\n    }\n    return res.slice(0, -1)\n  }\n  /* istanbul ignore next */\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute (node, key, val) {\n  node.setAttribute(key, val);\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tsetAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\n        refs[key].push(ref);\n      } else {\n        refs[key] = [ref];\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n\n/*\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key &&\n    a.tag === b.tag &&\n    a.isComment === b.isComment &&\n    isDef(a.data) === isDef(b.data) &&\n    sameInputType(a, b)\n  )\n}\n\n// Some browsers do not support dynamically changing type for <input>\n// so they need to be treated as different nodes\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  var inPre = 0;\n  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (data && data.pre) {\n          inPre++;\n        }\n        if (\n          !inPre &&\n          !vnode.ns &&\n          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\n          config.isUnknownElement(tag)\n        ) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (process.env.NODE_ENV !== 'production' && data && data.pre) {\n        inPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref) {\n    if (isDef(parent)) {\n      if (isDef(ref)) {\n        nodeOps.insertBefore(parent, elm, ref);\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    var ancestor = vnode;\n    while (ancestor) {\n      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n        nodeOps.setAttribute(vnode.elm, i, '');\n      }\n      ancestor = ancestor.parent;\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n        i !== vnode.context &&\n        isDef(i = i.$options._scopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !elmToMove) {\n            warn(\n              'It seems there are duplicate keys that is causing an update error. ' +\n              'Make sure each v-for item has a unique key.'\n            );\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n        isTrue(oldVnode.isStatic) &&\n        vnode.key === oldVnode.key &&\n        (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\n      vnode.elm = oldVnode.elm;\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n    var elm = vnode.elm = oldVnode.elm;\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          var childrenMatch = true;\n          var childNode = elm.firstChild;\n          for (var i$1 = 0; i$1 < children.length; i$1++) {\n            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n              childrenMatch = false;\n              break\n            }\n            childNode = childNode.nextSibling;\n          }\n          // if childNode is not null, it means the actual childNodes list is\n          // longer than the virtual children list.\n          if (!childrenMatch || childNode) {\n            if (process.env.NODE_ENV !== 'production' &&\n                typeof console !== 'undefined' &&\n                !bailed) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n            }\n            return false\n          }\n        }\n      }\n      if (isDef(data)) {\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode) {\n    if (isDef(vnode.tag)) {\n      return (\n        vnode.tag.indexOf('vue-component') === 0 ||\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {\n            oldVnode.removeAttribute('server-rendered');\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (process.env.NODE_ENV !== 'production') {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        if (isDef(vnode.parent)) {\n          // component root element replaced.\n          // update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          while (ancestor) {\n            ancestor.elm = vnode.elm;\n            ancestor = ancestor.parent;\n          }\n          if (isPatchable(vnode)) {\n            for (var i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (isDef(parentElm$1)) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  if (!oldVnode.data.attrs && !vnode.data.attrs) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (attrs.__ob__) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  /* istanbul ignore if */\n  if (isIE9 && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (attrs[key] == null) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, key);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (!data.staticClass && !data.class &&\n      (!oldData || (!oldData.staticClass && !oldData.class))) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (transitionClass) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n  }\n}\n\n/*  */\n\nfunction baseWarn (msg) {\n  console.error((\"[Vue compiler]: \" + msg));\n}\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n}\n\nfunction addAttr (el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  modifiers\n) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important\n) {\n  // check capture modifier\n  if (modifiers && modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  if (modifiers && modifiers.once) {\n    delete modifiers.once;\n    name = '~' + name; // mark the event as once\n  }\n  var events;\n  if (modifiers && modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n  var newHandler = { value: value, modifiers: modifiers };\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\nfunction getAndRemoveAttr (el, name) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  return val\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel (\n  el,\n  value,\n  modifiers\n) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression =\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\n        \"? \" + baseValueExpression + \".trim()\" +\n        \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: (\"(\" + value + \")\"),\n    expression: (\"\\\"\" + value + \"\\\"\"),\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode (\n  value,\n  assignment\n) {\n  var modelRs = parseModel(value);\n  if (modelRs.idx === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return \"var $$exp = \" + (modelRs.exp) + \", $$idx = \" + (modelRs.idx) + \";\" +\n      \"if (!Array.isArray($$exp)){\" +\n        value + \"=\" + assignment + \"}\" +\n      \"else{$$exp.splice($$idx, 1, \" + assignment + \")}\"\n  }\n}\n\n/**\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n *\n * for loop possible cases:\n *\n * - test\n * - test[idx]\n * - test[test1[idx]]\n * - test[\"a\"][idx]\n * - xxx.test[a[a].test1[idx]]\n * - test.xxx.a[\"asa\"][test1[idx]]\n *\n */\n\nvar len;\nvar str;\nvar chr;\nvar index$1;\nvar expressionPos;\nvar expressionEndPos;\n\nfunction parseModel (val) {\n  str = val;\n  len = str.length;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    return {\n      exp: val,\n      idx: null\n    }\n  }\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.substring(0, expressionPos),\n    idx: val.substring(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model (\n  el,\n  dir,\n  _warn\n) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (process.env.NODE_ENV !== 'production') {\n    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (tag === 'input' && dynamicType) {\n      warn$1(\n        \"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" +\n        \"v-model does not support dynamic input types. Use v-if branches instead.\"\n      );\n    }\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n        \"File inputs are read only. Use a v-on:change listener instead.\"\n      );\n    }\n  }\n\n  if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$1(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n      \"v-model is not supported on this element type. \" +\n      'If you are working with contenteditable, it\\'s recommended to ' +\n      'wrap a library dedicated for that purpose inside a custom component.'\n    );\n  }\n\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n        trueValueBinding === 'true'\n          ? (\":(\" + value + \")\")\n          : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n      )\n  );\n  addHandler(el, CHECKBOX_RADIO_TOKEN,\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$c){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" +\n      \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" +\n    \"}else{\" + value + \"=$$c}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + (genAssignmentCode(value, assignment));\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  var type = el.attrsMap.type;\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number || type === 'number') {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  var event;\n  /* istanbul ignore if */\n  if (on[RANGE_TOKEN]) {\n    // IE input[type=range] only supports `change` event\n    event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  if (on[CHECKBOX_RADIO_TOKEN]) {\n    // Chrome fires microtasks in between click/change, leads to #4521\n    event = isChrome ? 'click' : 'change';\n    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction add$1 (\n  event,\n  handler,\n  once,\n  capture\n) {\n  if (once) {\n    var oldHandler = handler;\n    var _target = target$1; // save current target element in closure\n    handler = function (ev) {\n      var res = arguments.length === 1\n        ? oldHandler(ev)\n        : oldHandler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, handler, capture, _target);\n      }\n    };\n  }\n  target$1.addEventListener(event, handler, capture);\n}\n\nfunction remove$2 (\n  event,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(event, handler, capture);\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (!oldVnode.data.on && !vnode.data.on) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (!oldVnode.data.domProps && !vnode.data.domProps) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (props.__ob__) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (props[key] == null) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = cur == null ? '' : String(cur);\n      if (shouldUpdateValue(elm, vnode, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (\n  elm,\n  vnode,\n  checkVal\n) {\n  return (!elm.composing && (\n    vnode.tag === 'option' ||\n    isDirty(elm, checkVal) ||\n    isInputChanged(elm, checkVal)\n  ))\n}\n\nfunction isDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value\n  return document.activeElement !== elm && elm.value !== checkVal\n}\n\nfunction isInputChanged (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if ((modifiers && modifiers.number) || elm.type === 'number') {\n    return toNumber(value) !== toNumber(newVal)\n  }\n  if (modifiers && modifiers.trim) {\n    return value.trim() !== newVal.trim()\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    el.style[normalize(name)] = val;\n  }\n};\n\nvar prefixes = ['Webkit', 'Moz', 'ms'];\n\nvar testEl;\nvar normalize = cached(function (prop) {\n  testEl = testEl || document.createElement('div');\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in testEl.style)) {\n    return prop\n  }\n  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefixed = prefixes[i] + upper;\n    if (prefixed in testEl.style) {\n      return prefixed\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (!data.staticStyle && !data.style &&\n      !oldData.staticStyle && !oldData.style) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldVnode.data.staticStyle;\n  var oldStyleBinding = oldVnode.data.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  vnode.data.style = style.__ob__ ? extend({}, style) : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (newStyle[name] == null) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    el.setAttribute('class', cur.trim());\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser && window.requestAnimationFrame\n  ? window.requestAnimationFrame.bind(window)\n  : setTimeout;\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n  addClass(el, cls);\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (el._leaveCb) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (el._enterCb || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n          pendingNode.tag === vnode.tag &&\n          pendingNode.elm._leaveCb) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        if (isValidDuration(explicitEnterDuration)) {\n          setTimeout(cb, explicitEnterDuration);\n        } else {\n          whenTransitionEnds(el, type, cb);\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (el._enterCb) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (el._leaveCb || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && explicitLeaveDuration != null) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          if (isValidDuration(explicitLeaveDuration)) {\n            setTimeout(cb, explicitLeaveDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (!fn) { return false }\n  var invokerFns = fn.fns;\n  if (invokerFns) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (!vnode.data.show) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (!vnode.data.show) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model$1 = {\n  inserted: function inserted (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      var cb = function () {\n        setSelected(el, binding, vnode.context);\n      };\n      cb();\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(cb, 0);\n      }\n    } else if (vnode.tag === 'textarea' || el.type === 'text' || el.type === 'password') {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var needReset = el.multiple\n        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })\n        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n      if (needReset) {\n        trigger(el, 'change');\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  for (var i = 0, l = options.length; i < l; i++) {\n    if (looseEqual(getValue(options[i]), value)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition && !isIE9) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    if (transition && !isIE9) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model$1,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  return /\\d-keep-alive$/.test(rawChild.tag)\n    ? h('keep-alive')\n    : null\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag; });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (process.env.NODE_ENV !== 'production' && children.length > 1) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (process.env.NODE_ENV !== 'production' &&\n        mode && mode !== 'in-out' && mode !== 'out-in') {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final desired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (process.env.NODE_ENV !== 'production') {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var body = document.body;\n    var f = body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      if (this._hasMove != null) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.mustUseProp = mustUseProp;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (process.env.NODE_ENV !== 'production' && isChrome) {\n      console[console.info ? 'info' : 'log'](\n        'Download the Vue Devtools extension for a better development experience:\\n' +\n        'https://github.com/vuejs/vue-devtools'\n      );\n    }\n  }\n  if (process.env.NODE_ENV !== 'production' &&\n      config.productionTip !== false &&\n      inBrowser && typeof console !== 'undefined') {\n    console[console.info ? 'info' : 'log'](\n      \"You are running Vue in development mode.\\n\" +\n      \"Make sure to turn on production mode when deploying for production.\\n\" +\n      \"See more tips at https://vuejs.org/guide/deployment.html\"\n    );\n  }\n}, 0);\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nfunction shouldDecode (content, encoded) {\n  var div = document.createElement('div');\n  div.innerHTML = \"<div a=\\\"\" + content + \"\\\">\";\n  return div.innerHTML.indexOf(encoded) > 0\n}\n\n// #3663\n// IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr'\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track'\n);\n\n/*  */\n\nvar decoder;\n\nfunction decode (html) {\n  decoder = decoder || document.createElement('div');\n  decoder.innerHTML = html;\n  return decoder.textContent\n}\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\nvar singleAttrAssign = /(?:=)/;\nvar singleAttrValues = [\n  // attr value double quotes\n  /\"([^\"]*)\"+/.source,\n  // attr value, single quotes\n  /'([^']*)'+/.source,\n  // attr value, no quotes\n  /([^\\s\"'=<>`]+)/.source\n];\nvar attribute = new RegExp(\n  '^\\\\s*' + singleAttrIdentifier.source +\n  '(?:\\\\s*(' + singleAttrAssign.source + ')' +\n  '\\\\s*(?:' + singleAttrValues.join('|') + '))?'\n);\n\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\nvar startTagOpen = new RegExp('^<' + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^<!--/;\nvar conditionalComment = /^<!\\[/;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n'\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) { return decodingMap[match]; })\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          continue\n        }\n      }\n\n      var text = (void 0), rest$1 = (void 0), next = (void 0);\n      if (textEnd >= 0) {\n        rest$1 = html.slice(textEnd);\n        while (\n          !endTag.test(rest$1) &&\n          !startTagOpen.test(rest$1) &&\n          !comment.test(rest$1) &&\n          !conditionalComment.test(rest$1)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest$1.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest$1 = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var endTagLength = 0;\n      var rest = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!--([\\s\\S]*?)-->/g, '$1')\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest.length;\n      html = rest;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"));\n      }\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') { delete args[3]; }\n        if (args[4] === '') { delete args[4]; }\n        if (args[5] === '') { delete args[5]; }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(\n          value,\n          options.shouldDecodeNewlines\n        )\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (process.env.NODE_ENV !== 'production' &&\n            (i > pos || !tagName) &&\n            options.warn) {\n          options.warn(\n            (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\")\n          );\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push(JSON.stringify(text.slice(lastIndex)));\n  }\n  return tokens.join('+')\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\nvar forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^v-bind:/;\nvar modifierRE = /\\.[^.]+/g;\n\nvar decodeHTMLCached = cached(decode);\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$2 = options.warn || baseWarn;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformIsPreTag = options.isPreTag || no;\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce (msg) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg);\n    }\n  }\n\n  function endPre (element) {\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    start: function start (tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = {\n        type: 1,\n        tag: tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        parent: currentParent,\n        children: []\n      };\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        process.env.NODE_ENV !== 'production' && warn$2(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.'\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        preTransforms[i](element, options);\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else {\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        processKey(element);\n\n        // determine whether this is a plain element after\n        // removing structural attributes\n        element.plain = !element.key && !attrs.length;\n\n        processRef(element);\n        processSlot(element);\n        processComponent(element);\n        for (var i$1 = 0; i$1 < transforms.length; i$1++) {\n          transforms[i$1](element, options);\n        }\n        processAttrs(element);\n      }\n\n      function checkRootConstraints (el) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (el.tag === 'slot' || el.tag === 'template') {\n            warnOnce(\n              \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n              'contain multiple nodes.'\n            );\n          }\n          if (el.attrsMap.hasOwnProperty('v-for')) {\n            warnOnce(\n              'Cannot use v-for on stateful component root element because ' +\n              'it renders multiple elements.'\n            );\n          }\n        }\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (!stack.length) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          checkRootConstraints(element);\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else if (process.env.NODE_ENV !== 'production') {\n          warnOnce(\n            \"Component template should contain exactly one root element. \" +\n            \"If you are using v-if on multiple elements, \" +\n            \"use v-else-if to chain them instead.\"\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else if (element.slotScope) { // scoped slot\n          currentParent.plain = false;\n          var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        endPre(element);\n      }\n      // apply post-transforms\n      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n        postTransforms[i$2](element, options);\n      }\n    },\n\n    end: function end () {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      endPre(element);\n    },\n\n    chars: function chars (text) {\n      if (!currentParent) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (text === template) {\n            warnOnce(\n              'Component template requires a root element, rather than just text.'\n            );\n          } else if ((text = text.trim())) {\n            warnOnce(\n              (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\")\n            );\n          }\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n          currentParent.tag === 'textarea' &&\n          currentParent.attrsMap.placeholder === text) {\n        return\n      }\n      var children = currentParent.children;\n      text = inPre || text.trim()\n        ? decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && children.length ? ' ' : '';\n      if (text) {\n        var expression;\n        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n          children.push({\n            type: 2,\n            expression: expression,\n            text: text\n          });\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {\n      warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) {\n      process.env.NODE_ENV !== 'production' && warn$2(\n        (\"Invalid v-for expression: \" + exp)\n      );\n      return\n    }\n    el.for = inMatch[2].trim();\n    var alias = inMatch[1].trim();\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      el.alias = iteratorMatch[1].trim();\n      el.iterator1 = iteratorMatch[2].trim();\n      if (iteratorMatch[3]) {\n        el.iterator2 = iteratorMatch[3].trim();\n      }\n    } else {\n      el.alias = alias;\n    }\n  }\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$2(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\"\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {\n        warn$2(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\"\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (process.env.NODE_ENV !== 'production' && el.key) {\n      warn$2(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\"\n      );\n    }\n  } else {\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    }\n    if (el.tag === 'template') {\n      el.slotScope = getAndRemoveAttr(el, 'scope');\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isProp = false;\n        if (modifiers) {\n          if (modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel) {\n            name = camelize(name);\n          }\n        }\n        if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (process.env.NODE_ENV !== 'production' && name === 'model') {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (process.env.NODE_ENV !== 'production') {\n        var expression = parseText(value, delimiters);\n        if (expression) {\n          warn$2(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.'\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value));\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (process.env.NODE_ENV !== 'production' && map[attrs[i].name] && !isIE) {\n      warn$2('duplicate attribute: ' + attrs[i].name);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\"\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic$1 (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      walkThroughConditionsBlocks(node.ifConditions, isInFor);\n    }\n  }\n}\n\nfunction walkThroughConditionsBlocks (conditionBlocks, isInFor) {\n  for (var i = 1, len = conditionBlocks.length; i < len; i++) {\n    markStaticRoots(conditionBlocks[i].block, isInFor);\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers (events, native) {\n  var res = native ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    res += \"\\\"\" + name + \"\\\":\" + (genHandler(name, events[name])) + \",\";\n  }\n  return res.slice(0, -1) + '}'\n}\n\nfunction genHandler (\n  name,\n  handler\n) {\n  if (!handler) {\n    return 'function(){}'\n  }\n\n  if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + \"]\")\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n\n  if (!handler.modifiers) {\n    return isMethodPath || isFunctionExpression\n      ? handler.value\n      : (\"function($event){\" + (handler.value) + \"}\") // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? handler.value + '($event)'\n      : isFunctionExpression\n        ? (\"(\" + (handler.value) + \")($event)\")\n        : handler.value;\n    return (\"function($event){\" + code + handlerCode + \"}\")\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\"if(!('button' in $event)&&\" + (keys.map(genFilterCode).join('&&')) + \")return null;\")\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var alias = keyCodes[key];\n  return (\"_k($event.keyCode,\" + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + \")\")\n}\n\n/*  */\n\nfunction bind$1 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\n// configurable state\nvar warn$3;\nvar transforms$1;\nvar dataGenFns;\nvar platformDirectives$1;\nvar isPlatformReservedTag$1;\nvar staticRenderFns;\nvar onceCount;\nvar currentOptions;\n\nfunction generate (\n  ast,\n  options\n) {\n  // save previous staticRenderFns so generate calls can be nested\n  var prevStaticRenderFns = staticRenderFns;\n  var currentStaticRenderFns = staticRenderFns = [];\n  var prevOnceCount = onceCount;\n  onceCount = 0;\n  currentOptions = options;\n  warn$3 = options.warn || baseWarn;\n  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');\n  dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  platformDirectives$1 = options.directives || {};\n  isPlatformReservedTag$1 = options.isReservedTag || no;\n  var code = ast ? genElement(ast) : '_c(\"div\")';\n  staticRenderFns = prevStaticRenderFns;\n  onceCount = prevOnceCount;\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: currentStaticRenderFns\n  }\n}\n\nfunction genElement (el) {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el);\n    } else {\n      var data = el.plain ? undefined : genData(el);\n\n      var children = el.inlineTemplate ? null : genChildren(el, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < transforms$1.length; i++) {\n      code = transforms$1[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el) {\n  el.staticProcessed = true;\n  staticRenderFns.push((\"with(this){return \" + (genElement(el)) + \"}\"));\n  return (\"_m(\" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      process.env.NODE_ENV !== 'production' && warn$3(\n        \"v-once can only be used inside v-for that is keyed. \"\n      );\n      return genElement(el)\n    }\n    return (\"_o(\" + (genElement(el)) + \",\" + (onceCount++) + (key ? (\",\" + key) : \"\") + \")\")\n  } else {\n    return genStatic(el)\n  }\n}\n\nfunction genIf (el) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice())\n}\n\nfunction genIfConditions (conditions) {\n  if (!conditions.length) {\n    return '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return el.once ? genOnce(el) : genElement(el)\n  }\n}\n\nfunction genFor (el) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key\n  ) {\n    warn$3(\n      \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n      \"v-for should have explicit keys. \" +\n      \"See https://vuejs.org/guide/list.html#key for more info.\",\n      true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genElement(el)) +\n    '})'\n}\n\nfunction genData (el) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < dataGenFns.length; i++) {\n    data += dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true)) + \",\";\n  }\n  // slot target\n  if (el.slotTarget) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el.scopedSlots)) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  return data\n}\n\nfunction genDirectives (el) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, warn$3);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el) {\n  var ast = el.children[0];\n  if (process.env.NODE_ENV !== 'production' && (\n    el.children.length > 1 || ast.type !== 1\n  )) {\n    warn$3('Inline-template components must have exactly one child element.');\n  }\n  if (ast.type === 1) {\n    var inlineRenderFns = generate(ast, currentOptions);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (slots) {\n  return (\"scopedSlots:_u([\" + (Object.keys(slots).map(function (key) { return genScopedSlot(key, slots[key]); }).join(',')) + \"])\")\n}\n\nfunction genScopedSlot (key, el) {\n  return \"[\" + key + \",function(\" + (String(el.attrsMap.scope)) + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? genChildren(el) || 'void 0'\n      : genElement(el)) + \"}]\"\n}\n\nfunction genChildren (el, checkSkip) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n        el$1.for &&\n        el$1.tag !== 'template' &&\n        el$1.tag !== 'slot') {\n      return genElement(el$1)\n    }\n    var normalizationType = checkSkip ? getNormalizationType(children) : 0;\n    return (\"[\" + (children.map(genNode).join(',')) + \"]\" + (normalizationType ? (\",\" + normalizationType) : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (children) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction maybeComponent (el) {\n  return !isPlatformReservedTag$1(el.tag)\n}\n\nfunction genNode (node) {\n  if (node.type === 1) {\n    return genElement(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genSlot (el) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs && (\"{\" + (el.attrs.map(function (a) { return ((camelize(a.name)) + \":\" + (a.value)); }).join(',')) + \"}\");\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (componentName, el) {\n  var children = el.inlineTemplate ? null : genChildren(el, true);\n  return (\"_c(\" + componentName + \",\" + (genData(el)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    res += \"\\\"\" + (prop.name) + \"\\\":\" + (transformSpecialNewlines(prop.value)) + \",\";\n  }\n  return res.slice(0, -1)\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\n  'delete,typeof,void'\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// check valid identifier for v-for\nvar identRE = /[A-Za-z_$][\\w$]*/;\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors\n}\n\nfunction checkNode (node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\n          } else if (onRE.test(name)) {\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkEvent (exp, text, errors) {\n  var keywordMatch = exp.replace(stripStringRE, '').match(unaryOperatorsRE);\n  if (keywordMatch) {\n    errors.push(\n      \"avoid using JavaScript unary operator as property name: \" +\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n    );\n  }\n  checkExpression(exp, text, errors);\n}\n\nfunction checkFor (node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier (ident, type, text, errors) {\n  if (typeof ident === 'string' && !identRE.test(ident)) {\n    errors.push((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())));\n  }\n}\n\nfunction checkExpression (exp, text, errors) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\n        \"avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n      );\n    } else {\n      errors.push((\"invalid expression: \" + (text.trim())));\n    }\n  }\n}\n\n/*  */\n\nfunction baseCompile (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  optimize(ast, options);\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n}\n\nfunction makeFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop\n  }\n}\n\nfunction createCompiler (baseOptions) {\n  var functionCompileCache = Object.create(null);\n\n  function compile (\n    template,\n    options\n  ) {\n    var finalOptions = Object.create(baseOptions);\n    var errors = [];\n    var tips = [];\n    finalOptions.warn = function (msg, tip$$1) {\n      (tip$$1 ? tips : errors).push(msg);\n    };\n\n    if (options) {\n      // merge custom modules\n      if (options.modules) {\n        finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n      }\n      // merge custom directives\n      if (options.directives) {\n        finalOptions.directives = extend(\n          Object.create(baseOptions.directives),\n          options.directives\n        );\n      }\n      // copy other options\n      for (var key in options) {\n        if (key !== 'modules' && key !== 'directives') {\n          finalOptions[key] = options[key];\n        }\n      }\n    }\n\n    var compiled = baseCompile(template, finalOptions);\n    if (process.env.NODE_ENV !== 'production') {\n      errors.push.apply(errors, detectErrors(compiled.ast));\n    }\n    compiled.errors = errors;\n    compiled.tips = tips;\n    return compiled\n  }\n\n  function compileToFunctions (\n    template,\n    options,\n    vm\n  ) {\n    options = options || {};\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn(\n            'It seems you are using the standalone build of Vue.js in an ' +\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\n            'The template compiler cannot work in this environment. Consider ' +\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n            'templates into render functions.'\n          );\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters\n      ? String(options.delimiters) + template\n      : template;\n    if (functionCompileCache[key]) {\n      return functionCompileCache[key]\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (process.env.NODE_ENV !== 'production') {\n      if (compiled.errors && compiled.errors.length) {\n        warn(\n          \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n          compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n          vm\n        );\n      }\n      if (compiled.tips && compiled.tips.length) {\n        compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = makeFunction(compiled.render, fnGenErrors);\n    var l = compiled.staticRenderFns.length;\n    res.staticRenderFns = new Array(l);\n    for (var i = 0; i < l; i++) {\n      res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i], fnGenErrors);\n    }\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn(\n          \"Failed to generate render function:\\n\\n\" +\n          fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n        }).join('\\n'),\n          vm\n        );\n      }\n    }\n\n    return (functionCompileCache[key] = res)\n  }\n\n  return {\n    compile: compile,\n    compileToFunctions: compileToFunctions\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (process.env.NODE_ENV !== 'production' && staticClass) {\n    var expression = parseText(staticClass, options.delimiters);\n    if (expression) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.'\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData$1\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      var expression = parseText(staticStyle, options.delimiters);\n      if (expression) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.'\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$2 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$2\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1\n];\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\nvar ref$1 = createCompiler(baseOptions);\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue$3.prototype.$mount;\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        delimiters: options.delimiters\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile end');\n        measure(((this._name) + \" compile\"), 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue$3.compile = compileToFunctions;\n\nexport default Vue$3;\n","\"use strict\";\n\nconst priceCurrencies = [{\n    id: \"dollar_us\",\n    name: \"US Dollar\",\n    label: \"$\",\n    val: 1\n}, {\n    id: \"euro\",\n    name: \"Euro\",\n    label: \"\",\n    val: 0.918603\n}, {\n    id: \"pound\",\n    name: \"Pound\",\n    label: \"\",\n    val: 0.793752\n}, {\n    id: \"dollar_ca\",\n    name: \"Canadian Dollar\",\n    label: \"$\",\n    val: 1.33448\n}, {\n    id: \"dollar_au\",\n    name: \"Australian Dollar\",\n    label: \"$\",\n    val: 1.30931\n}];\n\nexport default priceCurrencies;\n","\"use strict\";\n\nconst priceModes = [{\n    id: \"low\",\n    name: \"Low\",\n}, {\n    id: \"average\",\n    name: \"Average\",\n}, {\n    id: \"high\",\n    name: \"High\",\n}];\n\nexport default priceModes;\n","\"use strict\";\n\nconst deckParts = [{\n    id: \"main\",\n    name: \"Main\",\n    fileId: \"#main\",\n    size: [40, 60]\n}, {\n    id: \"extra\",\n    name: \"Extra\",\n    fileId: \"#extra\",\n    size: [0, 15]\n}, {\n    id: \"side\",\n    name: \"Side\",\n    fileId: \"!side\",\n    size: [0, 15]\n}];\n\nexport default deckParts;\n","\"use strict\";\n\nimport dataPriceCurrencies from \"./data/priceCurrencies\";\nimport dataPriceModes from \"./data/priceModes\";\nimport dataDeckParts from \"./data/deckParts\";\n\nconst appData = {\n    deckparts: dataDeckParts,\n    deck: {\n        name: \"Unnamed\",\n        link: \"\",\n        list: {\n            main: [],\n            extra: [],\n            side: []\n        }\n    },\n    cards: {\n        pairs: [],\n        data: {}\n    },\n    builder: {\n        filter: \"\",\n        pairsFiltered: [],\n    },\n    price: {\n        activeCurrency: \"dollar_us\",\n        modes: dataPriceModes,\n        currencies: dataPriceCurrencies\n    },\n    ajax: {\n        currentlyLoading: false,\n        namesLoaded: false,\n        pricesLoaded: false\n    }\n};\n\nexport default appData;\n","\"use strict\";\n\nconst uriLocationNoParam = function () {\n    return location.origin + location.pathname;\n};\n\nexport default uriLocationNoParam;\n","\"use strict\";\n\nconst eachObject = function (object, fn) {\n    const keys = Object.keys(object);\n    const l = keys.length;\n    let i = 0;\n\n    while (i < l) {\n        const currentKey = keys[i];\n\n        fn(object[currentKey], currentKey, i);\n        i++;\n    }\n};\n\nexport default eachObject;\n","\"use strict\";\n\nimport {\n    nameAPI,\n    imageAPI,\n    buyAPI\n} from \"../data/apiURLs\";\nimport utilEachObject from \"./utilEachObject\";\n\nconst apiLoadNames = function () {\n    const vm = this;\n\n    vm.ajax.currentlyLoading = true;\n    vm.ajax.namesLoaded = false;\n\n    fetch(nameAPI)\n        .then(response => {\n            return response.json();\n        })\n        .then(json => {\n            const resultData = {};\n            const resultPairs = [];\n            const nameStorage = [];\n\n            utilEachObject(json, (name, id) => {\n                resultData[id] = {\n                    name,\n                    img: `${imageAPI}/${id}.jpg`,\n                    link: `${buyAPI}${encodeURI(name)}`,\n                    price: false\n                };\n\n                //Only add each card once to pars, skip alternate arts\n                if (nameStorage.indexOf(name) === -1) {\n                    resultPairs.push([id, name]);\n                }\n\n                nameStorage.push(name);\n            });\n\n            vm.cards.data = resultData;\n            vm.cards.pairs = resultPairs.sort((a, b) => a[1].localeCompare(b[1]));\n            vm.builderUpdateNames();\n\n            vm.ajax.currentlyLoading = false;\n            vm.ajax.namesLoaded = true;\n        });\n};\n\nexport default apiLoadNames;\n","\"use strict\";\n\nexport const nameAPI = \"./api/names/names.min.json\";\nexport const priceAPI = \"./api/prices/prices.php?n=\";\nexport const imageAPI = \"https://ygoprodeck.com/pics\";\nexport const buyAPI = \"http://yugiohprices.com/card_price?name=\";\n","\"use strict\";\n\nimport {\n    priceAPI\n} from \"../data/apiURLs\";\n//import utilEachObject from \"./utilEachObject\";\n\nconst apiLoadPrices = function () {\n    const vm = this;\n    //Array of unique ids, minus the ones where prices were already loaded\n    const cardIds = vm.deckCardsWithoutPriceData();\n\n    if (cardIds.length > 0) {\n        const cardNames = cardIds.map(cardId => vm.cards.data[cardId].name);\n        const priceQuery = btoa(JSON.stringify(cardNames));\n\n        vm.ajax.currentlyLoading = true;\n        vm.ajax.pricesLoaded = false;\n\n        fetch(priceAPI + priceQuery)\n            .then(response => {\n                return response.json();\n            })\n            .then(json => {\n                cardIds.forEach((id, index) => {\n                    const priceData = json[index];\n                    const card = vm.cards.data[id];\n\n                    if (card) {\n                        card.price = {\n                            low: priceData.low,\n                            average: priceData.average,\n                            high: priceData.high\n                        };\n                    }\n                });\n\n                vm.ajax.currentlyLoading = false;\n                vm.ajax.pricesLoaded = true;\n            });\n    } else {\n        vm.ajax.pricesLoaded = true;\n    }\n};\n\nexport default apiLoadPrices;\n","\"use strict\";\n\nimport deckParts from \"../data/deckParts\";\n\nconst convertFileToDeck = function (fileContent) {\n    const fileContentTrimmed = fileContent.replace(/#created.+/, \"\").trim();\n    const arr = fileContentTrimmed.split(/[#!].+/g).splice(1);\n    const arrParts = arr.map(part => part.split(\"\\n\").filter(line => line.length > 1).map(Number));\n    const result = {};\n\n    deckParts.forEach((deckpart, index) => {\n        result[deckpart.id] = arrParts[index];\n    });\n\n    return result;\n};\n\nexport default convertFileToDeck;\n","\"use strict\";\n\nimport convertFileToDeck from \"./convertFileToDeck\";\n\nconst deckLoad = function (file) {\n    const reader = new FileReader();\n    const vm = this;\n\n    reader.onload = function (e) {\n        const fileContent = e.target.result;\n        const deckList = convertFileToDeck(fileContent);\n\n        vm.deck.name = file.name.replace(\".ydk\", \"\");\n        vm.deck.list = deckList;\n        vm.deckUpdate();\n    };\n\n    reader.readAsText(file);\n};\n\nexport default deckLoad;\n","\"use strict\";\n\nimport deckParts from \"../data/deckParts\";\n\nconst uriDeckDecode = function (deckUri) {\n    const deckArray = JSON.parse(atob(deckUri.replace(\"?d=\", \"\")));\n    const deckList = {};\n\n    deckParts.forEach((deckpart, index) => {\n        deckList[deckpart.id] = deckArray[1][index];\n    });\n\n    return [deckArray[0], deckList];\n};\n\nexport default uriDeckDecode;\n","\"use strict\";\n\nimport uriDeckDecode from \"./uriDeckDecode\";\n\nconst deckLoadUri = function (uriDeck) {\n    const vm = this;\n    const deckArray = uriDeckDecode(uriDeck);\n\n    vm.deck.name = deckArray[0];\n    vm.deck.list = deckArray[1];\n    vm.deckUpdate(uriDeck);\n};\n\nexport default deckLoadUri;\n","\"use strict\";\n\n\nconst uriDeckEncode = function (deck) {\n    const deckArray = [deck.name, Object.values(deck.list)];\n    const deckUri = btoa(JSON.stringify(deckArray));\n\n    return \"?d=\" + deckUri;\n};\n\nexport default uriDeckEncode;\n","\"use strict\";\n\nimport uriDeckEncode from \"./uriDeckEncode\";\n\nconst deckUpdate = function (deckLink) {\n    const vm = this;\n\n    vm.deck.link = deckLink || uriDeckEncode(vm.deck);\n    vm.ajax.pricesLoaded = false;\n};\n\nexport default deckUpdate;\n","\"use strict\";\n\nimport utilEachObject from \"./utilEachObject\";\n\nconst deckCardsWithoutPriceData = function () {\n    const vm = this;\n    const data = vm.cards.data;\n    const result = [];\n\n    utilEachObject(vm.deck.list, deckpart => {\n        deckpart.forEach(cardId => {\n            if (result.indexOf(cardId) === -1 && !data[cardId].price) {\n                result.push(cardId);\n            }\n        });\n    });\n\n    return result;\n};\n\nexport default deckCardsWithoutPriceData;\n","\"use strict\";\n\nconst priceConvert = function (price) {\n    const vm = this;\n    const currency = vm.price.currencies.find(item => item.id === vm.price.activeCurrency);\n    const val = (price * currency.val).toFixed(2);\n\n    return val + currency.label;\n};\n\nexport default priceConvert;\n","\"use strict\";\n\nconst priceForCard = function (id, mode) {\n    const vm = this;\n    const price = vm.cards.data[id].price[mode];\n\n    if (price) {\n        return vm.priceConvert(price);\n    } else {\n        return \"Not found\";\n    }\n};\n\nexport default priceForCard;\n","\"use strict\";\n\nimport utilEachObject from \"./utilEachObject\";\n\nconst priceForSection = function (section, mode) {\n    const priceSum = function (arr) {\n        let result = 0;\n\n        if (arr && arr.length) {\n            arr.forEach(id => {\n                const cardData = vm.cards.data[id];\n                if (cardData && cardData.price && cardData.price[mode]) {\n                    result += cardData.price[mode];\n                }\n            });\n        }\n\n        return result;\n    };\n    const vm = this;\n    let price = 0;\n\n    if (section === \"*\") {\n        utilEachObject(vm.deck.list, deckpart => {\n            price += priceSum(deckpart);\n        });\n    } else {\n        price = priceSum(vm.deck.list[section]);\n    }\n\n    return vm.priceConvert(price);\n};\n\nexport default priceForSection;\n","\"use strict\";\n\nconst builderUpdateNames = function () {\n    const vm = this;\n    const filter = vm.builder.filter.toLowerCase();\n    let result = vm.cards.pairs.filter(card => {\n        return card[1].toLowerCase().indexOf(filter) !== -1;\n    });\n\n    if (result.length > 500) {\n        result = result.splice(0, 500);\n    }\n\n    vm.builder.pairsFiltered = result;\n};\n\nexport default builderUpdateNames;\n","\"use strict\";\n\nconst builderDeckAdd = function (id, part) {\n    const vm = this;\n    const cardId = Number(id);\n    const deckPart = vm.deck.list[part];\n    const deckPartMax = vm.deckparts.find(deckpart => deckpart.id === part).size[1];\n\n    if (deckPart.length < deckPartMax && deckPart.filter(id => id === cardId).length < 3) {\n        deckPart.push(cardId);\n        vm.deckUpdate();\n    }\n};\n\nexport default builderDeckAdd;\n","\"use strict\";\n\nconst builderDeckRemove = function (id, part) {\n    const vm = this;\n    let foundCard = false;\n\n    vm.deck.list[part] = vm.deck.list[part].filter(cardId => {\n        if (!foundCard) {\n            if (id === cardId) {\n                foundCard = true;\n                return false;\n            }\n        }\n        return true;\n    });\n    vm.deckUpdate();\n};\n\nexport default builderDeckRemove;\n","/* FileSaver.js\n * A saveAs() FileSaver implementation.\n * 1.3.2\n * 2016-06-16 18:25:19\n *\n * By Eli Grey, http://eligrey.com\n * License: MIT\n *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md\n */\n\n/*global self */\n/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */\n\n/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */\n\nvar saveAs = saveAs || (function(view) {\n\t\"use strict\";\n\t// IE <10 is explicitly unsupported\n\tif (typeof view === \"undefined\" || typeof navigator !== \"undefined\" && /MSIE [1-9]\\./.test(navigator.userAgent)) {\n\t\treturn;\n\t}\n\tvar\n\t\t  doc = view.document\n\t\t  // only get URL when necessary in case Blob.js hasn't overridden it yet\n\t\t, get_URL = function() {\n\t\t\treturn view.URL || view.webkitURL || view;\n\t\t}\n\t\t, save_link = doc.createElementNS(\"http://www.w3.org/1999/xhtml\", \"a\")\n\t\t, can_use_save_link = \"download\" in save_link\n\t\t, click = function(node) {\n\t\t\tvar event = new MouseEvent(\"click\");\n\t\t\tnode.dispatchEvent(event);\n\t\t}\n\t\t, is_safari = /constructor/i.test(view.HTMLElement) || view.safari\n\t\t, is_chrome_ios =/CriOS\\/[\\d]+/.test(navigator.userAgent)\n\t\t, throw_outside = function(ex) {\n\t\t\t(view.setImmediate || view.setTimeout)(function() {\n\t\t\t\tthrow ex;\n\t\t\t}, 0);\n\t\t}\n\t\t, force_saveable_type = \"application/octet-stream\"\n\t\t// the Blob API is fundamentally broken as there is no \"downloadfinished\" event to subscribe to\n\t\t, arbitrary_revoke_timeout = 1000 * 40 // in ms\n\t\t, revoke = function(file) {\n\t\t\tvar revoker = function() {\n\t\t\t\tif (typeof file === \"string\") { // file is an object URL\n\t\t\t\t\tget_URL().revokeObjectURL(file);\n\t\t\t\t} else { // file is a File\n\t\t\t\t\tfile.remove();\n\t\t\t\t}\n\t\t\t};\n\t\t\tsetTimeout(revoker, arbitrary_revoke_timeout);\n\t\t}\n\t\t, dispatch = function(filesaver, event_types, event) {\n\t\t\tevent_types = [].concat(event_types);\n\t\t\tvar i = event_types.length;\n\t\t\twhile (i--) {\n\t\t\t\tvar listener = filesaver[\"on\" + event_types[i]];\n\t\t\t\tif (typeof listener === \"function\") {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlistener.call(filesaver, event || filesaver);\n\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\tthrow_outside(ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t, auto_bom = function(blob) {\n\t\t\t// prepend BOM for UTF-8 XML and text/* types (including HTML)\n\t\t\t// note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF\n\t\t\tif (/^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(blob.type)) {\n\t\t\t\treturn new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});\n\t\t\t}\n\t\t\treturn blob;\n\t\t}\n\t\t, FileSaver = function(blob, name, no_auto_bom) {\n\t\t\tif (!no_auto_bom) {\n\t\t\t\tblob = auto_bom(blob);\n\t\t\t}\n\t\t\t// First try a.download, then web filesystem, then object URLs\n\t\t\tvar\n\t\t\t\t  filesaver = this\n\t\t\t\t, type = blob.type\n\t\t\t\t, force = type === force_saveable_type\n\t\t\t\t, object_url\n\t\t\t\t, dispatch_all = function() {\n\t\t\t\t\tdispatch(filesaver, \"writestart progress write writeend\".split(\" \"));\n\t\t\t\t}\n\t\t\t\t// on any filesys errors revert to saving with object URLs\n\t\t\t\t, fs_error = function() {\n\t\t\t\t\tif ((is_chrome_ios || (force && is_safari)) && view.FileReader) {\n\t\t\t\t\t\t// Safari doesn't allow downloading of blob urls\n\t\t\t\t\t\tvar reader = new FileReader();\n\t\t\t\t\t\treader.onloadend = function() {\n\t\t\t\t\t\t\tvar url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');\n\t\t\t\t\t\t\tvar popup = view.open(url, '_blank');\n\t\t\t\t\t\t\tif(!popup) view.location.href = url;\n\t\t\t\t\t\t\turl=undefined; // release reference before dispatching\n\t\t\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t\t\t\tdispatch_all();\n\t\t\t\t\t\t};\n\t\t\t\t\t\treader.readAsDataURL(blob);\n\t\t\t\t\t\tfilesaver.readyState = filesaver.INIT;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// don't create more object URLs than needed\n\t\t\t\t\tif (!object_url) {\n\t\t\t\t\t\tobject_url = get_URL().createObjectURL(blob);\n\t\t\t\t\t}\n\t\t\t\t\tif (force) {\n\t\t\t\t\t\tview.location.href = object_url;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar opened = view.open(object_url, \"_blank\");\n\t\t\t\t\t\tif (!opened) {\n\t\t\t\t\t\t\t// Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html\n\t\t\t\t\t\t\tview.location.href = object_url;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t\tdispatch_all();\n\t\t\t\t\trevoke(object_url);\n\t\t\t\t}\n\t\t\t;\n\t\t\tfilesaver.readyState = filesaver.INIT;\n\n\t\t\tif (can_use_save_link) {\n\t\t\t\tobject_url = get_URL().createObjectURL(blob);\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tsave_link.href = object_url;\n\t\t\t\t\tsave_link.download = name;\n\t\t\t\t\tclick(save_link);\n\t\t\t\t\tdispatch_all();\n\t\t\t\t\trevoke(object_url);\n\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfs_error();\n\t\t}\n\t\t, FS_proto = FileSaver.prototype\n\t\t, saveAs = function(blob, name, no_auto_bom) {\n\t\t\treturn new FileSaver(blob, name || blob.name || \"download\", no_auto_bom);\n\t\t}\n\t;\n\t// IE 10+ (native saveAs)\n\tif (typeof navigator !== \"undefined\" && navigator.msSaveOrOpenBlob) {\n\t\treturn function(blob, name, no_auto_bom) {\n\t\t\tname = name || blob.name || \"download\";\n\n\t\t\tif (!no_auto_bom) {\n\t\t\t\tblob = auto_bom(blob);\n\t\t\t}\n\t\t\treturn navigator.msSaveOrOpenBlob(blob, name);\n\t\t};\n\t}\n\n\tFS_proto.abort = function(){};\n\tFS_proto.readyState = FS_proto.INIT = 0;\n\tFS_proto.WRITING = 1;\n\tFS_proto.DONE = 2;\n\n\tFS_proto.error =\n\tFS_proto.onwritestart =\n\tFS_proto.onprogress =\n\tFS_proto.onwrite =\n\tFS_proto.onabort =\n\tFS_proto.onerror =\n\tFS_proto.onwriteend =\n\t\tnull;\n\n\treturn saveAs;\n}(\n\t   typeof self !== \"undefined\" && self\n\t|| typeof window !== \"undefined\" && window\n\t|| this.content\n));\n// `self` is undefined in Firefox for Android content script context\n// while `this` is nsIContentFrameMessageManager\n// with an attribute `content` that corresponds to the window\n\nif (typeof module !== \"undefined\" && module.exports) {\n  module.exports.saveAs = saveAs;\n} else if ((typeof define !== \"undefined\" && define !== null) && (define.amd !== null)) {\n  define(\"FileSaver.js\", function() {\n    return saveAs;\n  });\n}\n","\"use strict\";\n\nimport deckParts from \"../data/deckParts\";\n\nconst convertDeckToFile = function (deckList) {\n    let result = [];\n\n    deckParts.forEach(deckpart => {\n        result.push(deckpart.fileId);\n        result = result.concat(deckList[deckpart.id]);\n    });\n\n    return result.join(\"\\n\");\n};\n\nexport default convertDeckToFile;\n","\"use strict\";\n\nimport FileSaver from \"file-saver/FileSaver.js\";\n\nimport convertDeckToFile from \"./convertDeckToFile.js\";\n\nconst fileDownloadDeck = function () {\n    const vm = this;\n    const fileData = convertDeckToFile(vm.deck.list);\n    const file = new File([fileData], vm.deck.name + \".ydk\", {\n        type: \"text/ydk\"\n    });\n\n    return FileSaver.saveAs(file);\n};\n\nexport default fileDownloadDeck;\n","\"use strict\";\n\nimport uriLocationNoParam from \"./methods/uriLocationNoParam\";\n\nimport apiLoadNames from \"./methods/apiLoadNames\";\nimport apiLoadPrices from \"./methods/apiLoadPrices\";\n\nimport deckLoad from \"./methods/deckLoad\";\nimport deckLoadUri from \"./methods/deckLoadUri\";\nimport deckUpdate from \"./methods/deckUpdate\";\nimport deckCardsWithoutPriceData from \"./methods/deckCardsWithoutPriceData\";\n\nimport priceConvert from \"./methods/priceConvert\";\nimport priceForCard from \"./methods/priceForCard\";\nimport priceForSection from \"./methods/priceForSection\";\n\nimport builderUpdateNames from \"./methods/builderUpdateNames\";\nimport builderDeckAdd from \"./methods/builderDeckAdd\";\nimport builderDeckRemove from \"./methods/builderDeckRemove\";\n\nimport fileDownloadDeck from \"./methods/fileDownloadDeck\";\n\nconst appMethods = {\n    uriLocationNoParam,\n\n    apiLoadNames,\n    apiLoadPrices,\n\n    deckLoad,\n    deckLoadUri,\n    deckUpdate,\n    deckCardsWithoutPriceData,\n\n    priceConvert,\n    priceForCard,\n    priceForSection,\n\n    builderUpdateNames,\n    builderDeckAdd,\n    builderDeckRemove,\n\n    fileDownloadDeck,\n\n    onFileChange(e) {\n        const vm = this;\n        const files = e.target.files || e.dataTransfer.files;\n\n        vm.deckLoad(files[0]);\n    }\n};\n\nexport default appMethods;\n","\"use strict\";\n\nimport Vue from \"vue/dist/vue.esm.js\";\nimport appData from \"./appData\";\nimport appMethods from \"./appMethods\";\n\n//ready-event required because ygoprodeck.com loads scripts in head\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n    const urlQuery = location.search;\n    const priceApp = new Vue({\n        el: \"#app\",\n        data: appData,\n        methods: appMethods\n    });\n\n    priceApp.apiLoadNames();\n\n    if (urlQuery.indexOf(\"?d\") !== -1) {\n        priceApp.deckLoadUri(urlQuery);\n    }\n});\n"],"names":["_toString","val","JSON","stringify","String","toNumber","n","parseFloat","isNaN","makeMap","str","expectsLowerCase","map","Object","create","list","split","i","length","toLowerCase","remove","arr","item","index","indexOf","splice","hasOwn","obj","key","hasOwnProperty","call","isPrimitive","value","cached","fn","cache","bind","ctx","boundFn","a","l","arguments","apply","_length","toArray","start","ret","Array","extend","to","_from","isObject","isPlainObject","toString","OBJECT_STRING","toObject","res","noop","looseEqual","b","isObjectA","isObjectB","e","looseIndexOf","once","called","isReserved","c","charCodeAt","def","enumerable","defineProperty","parsePath","path","bailRE","test","segments","isNative","Ctor","pushTarget","_target","Dep","target","push","popTarget","targetStack","pop","protoAugment","src","__proto__","copyAugment","keys","observe","asRootData","ob","__ob__","Observer","observerState","shouldConvert","isServerRendering","isArray","isExtensible","_isVue","vmCount","defineReactive$$1","customSetter","dep","property","getOwnPropertyDescriptor","configurable","getter","get","setter","set","childOb","depend","newVal","notify","Math","max","del","dependArray","mergeData","from","toVal","fromVal","mergeHook","parentVal","childVal","concat","mergeAssets","normalizeProps","options","props","name","camelize","type","normalizeDirectives","dirs","directives","update","mergeOptions","parent","child","vm","mergeField","strat","strats","defaultStrat","extendsFrom","extends","mixins","mixin","prototype","Vue$3","resolveAsset","id","warnMissing","assets","camelizedId","PascalCaseId","capitalize","validateProp","propOptions","propsData","prop","absent","isType","Boolean","hyphenate","undefined","getPropDefaultValue","prevShouldConvert","default","$options","_props","getType","match","len","handleError","err","info","config","errorHandler","inBrowser","console","error","createTextVNode","VNode","cloneVNode","vnode","cloned","tag","data","children","text","elm","context","componentOptions","ns","isStatic","isCloned","cloneVNodes","vnodes","createFnInvoker","fns","invoker","arguments$1","updateListeners","on","oldOn","add","remove$$1","cur","old","event","normalizeEvent","capture","mergeVNodeHook","hookKey","hook","wrappedHook","this","oldHook","merged","simpleNormalizeChildren","normalizeChildren","normalizeArrayChildren","nestedIndex","last","getFirstComponentChild","filter","initEvents","_events","_hasHookEvent","listeners","_parentListeners","once$$1","$once","$on","remove$1","$off","updateComponentListeners","oldListeners","resolveSlots","slots","defaultSlot","functionalContext","slot","every","isWhitespace","node","isComment","resolveScopedSlots","initLifecycle","abstract","$parent","$children","$root","$refs","_watcher","_inactive","_directInactive","_isMounted","_isDestroyed","_isBeingDestroyed","mountComponent","el","hydrating","$el","render","createEmptyVNode","updateComponent","_update","_render","Watcher","$vnode","updateChildComponent","parentVnode","renderChildren","hasChildren","_renderChildren","scopedSlots","$scopedSlots","emptyObject","_parentVnode","_vnode","propKeys","_propKeys","$slots","$forceUpdate","isInInactiveTree","activateChildComponent","direct","deactivateChildComponent","callHook","handlers","j","$emit","resetSchedulerState","flushing","flushSchedulerQueue","watcher","sort","queue","run","oldQueue","slice","devtools","emit","queueWatcher","has","waiting","traverse","clear","seenObjects","_traverse","seen","isA","depId","proxy","sourceKey","sharedPropertyDefinition","initState","_watchers","opts","methods","_data","computed","watch","initProps","propsOptions","isRoot","initData","getData","initComputed","watchers","_computedWatchers","userDef","computedWatcherOptions","defineComputed","createComputedGetter","dirty","evaluate","initMethods","initWatch","handler","createWatcher","$watch","createComponent","baseCtor","_base","cid","resolved","resolveAsyncComponent","model","extractProps","functional","createFunctionalComponent","nativeOn","_context","h","d","createElement","createComponentInstanceForVnode","parentElm","refElm","vnodeComponentOptions","inlineTemplate","staticRenderFns","factory","cb","requested","cbs","pendingCallbacks","sync","resolve","reject","reason","then","attrs","domProps","altKey","checkProp","hash","preserve","mergeHooks","hooksToMerge","fromParent","ours","componentVNodeHooks","mergeHook$1","one","two","transformModel","callback","normalizationType","alwaysNormalize","ALWAYS_NORMALIZE","_createElement","SIMPLE_NORMALIZE","getTagNamespace","isReservedTag","parsePlatformTagName","applyNS","renderList","renderSlot","fallback","bindObject","scopedSlotFn","slotNodes","resolveFilter","identity","checkKeyCodes","eventKeyCode","builtInAlias","keyCodes","bindObjectProps","asProp","mustUseProp","renderStatic","isInFor","tree","_staticTrees","_renderProxy","markOnce","markStatic","isOnce","markStaticNode","initRender","renderContext","_c","$createElement","initProvide","provide","_provided","initInjections","inject","hasSymbol","Reflect","ownKeys","provideKey","source","initInternalComponent","constructor","_componentTag","_parentElm","_refElm","resolveConstructorOptions","super","superOptions","modifiedOptions","resolveModifiedOptions","extendOptions","components","modified","latest","sealed","sealedOptions","dedupe","_init","initUse","Vue","use","plugin","installed","args","unshift","install","initMixin$1","initExtend","Super","SuperId","cachedCtors","_Ctor","Sub","_assetTypes","forEach","initProps$1","Comp","initComputed$1","initAssetRegisters","definition","getComponentName","matches","pattern","RegExp","pruneCache","cachedNode","pruneCacheEntry","componentInstance","$destroy","genClassForVnode","parentNode","childNode","mergeClassData","genClassFromData","staticClass","class","dynamicClass","stringifyClass","stringified","isSVG","isUnknownElement","unknownElementCache","document","window","HTMLUnknownElement","HTMLElement","query","selected","querySelector","createElement$1","tagName","multiple","setAttribute","createElementNS","namespace","namespaceMap","createTextNode","createComment","insertBefore","newNode","referenceNode","removeChild","appendChild","nextSibling","setTextContent","textContent","registerRef","isRemoval","ref","refs","refInFor","isUndef","v","isDef","isTrue","sameVnode","sameInputType","createKeyToOldIdx","beginIdx","endIdx","updateDirectives","oldVnode","oldDir","dir","isCreate","emptyNode","isDestroy","oldDirs","normalizeDirectives$1","newDirs","dirsWithInsert","dirsWithPostpatch","oldValue","componentUpdated","inserted","callInsert","modifiers","emptyModifiers","getRawDirName","rawName","join","callHook$1","updateAttrs","oldAttrs","isIE9","isXlink","removeAttributeNS","xlinkNS","getXlinkProp","isEnumeratedAttr","removeAttribute","setAttr","isBooleanAttr","isFalsyAttrValue","setAttributeNS","updateClass","oldData","cls","transitionClass","_transitionClasses","_prevClass","parseFilters","exp","pushFilter","filters","lastFilterIndex","trim","prev","expression","inSingle","inDouble","inTemplateString","inRegex","curly","square","paren","p","charAt","validDivisionCharRE","wrapFilter","baseWarn","msg","pluckModuleFunction","modules","m","_","addProp","addAttr","addDirective","arg","addHandler","important","events","native","nativeEvents","newHandler","getBindingAttr","getStatic","dynamicValue","getAndRemoveAttr","staticValue","attrsMap","attrsList","genComponentModel","number","valueExpression","assignment","genAssignmentCode","modelRs","parseModel","idx","expressionPos","expressionEndPos","lastIndexOf","eof","next","isStringStart","chr","substring","index$1","parseBracket","inBracket","parseString","stringQuote","_warn","genCheckboxModel","valueBinding","trueValueBinding","falseValueBinding","CHECKBOX_RADIO_TOKEN","genRadioModel","genSelect","selectedVal","code","genDefaultModel","lazy","needCompositionGuard","RANGE_TOKEN","normalizeEvents","isIE","isChrome","add$1","oldHandler","target$1","ev","addEventListener","remove$2","removeEventListener","updateDOMListeners","updateDOMProps","oldProps","_value","strCur","shouldUpdateValue","checkVal","composing","isDirty","isInputChanged","activeElement","_vModifiers","normalizeStyleData","style","normalizeStyleBinding","staticStyle","bindingStyle","parseStyleText","getStyle","checkChild","styleData","updateStyle","oldStaticStyle","oldStyleBinding","oldStyle","newStyle","addClass","classList","getAttribute","removeClass","tar","replace","resolveTransition","def$$1","css","autoCssTransition","nextFrame","addTransitionClass","removeTransitionClass","whenTransitionEnds","expectedType","getTransitionInfo","timeout","propCount","TRANSITION","transitionEndEvent","animationEndEvent","ended","end","onEnd","styles","getComputedStyle","transitionDelays","transitionProp","transitionDurations","transitionTimeout","getTimeout","animationDelays","animationProp","animationDurations","animationTimeout","ANIMATION","transformRE","delays","durations","toMs","s","Number","enter","toggleDisplay","_leaveCb","cancelled","transition","_enterCb","nodeType","enterClass","enterToClass","enterActiveClass","appearClass","appearToClass","appearActiveClass","beforeEnter","afterEnter","enterCancelled","beforeAppear","appear","afterAppear","appearCancelled","duration","activeInstance","transitionNode","isAppear","isRootInsert","startClass","activeClass","toClass","beforeEnterHook","enterHook","afterEnterHook","enterCancelledHook","explicitEnterDuration","expectsCSS","userWantsControl","getHookArgumentsLength","show","pendingNode","_pending","isValidDuration","leave","rm","performLeave","beforeLeave","leaveClass","leaveActiveClass","leaveToClass","explicitLeaveDuration","afterLeave","leaveCancelled","delayLeave","invokerFns","_enter","setSelected","binding","isMultiple","option","getValue","selectedIndex","hasNoMatchingOption","onCompositionStart","onCompositionEnd","trigger","createEvent","initEvent","dispatchEvent","locateNode","getRealChild","compOptions","extractTransitionData","comp","key$1","placeholder","rawChild","hasParentTransition","isSameChild","oldChild","callPendingCbs","_moveCb","recordPosition","newPos","getBoundingClientRect","applyTranslation","oldPos","pos","dx","left","dy","top","moved","transform","WebkitTransform","transitionDuration","decode","html","decoder","innerHTML","decodeAttr","shouldDecodeNewlines","re","encodedAttrWithNewLines","encodedAttr","decodingMap","parseHTML","advance","parseEndTag","lowerCasedTagName","stack","lowerCasedTag","lastTag","expectHTML","isUnaryTag$$1","isUnaryTag","no","canBeLeftOpenTag$$1","canBeLeftOpenTag","isPlainTextElement","stackedTag","reStackedTag","reCache","endTagLength","rest","all","endTag","chars","textEnd","comment","commentEnd","conditionalComment","conditionalEnd","doctypeMatch","doctype","endTagMatch","curIndex","startTagMatch","startTagOpen","attr","startTagClose","attribute","unarySlash","isNonPhrasingTag","unary","IS_REGEX_CAPTURING_BROKEN","rest$1","parseText","delimiters","tagRE","buildRegex","defaultTagRE","tokens","lastIndex","exec","parse","template","endPre","element","pre","platformIsPreTag","warn","isPreTag","root","currentParent","preserveWhitespace","inVPre","inPre","warn$2","platformGetTagNamespace","guardIESVGBug","makeAttrsMap","isForbiddenTag","forbidden","preTransforms","plain","i$1","transforms","if","elseif","else","slotScope","slotTarget","i$2","postTransforms","lastNode","decodeHTMLCached","processPre","processRawAttrs","processKey","processRef","checkInFor","processFor","inMatch","forAliasRE","for","alias","iteratorMatch","forIteratorRE","iterator1","iterator2","processIf","processIfConditions","findPrevElement","addIfCondition","condition","ifConditions","processOnce","processSlot","slotName","processComponent","component","processAttrs","isProp","dirRE","hasBindings","parseModifiers","modifierRE","bindRE","camel","platformMustUseProp","onRE","argMatch","argRE","ieNSBug","ieNSPrefix","optimize","genStaticKeysCached","staticKeys","genStaticKeys$1","markStatic$1","static","isPlatformReservedTag","markStaticRoots","staticInFor","staticRoot","walkThroughConditionsBlocks","conditionBlocks","block","isBuiltInTag","isDirectChildOfTemplateFor","isStaticKey","genHandlers","genHandler","isMethodPath","simplePathRE","isFunctionExpression","fnExpRE","genModifierCode","modifierCode","genKeyFilter","genFilterCode","keyVal","parseInt","bind$1","wrapData","generate","ast","prevStaticRenderFns","currentStaticRenderFns","prevOnceCount","onceCount","genElement","staticProcessed","genStatic","onceProcessed","genOnce","forProcessed","genFor","ifProcessed","genIf","genSlot","genComponent","genData","genChildren","transforms$1","genIfConditions","conditions","genTernaryExp","shift","genDirectives","dataGenFns","genProps","genScopedSlots","genInlineTemplate","needRuntime","hasRuntime","gen","platformDirectives$1","baseDirectives","warn$3","inlineRenderFns","currentOptions","genScopedSlot","scope","checkSkip","el$1","getNormalizationType","genNode","needsNormalization","some","maybeComponent","isPlatformReservedTag$1","genText","transformSpecialNewlines","bind$$1","componentName","baseCompile","makeFunction","errors","Function","transformNode","classBinding","genData$1","transformNode$1","styleBinding","genData$2","getOuterHTML","outerHTML","container","cloneNode","_isServer","_Set","toUpperCase","freeze","hasProto","UA","navigator","userAgent","isEdge","isAndroid","isIOS","global","env","VUE_ENV","__VUE_DEVTOOLS_GLOBAL_HOOK__","Symbol","nextTick","nextTickHandler","copies","callbacks","timerFunc","pending","Promise","logError","catch","MutationObserver","counter","observer","textNode","_resolve","Set","uid$1","subs","addSub","sub","removeSub","addDep","arrayProto","arrayMethods","method","original","result","observeArray","arrayKeys","getOwnPropertyNames","walk","items","optionMergeStrategies","instanceData","defaultData","_lifecycleHooks","raw","prototypeAccessors","defineProperties","uid$2","expOrFn","deep","user","active","deps","newDeps","depIds","newDepIds","cleanupDeps","this$1","tmp","teardown","$mount","keepAlive","mountedNode","prepatch","uid","_uid","_isComponent","_self","dataDef","propsDef","$set","$delete","immediate","hookRE","prevEl","prevVnode","prevActiveInstance","__patch__","__vue__","$nextTick","_o","_n","_s","_l","_t","_q","_i","_m","_f","_k","_b","_v","_e","_u","patternTypes","KeepAlive","include","exclude","builtInComponents","configDef","util","delete","version","warn$1","testEl","acceptValue","isHTMLTag","nodeOps","hooks","baseModules","klass","cssText","cssVarRE","importantRE","setProp","setProperty","normalize","prefixes","upper","prefixed","hasTransition","ontransitionend","onwebkittransitionend","onanimationend","onwebkitanimationend","raf","requestAnimationFrame","setTimeout","platformModules","patch","backend","emptyNodeAt","createRmCb","childElm","removeNode","createElm","insertedVnodeQueue","nested","isReactivated","init","initComponent","pendingInsert","isPatchable","reactivateComponent","innerNode","activate","insert","createChildren","invokeCreateHooks","setScope","ancestor","_scopeId","addVnodes","startIdx","invokeDestroyHook","destroy","removeVnodes","ch","removeAndInvokeRemoveHook","updateChildren","oldCh","newCh","removeOnly","oldKeyToIdx","idxInOld","elmToMove","oldStartIdx","newStartIdx","oldEndIdx","oldStartVnode","oldEndVnode","newEndIdx","newStartVnode","newEndVnode","canMove","patchVnode","postpatch","invokeInsertHook","initial","hydrate","hasChildNodes","childrenMatch","firstChild","isRenderedModule","isInitialPatch","isRealElement","hasAttribute","oldElm","parentElm$1","vmodel","model$1","originalDisplay","__vOriginalDisplay","display","platformDirectives","transitionProps","Transition","mode","_leaving","oldRawChild","delayedLeave","TransitionGroup","prevChildren","rawChildren","transitionData","kept","removed","c$1","moveClass","hasMove","body","offsetHeight","propertyName","_hasMove","clone","hasTransform","platformComponents","content","encoded","div","singleAttrValues","ncname","g","open","close","genGuard","klass$1","style$1","modules$1","directives$1","baseOptions","reduce","ref$1","compile","finalOptions","tips","tip$$1","compiled","compileToFunctions","functionCompileCache","fnGenErrors","idToTemplate","mount","documentElement","priceCurrencies","priceModes","deckParts","appData","dataDeckParts","dataPriceModes","dataPriceCurrencies","uriLocationNoParam","location","origin","pathname","eachObject","object","currentKey","apiLoadNames","ajax","currentlyLoading","namesLoaded","response","json","resultData","resultPairs","nameStorage","imageAPI","encodeURI","cards","pairs","localeCompare","builderUpdateNames","apiLoadPrices","cardIds","deckCardsWithoutPriceData","cardNames","cardId","priceQuery","btoa","pricesLoaded","priceData","card","price","low","average","high","convertFileToDeck","fileContent","fileContentTrimmed","arrParts","part","line","deckpart","deckLoad","file","reader","FileReader","onload","deckList","deck","deckUpdate","readAsText","uriDeckDecode","deckUri","deckArray","atob","deckLoadUri","uriDeck","uriDeckEncode","values","deckLink","link","priceConvert","currency","currencies","find","activeCurrency","toFixed","label","priceForCard","priceForSection","section","priceSum","cardData","builder","pairsFiltered","builderDeckAdd","deckPart","deckPartMax","deckparts","size","builderDeckRemove","foundCard","saveAs","view","doc","get_URL","URL","webkitURL","save_link","can_use_save_link","click","MouseEvent","is_safari","safari","is_chrome_ios","throw_outside","ex","setImmediate","revoke","revoker","revokeObjectURL","dispatch","filesaver","event_types","listener","auto_bom","blob","Blob","fromCharCode","FileSaver","no_auto_bom","object_url","force","dispatch_all","readyState","INIT","createObjectURL","href","download","DONE","onloadend","url","readAsDataURL","FS_proto","msSaveOrOpenBlob","abort","WRITING","onwritestart","onprogress","onwrite","onabort","onerror","onwriteend","self","module","exports","convertDeckToFile","fileId","fileDownloadDeck","fileData","File","appMethods","files","dataTransfer","urlQuery","search","priceApp"],"mappings":"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","preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjpudWxsLCJzb3VyY2VzIjpbIi9tbnQvYy93b3Jrc3BhY2Uvd3d3L3lnb2RlY2twcmljZS9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmVzbS5qcyIsIi9tbnQvYy93b3Jrc3BhY2Uvd3d3L3lnb2RlY2twcmljZS9zcmMvanMvZGF0YS9wcmljZUN1cnJlbmNpZXMuanMiLCIvbW50L2Mvd29ya3NwYWNlL3d3dy95Z29kZWNrcHJpY2Uvc3JjL2pzL2RhdGEvcHJpY2VNb2Rlcy5qcyIsIi9tbnQvYy93b3Jrc3BhY2Uvd3d3L3lnb2RlY2twcmljZS9zcmMvanMvZGF0YS9kZWNrUGFydHMuanMiLCIvbW50L2Mvd29ya3NwYWNlL3d3dy95Z29kZWNrcHJpY2Uvc3JjL2pzL2FwcERhdGEuanMiLCIvbW50L2Mvd29ya3NwYWNlL3d3dy95Z29kZWNrcHJpY2Uvc3JjL2pzL21ldGhvZHMvdXJpTG9jYXRpb25Ob1BhcmFtLmpzIiwiL21udC9jL3dvcmtzcGFjZS93d3cveWdvZGVja3ByaWNlL3NyYy9qcy9tZXRob2RzL3V0aWxFYWNoT2JqZWN0LmpzIiwiL21udC9jL3dvcmtzcGFjZS93d3cveWdvZGVja3ByaWNlL3NyYy9qcy9tZXRob2RzL2FwaUxvYWROYW1lcy5qcyIsIi9tbnQvYy93b3Jrc3BhY2Uvd3d3L3lnb2RlY2twcmljZS9zcmMvanMvZGF0YS9hcGlVUkxzLmpzIiwiL21udC9jL3dvcmtzcGFjZS93d3cveWdvZGVja3ByaWNlL3NyYy9qcy9tZXRob2RzL2FwaUxvYWRQcmljZXMuanMiLCIvbW50L2Mvd29ya3NwYWNlL3d3dy95Z29kZWNrcHJpY2Uvc3JjL2pzL21ldGhvZHMvY29udmVydEZpbGVUb0RlY2suanMiLCIvbW50L2Mvd29ya3NwYWNlL3d3dy95Z29kZWNrcHJpY2Uvc3JjL2pzL21ldGhvZHMvZGVja0xvYWQuanMiLCIvbW50L2Mvd29ya3NwYWNlL3d3dy95Z29kZWNrcHJpY2Uvc3JjL2pzL21ldGhvZHMvdXJpRGVja0RlY29kZS5qcyIsIi9tbnQvYy93b3Jrc3BhY2Uvd3d3L3lnb2RlY2twcmljZS9zcmMvanMvbWV0aG9kcy9kZWNrTG9hZFVyaS5qcyIsIi9tbnQvYy93b3Jrc3BhY2Uvd3d3L3lnb2RlY2twcmljZS9zcmMvanMvbWV0aG9kcy91cmlEZWNrRW5jb2RlLmpzIiwiL21udC9jL3dvcmtzcGFjZS93d3cveWdvZGVja3ByaWNlL3NyYy9qcy9tZXRob2RzL2RlY2tVcGRhdGUuanMiLCIvbW50L2Mvd29ya3NwYWNlL3d3dy95Z29kZWNrcHJpY2Uvc3JjL2pzL21ldGhvZHMvZGVja0NhcmRzV2l0aG91dFByaWNlRGF0YS5qcyIsIi9tbnQvYy93b3Jrc3BhY2Uvd3d3L3lnb2RlY2twcmljZS9zcmMvanMvbWV0aG9kcy9wcmljZUNvbnZlcnQuanMiLCIvbW50L2Mvd29ya3NwYWNlL3d3dy95Z29kZWNrcHJpY2Uvc3JjL2pzL21ldGhvZHMvcHJpY2VGb3JDYXJkLmpzIiwiL21udC9jL3dvcmtzcGFjZS93d3cveWdvZGVja3ByaWNlL3NyYy9qcy9tZXRob2RzL3ByaWNlRm9yU2VjdGlvbi5qcyIsIi9tbnQvYy93b3Jrc3BhY2Uvd3d3L3lnb2RlY2twcmljZS9zcmMvanMvbWV0aG9kcy9idWlsZGVyVXBkYXRlTmFtZXMuanMiLCIvbW50L2Mvd29ya3NwYWNlL3d3dy95Z29kZWNrcHJpY2Uvc3JjL2pzL21ldGhvZHMvYnVpbGRlckRlY2tBZGQuanMiLCIvbW50L2Mvd29ya3NwYWNlL3d3dy95Z29kZWNrcHJpY2Uvc3JjL2pzL21ldGhvZHMvYnVpbGRlckRlY2tSZW1vdmUuanMiLCIvbW50L2Mvd29ya3NwYWNlL3d3dy95Z29kZWNrcHJpY2Uvbm9kZV9tb2R1bGVzL2ZpbGUtc2F2ZXIvRmlsZVNhdmVyLmpzIiwiL21udC9jL3dvcmtzcGFjZS93d3cveWdvZGVja3ByaWNlL3NyYy9qcy9tZXRob2RzL2NvbnZlcnREZWNrVG9GaWxlLmpzIiwiL21udC9jL3dvcmtzcGFjZS93d3cveWdvZGVja3ByaWNlL3NyYy9qcy9tZXRob2RzL2ZpbGVEb3dubG9hZERlY2suanMiLCIvbW50L2Mvd29ya3NwYWNlL3d3dy95Z29kZWNrcHJpY2Uvc3JjL2pzL2FwcE1ldGhvZHMuanMiLCIvbW50L2Mvd29ya3NwYWNlL3d3dy95Z29kZWNrcHJpY2Uvc3JjL2pzL2FwcC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFZ1ZS5qcyB2Mi4yLjZcbiAqIChjKSAyMDE0LTIwMTcgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuLyogICovXG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIF90b1N0cmluZyAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbFxuICAgID8gJydcbiAgICA6IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgIDogU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cbn1cblxuLyoqXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAqIGlzIGluIHRoYXQgbWFwLlxuICovXG5mdW5jdGlvbiBtYWtlTWFwIChcbiAgc3RyLFxuICBleHBlY3RzTG93ZXJDYXNlXG4pIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH1cbiAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXG4gKi9cbnZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGl0ZW0pIHtcbiAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZVxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJ1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FjaGVkIChmbikge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICB2YXIgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuICovXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbnZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCBmdW5jdGlvbiAoXywgYykgeyByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnOyB9KVxufSk7XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqL1xudmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG59KTtcblxuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICovXG52YXIgaHlwaGVuYXRlUkUgPSAvKFteLV0pKFtBLVpdKS9nO1xudmFyIGh5cGhlbmF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHJcbiAgICAucmVwbGFjZShoeXBoZW5hdGVSRSwgJyQxLSQyJylcbiAgICAucmVwbGFjZShoeXBoZW5hdGVSRSwgJyQxLSQyJylcbiAgICAudG9Mb3dlckNhc2UoKVxufSk7XG5cbi8qKlxuICogU2ltcGxlIGJpbmQsIGZhc3RlciB0aGFuIG5hdGl2ZVxuICovXG5mdW5jdGlvbiBiaW5kIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGxcbiAgICAgID8gbCA+IDFcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgIDogZm4uY2FsbChjdHgpXG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIGZuIGxlbmd0aFxuICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gIHJldHVybiBib3VuZEZuXG59XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIE9CSkVDVF9TVFJJTkcgPSAnW29iamVjdCBPYmplY3RdJztcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSBPQkpFQ1RfU1RSSU5HXG59XG5cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xudmFyIG5vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG5cbi8qKlxuICogUmV0dXJuIHNhbWUgdmFsdWVcbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdGF0aWMga2V5cyBzdHJpbmcgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gIHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAoa2V5cywgbSkge1xuICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gIH0sIFtdKS5qb2luKCcsJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGEpID09PSBKU09OLnN0cmluZ2lmeShiKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHBvc3NpYmxlIGNpcmN1bGFyIHJlZmVyZW5jZVxuICAgICAgcmV0dXJuIGEgPT09IGJcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4oKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBjb25maWcgPSB7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAqL1xuICBwcm9kdWN0aW9uVGlwOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuICAgKi9cbiAgZGV2dG9vbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICovXG4gIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAvKipcbiAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICovXG4gIGVycm9ySGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAqL1xuICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgKi9cbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgKi9cbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXNzZXQgdHlwZXMgdGhhdCBhIGNvbXBvbmVudCBjYW4gb3duLlxuICAgKi9cbiAgX2Fzc2V0VHlwZXM6IFtcbiAgICAnY29tcG9uZW50JyxcbiAgICAnZGlyZWN0aXZlJyxcbiAgICAnZmlsdGVyJ1xuICBdLFxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGxpZmVjeWNsZSBob29rcy5cbiAgICovXG4gIF9saWZlY3ljbGVIb29rczogW1xuICAgICdiZWZvcmVDcmVhdGUnLFxuICAgICdjcmVhdGVkJyxcbiAgICAnYmVmb3JlTW91bnQnLFxuICAgICdtb3VudGVkJyxcbiAgICAnYmVmb3JlVXBkYXRlJyxcbiAgICAndXBkYXRlZCcsXG4gICAgJ2JlZm9yZURlc3Ryb3knLFxuICAgICdkZXN0cm95ZWQnLFxuICAgICdhY3RpdmF0ZWQnLFxuICAgICdkZWFjdGl2YXRlZCdcbiAgXSxcblxuICAvKipcbiAgICogTWF4IGNpcmN1bGFyIHVwZGF0ZXMgYWxsb3dlZCBpbiBhIHNjaGVkdWxlciBmbHVzaCBjeWNsZS5cbiAgICovXG4gIF9tYXhVcGRhdGVDb3VudDogMTAwXG59O1xuXG4vKiAgKi9cblxudmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gL1teXFx3LiRdLztcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cbi8qIGdsb2JhbHMgTXV0YXRpb25PYnNlcnZlciAqL1xuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbnZhciBpc0lFID0gVUEgJiYgL21zaWV8dHJpZGVudC8udGVzdChVQSk7XG52YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbnZhciBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcbnZhciBpc0FuZHJvaWQgPSBVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwO1xudmFyIGlzSU9TID0gVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKTtcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2lzU2VydmVyXG59O1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gIHJldHVybiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxufVxuXG52YXIgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxuLyoqXG4gKiBEZWZlciBhIHRhc2sgdG8gZXhlY3V0ZSBpdCBhc3luY2hyb25vdXNseS5cbiAqL1xudmFyIG5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICB2YXIgcGVuZGluZyA9IGZhbHNlO1xuICB2YXIgdGltZXJGdW5jO1xuXG4gIGZ1bmN0aW9uIG5leHRUaWNrSGFuZGxlciAoKSB7XG4gICAgcGVuZGluZyA9IGZhbHNlO1xuICAgIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvcGllc1tpXSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHRoZSBuZXh0VGljayBiZWhhdmlvciBsZXZlcmFnZXMgdGhlIG1pY3JvdGFzayBxdWV1ZSwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkXG4gIC8vIHZpYSBlaXRoZXIgbmF0aXZlIFByb21pc2UudGhlbiBvciBNdXRhdGlvbk9ic2VydmVyLlxuICAvLyBNdXRhdGlvbk9ic2VydmVyIGhhcyB3aWRlciBzdXBwb3J0LCBob3dldmVyIGl0IGlzIHNlcmlvdXNseSBidWdnZWQgaW5cbiAgLy8gVUlXZWJWaWV3IGluIGlPUyA+PSA5LjMuMyB3aGVuIHRyaWdnZXJlZCBpbiB0b3VjaCBldmVudCBoYW5kbGVycy4gSXRcbiAgLy8gY29tcGxldGVseSBzdG9wcyB3b3JraW5nIGFmdGVyIHRyaWdnZXJpbmcgYSBmZXcgdGltZXMuLi4gc28sIGlmIG5hdGl2ZVxuICAvLyBQcm9taXNlIGlzIGF2YWlsYWJsZSwgd2Ugd2lsbCB1c2UgaXQ6XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gICAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB2YXIgbG9nRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7IGNvbnNvbGUuZXJyb3IoZXJyKTsgfTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwLnRoZW4obmV4dFRpY2tIYW5kbGVyKS5jYXRjaChsb2dFcnJvcik7XG4gICAgICAvLyBpbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgICBpZiAoaXNJT1MpIHsgc2V0VGltZW91dChub29wKTsgfVxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICYmIChcbiAgICBpc05hdGl2ZShNdXRhdGlvbk9ic2VydmVyKSB8fFxuICAgIC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxuICAgIE11dGF0aW9uT2JzZXJ2ZXIudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXSdcbiAgKSkge1xuICAgIC8vIHVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXG4gICAgLy8gZS5nLiBQaGFudG9tSlMgSUUxMSwgaU9TNywgQW5kcm9pZCA0LjRcbiAgICB2YXIgY291bnRlciA9IDE7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobmV4dFRpY2tIYW5kbGVyKTtcbiAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoY291bnRlcikpO1xuICAgIG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb3VudGVyID0gKGNvdW50ZXIgKyAxKSAlIDI7XG4gICAgICB0ZXh0Tm9kZS5kYXRhID0gU3RyaW5nKGNvdW50ZXIpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gZmFsbGJhY2sgdG8gc2V0VGltZW91dFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChuZXh0VGlja0hhbmRsZXIsIDApO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcXVldWVOZXh0VGljayAoY2IsIGN0eCkge1xuICAgIHZhciBfcmVzb2x2ZTtcbiAgICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY2IpIHsgY2IuY2FsbChjdHgpOyB9XG4gICAgICBpZiAoX3Jlc29sdmUpIHsgX3Jlc29sdmUoY3R4KTsgfVxuICAgIH0pO1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IHRydWU7XG4gICAgICB0aW1lckZ1bmMoKTtcbiAgICB9XG4gICAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB9KVxuICAgIH1cbiAgfVxufSkoKTtcblxudmFyIF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICBfU2V0ID0gU2V0O1xufSBlbHNlIHtcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICBfU2V0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXQgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZVxuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGtleSkge1xuICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2V0O1xuICB9KCkpO1xufVxuXG52YXIgd2FybiA9IG5vb3A7XG52YXIgdGlwID0gbm9vcDtcbnZhciBmb3JtYXRDb21wb25lbnROYW1lO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIFwiIFwiICsgKFxuICAgICAgICB2bSA/IGZvcm1hdExvY2F0aW9uKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiICsgbXNnICsgXCIgXCIgKyAoXG4gICAgICAgIHZtID8gZm9ybWF0TG9jYXRpb24oZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xuICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcbiAgICAgIHJldHVybiAnPFJvb3Q+J1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IHR5cGVvZiB2bSA9PT0gJ3N0cmluZydcbiAgICAgID8gdm1cbiAgICAgIDogdHlwZW9mIHZtID09PSAnZnVuY3Rpb24nICYmIHZtLm9wdGlvbnNcbiAgICAgICAgPyB2bS5vcHRpb25zLm5hbWVcbiAgICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgICA/IHZtLiRvcHRpb25zLm5hbWUgfHwgdm0uJG9wdGlvbnMuX2NvbXBvbmVudFRhZ1xuICAgICAgICAgIDogdm0ubmFtZTtcblxuICAgIHZhciBmaWxlID0gdm0uX2lzVnVlICYmIHZtLiRvcHRpb25zLl9fZmlsZTtcbiAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xuICAgICAgdmFyIG1hdGNoID0gZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC52dWUkLyk7XG4gICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIChuYW1lID8gKFwiPFwiICsgKGNsYXNzaWZ5KG5hbWUpKSArIFwiPlwiKSA6IFwiPEFub255bW91cz5cIikgK1xuICAgICAgKGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gKFwiIGF0IFwiICsgZmlsZSkgOiAnJylcbiAgICApXG4gIH07XG5cbiAgdmFyIGZvcm1hdExvY2F0aW9uID0gZnVuY3Rpb24gKHN0cikge1xuICAgIGlmIChzdHIgPT09IFwiPEFub255bW91cz5cIikge1xuICAgICAgc3RyICs9IFwiIC0gdXNlIHRoZSBcXFwibmFtZVxcXCIgb3B0aW9uIGZvciBiZXR0ZXIgZGVidWdnaW5nIG1lc3NhZ2VzLlwiO1xuICAgIH1cbiAgICByZXR1cm4gKFwiXFxuKGZvdW5kIGluIFwiICsgc3RyICsgXCIpXCIpXG4gIH07XG59XG5cbi8qICAqL1xuXG5cbnZhciB1aWQkMSA9IDA7XG5cbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICovXG52YXIgRGVwID0gZnVuY3Rpb24gRGVwICgpIHtcbiAgdGhpcy5pZCA9IHVpZCQxKys7XG4gIHRoaXMuc3VicyA9IFtdO1xufTtcblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiBhZGRTdWIgKHN1Yikge1xuICB0aGlzLnN1YnMucHVzaChzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiByZW1vdmVTdWIgKHN1Yikge1xuICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICBpZiAoRGVwLnRhcmdldCkge1xuICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICB9XG59O1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG4gIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gIHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBzdWJzW2ldLnVwZGF0ZSgpO1xuICB9XG59O1xuXG4vLyB0aGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyB0aGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgb25lXG4vLyB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZCBhdCBhbnkgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xudmFyIHRhcmdldFN0YWNrID0gW107XG5cbmZ1bmN0aW9uIHB1c2hUYXJnZXQgKF90YXJnZXQpIHtcbiAgaWYgKERlcC50YXJnZXQpIHsgdGFyZ2V0U3RhY2sucHVzaChEZXAudGFyZ2V0KTsgfVxuICBEZXAudGFyZ2V0ID0gX3RhcmdldDtcbn1cblxuZnVuY3Rpb24gcG9wVGFyZ2V0ICgpIHtcbiAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrLnBvcCgpO1xufVxuXG4vKlxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1tcbiAgJ3B1c2gnLFxuICAncG9wJyxcbiAgJ3NoaWZ0JyxcbiAgJ3Vuc2hpZnQnLFxuICAnc3BsaWNlJyxcbiAgJ3NvcnQnLFxuICAncmV2ZXJzZSdcbl1cbi5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICgpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICAvLyBhdm9pZCBsZWFraW5nIGFyZ3VtZW50czpcbiAgICAvLyBodHRwOi8vanNwZXJmLmNvbS9jbG9zdXJlLXdpdGgtYXJndW1lbnRzXG4gICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGkpO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHMkMVtpXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgeyBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpOyB9XG4gICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pO1xufSk7XG5cbi8qICAqL1xuXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIGEgcmVhY3RpdmUgcHJvcGVydHkgaXMgc2V0LCB0aGUgbmV3IHZhbHVlIGlzXG4gKiBhbHNvIGNvbnZlcnRlZCB0byBiZWNvbWUgcmVhY3RpdmUuIEhvd2V2ZXIgd2hlbiBwYXNzaW5nIGRvd24gcHJvcHMsXG4gKiB3ZSBkb24ndCB3YW50IHRvIGZvcmNlIGNvbnZlcnNpb24gYmVjYXVzZSB0aGUgdmFsdWUgbWF5IGJlIGEgbmVzdGVkIHZhbHVlXG4gKiB1bmRlciBhIGZyb3plbiBkYXRhIHN0cnVjdHVyZS4gQ29udmVydGluZyBpdCB3b3VsZCBkZWZlYXQgdGhlIG9wdGltaXphdGlvbi5cbiAqL1xudmFyIG9ic2VydmVyU3RhdGUgPSB7XG4gIHNob3VsZENvbnZlcnQ6IHRydWUsXG4gIGlzU2V0dGluZ1Byb3BzOiBmYWxzZVxufTtcblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGFyZSBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2hlcyB1cGRhdGVzLlxuICovXG52YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiBPYnNlcnZlciAodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgdGhpcy52bUNvdW50ID0gMDtcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBhdWdtZW50ID0gaGFzUHJvdG9cbiAgICAgID8gcHJvdG9BdWdtZW50XG4gICAgICA6IGNvcHlBdWdtZW50O1xuICAgIGF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXYWxrIHRocm91Z2ggZWFjaCBwcm9wZXJ0eSBhbmQgY29udmVydCB0aGVtIGludG9cbiAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gd2FsayAob2JqKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEob2JqLCBrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuICB9XG59O1xuXG4vKipcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICB9XG59O1xuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqL1xuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKFxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlclxuKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcblxuICB2YXIgY2hpbGRPYiA9IG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGN1c3RvbVNldHRlcikge1xuICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgfVxuICAgICAgY2hpbGRPYiA9IG9ic2VydmUobmV3VmFsKTtcbiAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxuICogYWxyZWFkeSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgdHlwZW9mIGtleSA9PT0gJ251bWJlcicpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKGhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCApLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICApO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoIW9iKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGRlZmluZVJlYWN0aXZlJCQxKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgcmV0dXJuIHZhbFxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiB0eXBlb2Yga2V5ID09PSAnbnVtYmVyJykge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0ICkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIHRhcmdldFtrZXldO1xuICBpZiAoIW9iKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xufVxuXG4vKipcbiAqIENvbGxlY3QgZGVwZW5kZW5jaWVzIG9uIGFycmF5IGVsZW1lbnRzIHdoZW4gdGhlIGFycmF5IGlzIHRvdWNoZWQsIHNpbmNlXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cbiAqL1xuZnVuY3Rpb24gZGVwZW5kQXJyYXkgKHZhbHVlKSB7XG4gIGZvciAodmFyIGUgPSAodm9pZCAwKSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlID0gdmFsdWVbaV07XG4gICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKi9cbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuXG4vKipcbiAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICtcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiYgaXNQbGFpbk9iamVjdChmcm9tVmFsKSkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgY2hpbGRWYWwuY2FsbCh0aGlzKSxcbiAgICAgICAgcGFyZW50VmFsLmNhbGwodGhpcylcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSBpZiAocGFyZW50VmFsIHx8IGNoaWxkVmFsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSlcbiAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICByZXR1cm4gY2hpbGRWYWxcbiAgICA/IHBhcmVudFZhbFxuICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsXG59XG5cbmNvbmZpZy5fbGlmZWN5Y2xlSG9va3MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG59KTtcblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBc3NldHMgKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICByZXR1cm4gY2hpbGRWYWxcbiAgICA/IGV4dGVuZChyZXMsIGNoaWxkVmFsKVxuICAgIDogcmVzXG59XG5cbmNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogV2F0Y2hlcnMuXG4gKlxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5IGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXldO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleV0gPSBwYXJlbnRcbiAgICAgID8gcGFyZW50LmNvbmNhdChjaGlsZClcbiAgICAgIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cbnN0cmF0cy5wcm9wcyA9XG5zdHJhdHMubWV0aG9kcyA9XG5zdHJhdHMuY29tcHV0ZWQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBleHRlbmQocmV0LCBjaGlsZFZhbCk7XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneS5cbiAqL1xudmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkXG4gICAgPyBwYXJlbnRWYWxcbiAgICA6IGNoaWxkVmFsXG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIGNvbXBvbmVudCBuYW1lc1xuICovXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudHMgKG9wdGlvbnMpIHtcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgIHZhciBsb3dlciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChpc0J1aWx0SW5UYWcobG93ZXIpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKGxvd2VyKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAgICdpZDogJyArIGtleVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zKSB7XG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcHMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgaSwgdmFsLCBuYW1lO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB7IHR5cGU6IHZhbCB9O1xuICAgIH1cbiAgfVxuICBvcHRpb25zLnByb3BzID0gcmVzO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcbiAgdmFyIGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XG4gIGlmIChkaXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRpcnMpIHtcbiAgICAgIHZhciBkZWYgPSBkaXJzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiwgdXBkYXRlOiBkZWYgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICBwYXJlbnQsXG4gIGNoaWxkLFxuICB2bVxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgfVxuICBub3JtYWxpemVQcm9wcyhjaGlsZCk7XG4gIG5vcm1hbGl6ZURpcmVjdGl2ZXMoY2hpbGQpO1xuICB2YXIgZXh0ZW5kc0Zyb20gPSBjaGlsZC5leHRlbmRzO1xuICBpZiAoZXh0ZW5kc0Zyb20pIHtcbiAgICBwYXJlbnQgPSB0eXBlb2YgZXh0ZW5kc0Zyb20gPT09ICdmdW5jdGlvbidcbiAgICAgID8gbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20ub3B0aW9ucywgdm0pXG4gICAgICA6IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGV4dGVuZHNGcm9tLCB2bSk7XG4gIH1cbiAgaWYgKGNoaWxkLm1peGlucykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIG1peGluID0gY2hpbGQubWl4aW5zW2ldO1xuICAgICAgaWYgKG1peGluLnByb3RvdHlwZSBpbnN0YW5jZW9mIFZ1ZSQzKSB7XG4gICAgICAgIG1peGluID0gbWl4aW4ub3B0aW9ucztcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIG1peGluLCB2bSk7XG4gICAgfVxuICB9XG4gIHZhciBvcHRpb25zID0ge307XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQgKFxuICBvcHRpb25zLFxuICB0eXBlLFxuICBpZCxcbiAgd2Fybk1pc3Npbmdcbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcbiAgaWYgKGhhc093bihhc3NldHMsIGlkKSkgeyByZXR1cm4gYXNzZXRzW2lkXSB9XG4gIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkgeyByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXSB9XG4gIHZhciBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cbiAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG4gIHZhciByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gIGtleSxcbiAgcHJvcE9wdGlvbnMsXG4gIHByb3BzRGF0YSxcbiAgdm1cbikge1xuICB2YXIgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XG4gIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gIC8vIGhhbmRsZSBib29sZWFuIHByb3BzXG4gIGlmIChpc1R5cGUoQm9vbGVhbiwgcHJvcC50eXBlKSkge1xuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoIWlzVHlwZShTdHJpbmcsIHByb3AudHlwZSkgJiYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpKSB7XG4gICAgICB2YWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgIHZhciBwcmV2U2hvdWxkQ29udmVydCA9IG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydDtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHByZXZTaG91bGRDb252ZXJ0O1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0UHJvcChwcm9wLCBrZXksIHZhbHVlLCB2bSwgYWJzZW50KTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwcm9wLlxuICovXG5mdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlICh2bSwgcHJvcCwga2V5KSB7XG4gIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcbiAgaWYgKCFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuICB2YXIgZGVmID0gcHJvcC5kZWZhdWx0O1xuICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzT2JqZWN0KGRlZikpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgKyBrZXkgKyAnXCI6ICcgK1xuICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xuICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHRoZSByYXcgcHJvcCB2YWx1ZSB3YXMgYWxzbyB1bmRlZmluZWQgZnJvbSBwcmV2aW91cyByZW5kZXIsXG4gIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxuICBpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhW2tleV0gPT09IHVuZGVmaW5lZCAmJlxuICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdm0uX3Byb3BzW2tleV1cbiAgfVxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGdldFR5cGUocHJvcC50eXBlKSAhPT0gJ0Z1bmN0aW9uJ1xuICAgID8gZGVmLmNhbGwodm0pXG4gICAgOiBkZWZcbn1cblxuLyoqXG4gKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFByb3AgKFxuICBwcm9wLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgdm0sXG4gIGFic2VudFxuKSB7XG4gIGlmIChwcm9wLnJlcXVpcmVkICYmIGFic2VudCkge1xuICAgIHdhcm4oXG4gICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xuICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICBpZiAodHlwZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG4gIGlmICghdmFsaWQpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nICtcbiAgICAgICcgRXhwZWN0ZWQgJyArIGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykgK1xuICAgICAgJywgZ290ICcgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSArICcuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gIGlmICh2YWxpZGF0b3IpIHtcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoZSB0eXBlIG9mIGEgdmFsdWVcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcbiAgdmFyIHZhbGlkO1xuICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ1N0cmluZycpIHtcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gKGV4cGVjdGVkVHlwZSA9ICdzdHJpbmcnKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdOdW1iZXInKSB7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IChleHBlY3RlZFR5cGUgPSAnbnVtYmVyJyk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQm9vbGVhbicpIHtcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gKGV4cGVjdGVkVHlwZSA9ICdib29sZWFuJyk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnRnVuY3Rpb24nKSB7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IChleHBlY3RlZFR5cGUgPSAnZnVuY3Rpb24nKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcbiAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gIH1cbn1cblxuLyoqXG4gKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcbiAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdXG59XG5cbmZ1bmN0aW9uIGlzVHlwZSAodHlwZSwgZm4pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGZuKSkge1xuICAgIHJldHVybiBnZXRUeXBlKGZuKSA9PT0gZ2V0VHlwZSh0eXBlKVxuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChnZXRUeXBlKGZuW2ldKSA9PT0gZ2V0VHlwZSh0eXBlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pO1xuICB9IGVsc2Uge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkVycm9yIGluIFwiICsgaW5mbyArIFwiOlwiKSwgdm0pO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChpbkJyb3dzZXIgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcbiAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICApO1xuXG4gIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHdhcm4oXG4gICAgICBcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBcIiArXG4gICAgICBcInJlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRvIGRlY2xhcmUgcmVhY3RpdmUgZGF0YSBcIiArXG4gICAgICBcInByb3BlcnRpZXMgaW4gdGhlIGRhdGEgb3B0aW9uLlwiLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICB2YXIgaGFzUHJveHkgPVxuICAgIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBQcm94eS50b1N0cmluZygpLm1hdGNoKC9uYXRpdmUgY29kZS8pO1xuXG4gIGlmIChoYXNQcm94eSkge1xuICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEnKTtcbiAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgd2FybigoXCJBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC5cIiArIGtleSkpO1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGhhc0hhbmRsZXIgPSB7XG4gICAgaGFzOiBmdW5jdGlvbiBoYXMgKHRhcmdldCwga2V5KSB7XG4gICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgIHZhciBpc0FsbG93ZWQgPSBhbGxvd2VkR2xvYmFscyhrZXkpIHx8IGtleS5jaGFyQXQoMCkgPT09ICdfJztcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkXG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRIYW5kbGVyID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICh0YXJnZXQsIGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFtrZXldXG4gICAgfVxuICB9O1xuXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgPyBnZXRIYW5kbGVyXG4gICAgICAgIDogaGFzSGFuZGxlcjtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBtYXJrO1xudmFyIG1lYXN1cmU7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBwZXJmICYmXG4gICAgcGVyZi5tYXJrICYmXG4gICAgcGVyZi5tZWFzdXJlICYmXG4gICAgcGVyZi5jbGVhck1hcmtzICYmXG4gICAgcGVyZi5jbGVhck1lYXN1cmVzXG4gICkge1xuICAgIG1hcmsgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBwZXJmLm1hcmsodGFnKTsgfTtcbiAgICBtZWFzdXJlID0gZnVuY3Rpb24gKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpIHtcbiAgICAgIHBlcmYubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKTtcbiAgICB9O1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZSAoXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIHRleHQsXG4gIGVsbSxcbiAgY29udGV4dCxcbiAgY29tcG9uZW50T3B0aW9uc1xuKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMuZWxtID0gZWxtO1xuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmZ1bmN0aW9uYWxDb250ZXh0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICB0aGlzLmlzT25jZSA9IGZhbHNlO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY2hpbGQ6IHt9IH07XG5cbi8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5wcm90b3R5cGVBY2Nlc3NvcnMuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xuICBub2RlLnRleHQgPSAnJztcbiAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuICByZXR1cm4gbm9kZVxufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcbn1cblxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3Ncbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cbmZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlKSB7XG4gIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgdm5vZGUudGFnLFxuICAgIHZub2RlLmRhdGEsXG4gICAgdm5vZGUuY2hpbGRyZW4sXG4gICAgdm5vZGUudGV4dCxcbiAgICB2bm9kZS5lbG0sXG4gICAgdm5vZGUuY29udGV4dCxcbiAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zXG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgcmV0dXJuIGNsb25lZFxufVxuXG5mdW5jdGlvbiBjbG9uZVZOb2RlcyAodm5vZGVzKSB7XG4gIHZhciBsZW4gPSB2bm9kZXMubGVuZ3RoO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KGxlbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXNbaV0gPSBjbG9uZVZOb2RlKHZub2Rlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBvbmNlOiBvbmNlJCQxLFxuICAgIGNhcHR1cmU6IGNhcHR1cmVcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZuSW52b2tlciAoZm5zKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIHZhciBmbnMgPSBpbnZva2VyLmZucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbnNbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzJDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xuICAgICAgcmV0dXJuIGZucy5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG4gIGludm9rZXIuZm5zID0gZm5zO1xuICByZXR1cm4gaW52b2tlclxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMgKFxuICBvbixcbiAgb2xkT24sXG4gIGFkZCxcbiAgcmVtb3ZlJCQxLFxuICB2bVxuKSB7XG4gIHZhciBuYW1lLCBjdXIsIG9sZCwgZXZlbnQ7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgaWYgKCFjdXIpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIW9sZCkge1xuICAgICAgaWYgKCFjdXIuZm5zKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1cik7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5vbmNlLCBldmVudC5jYXB0dXJlKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmICghb25bbmFtZV0pIHtcbiAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICByZW1vdmUkJDEoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0sIGV2ZW50LmNhcHR1cmUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2sgKGRlZiwgaG9va0tleSwgaG9vaykge1xuICB2YXIgaW52b2tlcjtcbiAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xuICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICByZW1vdmUoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcbiAgfVxuXG4gIGlmICghb2xkSG9vaykge1xuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChvbGRIb29rLmZucyAmJiBvbGRIb29rLm1lcmdlZCkge1xuICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgIH1cbiAgfVxuXG4gIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcbn1cblxuLyogICovXG5cbi8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxuLy8gc3RhdGljYWxseSBhbmFseXppbmcgdGhlIHRlbXBsYXRlIGF0IGNvbXBpbGUgdGltZS5cbi8vXG4vLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxuLy8gZ2VuZXJhdGVkIHJlbmRlciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJldHVybiBBcnJheTxWTm9kZT4uIFRoZXJlIGFyZVxuLy8gdHdvIGNhc2VzIHdoZXJlIGV4dHJhIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkOlxuXG4vLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4vLyBtYXkgcmV0dXJuIGFuIEFycmF5IGluc3RlYWQgb2YgYSBzaW5nbGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBqdXN0IGEgc2ltcGxlXG4vLyBub3JtYWxpemF0aW9uIGlzIG5lZWRlZCAtIGlmIGFueSBjaGlsZCBpcyBhbiBBcnJheSwgd2UgZmxhdHRlbiB0aGUgd2hvbGVcbi8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxuLy8gYmVjYXVzZSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYWxyZWFkeSBub3JtYWxpemUgdGhlaXIgb3duIGNoaWxkcmVuLlxuZnVuY3Rpb24gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbltpXSkpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjaGlsZHJlbilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuXG59XG5cbi8vIDIuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbnN0cnVjdHMgdGhhdCBhbHdheXMgZ2VuZXJhdGVkIG5lc3RlZCBBcnJheXMsXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcbi8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbi8vIGlzIG5lZWRlZCB0byBjYXRlciB0byBhbGwgcG9zc2libGUgdHlwZXMgb2YgY2hpbGRyZW4gdmFsdWVzLlxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcbiAgICA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxuICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbilcbiAgICAgIDogdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpLCBjLCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGMgPT0gbnVsbCB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICBsYXN0ID0gcmVzW3Jlcy5sZW5ndGggLSAxXTtcbiAgICAvLyAgbmVzdGVkXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcbiAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpKTtcbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAobGFzdCAmJiBsYXN0LnRleHQpIHtcbiAgICAgICAgbGFzdC50ZXh0ICs9IFN0cmluZyhjKTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGMudGV4dCAmJiBsYXN0ICYmIGxhc3QudGV4dCkge1xuICAgICAgICByZXNbcmVzLmxlbmd0aCAtIDFdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoYy50YWcgJiYgYy5rZXkgPT0gbnVsbCAmJiBuZXN0ZWRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICByZXR1cm4gY2hpbGRyZW4gJiYgY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjICYmIGMuY29tcG9uZW50T3B0aW9uczsgfSlbMF1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG4gIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICB2YXIgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0O1xuXG5mdW5jdGlvbiBhZGQgKGV2ZW50LCBmbiwgb25jZSQkMSkge1xuICBpZiAob25jZSQkMSkge1xuICAgIHRhcmdldC4kb25jZShldmVudCwgZm4pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmUkMSAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyAoXG4gIHZtLFxuICBsaXN0ZW5lcnMsXG4gIG9sZExpc3RlbmVyc1xuKSB7XG4gIHRhcmdldCA9IHZtO1xuICB1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCwgcmVtb3ZlJDEsIHZtKTtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSQxID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSQxIDwgbDsgaSQxKyspIHtcbiAgICAgICAgdGhpcyQxLiRvZmYoZXZlbnRbaSQxXSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgdmFyIGNiO1xuICAgIHZhciBpID0gY2JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjYiA9IGNic1tpXTtcbiAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuICAgICAgICB0aXAoXG4gICAgICAgICAgXCJFdmVudCBcXFwiXCIgKyBsb3dlckNhc2VFdmVudCArIFwiXFxcIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiIGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xuICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcbiAgICAgICAgICBcIllvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIChoeXBoZW5hdGUoZXZlbnQpKSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoY2JzKSB7XG4gICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNic1tpXS5hcHBseSh2bSwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIHJhdyBjaGlsZHJlbiBWTm9kZXMgaW50byBhIHNsb3Qgb2JqZWN0LlxuICovXG5mdW5jdGlvbiByZXNvbHZlU2xvdHMgKFxuICBjaGlsZHJlbixcbiAgY29udGV4dFxuKSB7XG4gIHZhciBzbG90cyA9IHt9O1xuICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIHNsb3RzXG4gIH1cbiAgdmFyIGRlZmF1bHRTbG90ID0gW107XG4gIHZhciBuYW1lLCBjaGlsZDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxuICAgIC8vIHNhbWUgY29udGV4dC5cbiAgICBpZiAoKGNoaWxkLmNvbnRleHQgPT09IGNvbnRleHQgfHwgY2hpbGQuZnVuY3Rpb25hbENvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICAgIGNoaWxkLmRhdGEgJiYgKG5hbWUgPSBjaGlsZC5kYXRhLnNsb3QpKSB7XG4gICAgICB2YXIgc2xvdCA9IChzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSkpO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVmYXVsdFNsb3QucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSB3aGl0ZXNwYWNlXG4gIGlmICghZGVmYXVsdFNsb3QuZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuICAgIHNsb3RzLmRlZmF1bHQgPSBkZWZhdWx0U2xvdDtcbiAgfVxuICByZXR1cm4gc2xvdHNcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCB8fCBub2RlLnRleHQgPT09ICcgJ1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuICBmbnNcbikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzW2Zuc1tpXVswXV0gPSBmbnNbaV1bMV07XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcblxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcblxuICAvLyBsb2NhdGUgZmlyc3Qgbm9uLWFic3RyYWN0IHBhcmVudFxuICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICB3aGlsZSAocGFyZW50LiRvcHRpb25zLmFic3RyYWN0ICYmIHBhcmVudC4kcGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcbiAgfVxuXG4gIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XG4gIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XG5cbiAgdm0uJGNoaWxkcmVuID0gW107XG4gIHZtLiRyZWZzID0ge307XG5cbiAgdm0uX3dhdGNoZXIgPSBudWxsO1xuICB2bS5faW5hY3RpdmUgPSBudWxsO1xuICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgdm0uX2lzTW91bnRlZCA9IGZhbHNlO1xuICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgfVxuICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XG4gICAgdmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICB2YXIgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XG4gICAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcbiAgICB2bS5fdm5vZGUgPSB2bm9kZTtcbiAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcbiAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cbiAgICBpZiAoIXByZXZWbm9kZSkge1xuICAgICAgLy8gaW5pdGlhbCByZW5kZXJcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhcbiAgICAgICAgdm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcmVmRWxtXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGVzXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmIChwcmV2RWwpIHtcbiAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcbiAgICB9XG4gICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxuICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XG4gICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcbiAgICB9XG4gICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxuICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgcmVtb3ZlKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcbiAgICB9XG4gICAgLy8gdGVhcmRvd24gd2F0Y2hlcnNcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2bS5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcbiAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cbiAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XG4gICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xuICAgIH1cbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxuICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuICAgIC8vIGZpcmUgZGVzdHJveWVkIGhvb2tcbiAgICBjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdm0uJG9mZigpO1xuICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byBET00gbm9kZXMgKHByZXZlbnRzIGxlYWspXG4gICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSA9IHZtLiRvcHRpb25zLl9yZWZFbG0gPSBudWxsO1xuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gIHZtLFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgdm0uJGVsID0gZWw7XG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XG5cbiAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgIHZhciBpZCA9IHZtLl91aWQ7XG4gICAgICB2YXIgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgaWQ7XG4gICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChuYW1lICsgXCIgcmVuZGVyXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgobmFtZSArIFwiIHBhdGNoXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZtLl91cGRhdGUodm0uX3JlbmRlcigpLCBoeWRyYXRpbmcpO1xuICAgIH07XG4gIH1cblxuICB2bS5fd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3ApO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICB2bSxcbiAgcHJvcHNEYXRhLFxuICBsaXN0ZW5lcnMsXG4gIHBhcmVudFZub2RlLFxuICByZW5kZXJDaGlsZHJlblxuKSB7XG4gIC8vIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBoYXMgc2xvdCBjaGlsZHJlblxuICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlblxuICB2YXIgaGFzQ2hpbGRyZW4gPSAhIShcbiAgICByZW5kZXJDaGlsZHJlbiB8fCAgICAgICAgICAgICAgIC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8ICAvLyBoYXMgb2xkIHN0YXRpYyBzbG90c1xuICAgIHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMgfHwgLy8gaGFzIG5ldyBzY29wZWQgc2xvdHNcbiAgICB2bS4kc2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0IC8vIGhhcyBvbGQgc2NvcGVkIHNsb3RzXG4gICk7XG5cbiAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXG4gIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcbiAgICB2bS5fdm5vZGUucGFyZW50ID0gcGFyZW50Vm5vZGU7XG4gIH1cbiAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG5cbiAgLy8gdXBkYXRlIHByb3BzXG4gIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBmYWxzZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgb2JzZXJ2ZXJTdGF0ZS5pc1NldHRpbmdQcm9wcyA9IHRydWU7XG4gICAgfVxuICAgIHZhciBwcm9wcyA9IHZtLl9wcm9wcztcbiAgICB2YXIgcHJvcEtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgfHwgW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IHByb3BLZXlzW2ldO1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHZtLiRvcHRpb25zLnByb3BzLCBwcm9wc0RhdGEsIHZtKTtcbiAgICB9XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgb2JzZXJ2ZXJTdGF0ZS5pc1NldHRpbmdQcm9wcyA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xuICB9XG4gIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICAgIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG4gIH1cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcbiAgICB2bS4kZm9yY2VVcGRhdGUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlICh2bSkge1xuICB3aGlsZSAodm0gJiYgKHZtID0gdm0uJHBhcmVudCkpIHtcbiAgICBpZiAodm0uX2luYWN0aXZlKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0gZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT0gbnVsbCkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgdmFyIGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBoYW5kbGVyc1tpXS5jYWxsKHZtKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChob29rICsgXCIgaG9va1wiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG59XG5cbi8qICAqL1xuXG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGhhcyA9IHt9O1xudmFyIGNpcmN1bGFyID0ge307XG52YXIgd2FpdGluZyA9IGZhbHNlO1xudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIFJlc2V0IHRoZSBzY2hlZHVsZXIncyBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gcmVzZXRTY2hlZHVsZXJTdGF0ZSAoKSB7XG4gIHF1ZXVlLmxlbmd0aCA9IDA7XG4gIGhhcyA9IHt9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNpcmN1bGFyID0ge307XG4gIH1cbiAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8qKlxuICogRmx1c2ggYm90aCBxdWV1ZXMgYW5kIHJ1biB0aGUgd2F0Y2hlcnMuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVyUXVldWUgKCkge1xuICBmbHVzaGluZyA9IHRydWU7XG4gIHZhciB3YXRjaGVyLCBpZCwgdm07XG5cbiAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxuICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxuICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cbiAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBjb25maWcuX21heFVwZGF0ZUNvdW50KSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHJlc2V0IHNjaGVkdWxlciBiZWZvcmUgdXBkYXRlZCBob29rIGNhbGxlZFxuICB2YXIgb2xkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuICByZXNldFNjaGVkdWxlclN0YXRlKCk7XG5cbiAgLy8gY2FsbCB1cGRhdGVkIGhvb2tzXG4gIGluZGV4ID0gb2xkUXVldWUubGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHdhdGNoZXIgPSBvbGRRdWV1ZVtpbmRleF07XG4gICAgdm0gPSB3YXRjaGVyLnZtO1xuICAgIGlmICh2bS5fd2F0Y2hlciA9PT0gd2F0Y2hlciAmJiB2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcbiAgICB9XG4gIH1cblxuICAvLyBkZXZ0b29sIGhvb2tcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcbiAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xuICB9XG59XG5cbi8qKlxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlV2F0Y2hlciAod2F0Y2hlcikge1xuICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XG4gICAgaGFzW2lkXSA9IHRydWU7XG4gICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cbiAgICAgIHZhciBpID0gcXVldWUubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlIChpID49IDAgJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnNwbGljZShNYXRoLm1heChpLCBpbmRleCkgKyAxLCAwLCB3YXRjaGVyKTtcbiAgICB9XG4gICAgLy8gcXVldWUgdGhlIGZsdXNoXG4gICAgaWYgKCF3YWl0aW5nKSB7XG4gICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHVpZCQyID0gMDtcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqL1xudmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGNiLFxuICBvcHRpb25zXG4pIHtcbiAgdGhpcy52bSA9IHZtO1xuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgLy8gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZGVlcCA9IHRoaXMudXNlciA9IHRoaXMubGF6eSA9IHRoaXMuc3luYyA9IGZhbHNlO1xuICB9XG4gIHRoaXMuY2IgPSBjYjtcbiAgdGhpcy5pZCA9ICsrdWlkJDI7IC8vIHVpZCBmb3IgYmF0Y2hpbmdcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICB0aGlzLmRlcHMgPSBbXTtcbiAgdGhpcy5uZXdEZXBzID0gW107XG4gIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLmV4cHJlc3Npb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgPyBleHBPckZuLnRvU3RyaW5nKClcbiAgICA6ICcnO1xuICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXJcbiAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gZnVuY3Rpb24gKCkge307XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xuICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiB0aGlzLmdldCgpO1xufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gIHB1c2hUYXJnZXQodGhpcyk7XG4gIHZhciB2YWx1ZTtcbiAgdmFyIHZtID0gdGhpcy52bTtcbiAgaWYgKHRoaXMudXNlcikge1xuICAgIHRyeSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gIH1cbiAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICBpZiAodGhpcy5kZWVwKSB7XG4gICAgdHJhdmVyc2UodmFsdWUpO1xuICB9XG4gIHBvcFRhcmdldCgpO1xuICB0aGlzLmNsZWFudXBEZXBzKCk7XG4gIHJldHVybiB2YWx1ZVxufTtcblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xuICB2YXIgaWQgPSBkZXAuaWQ7XG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBkZXAgPSB0aGlzJDEuZGVwc1tpXTtcbiAgICBpZiAoIXRoaXMkMS5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gIH1cbiAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xuICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgdG1wID0gdGhpcy5kZXBzO1xuICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRoaXMubGF6eSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgIHRoaXMucnVuKCk7XG4gIH0gZWxzZSB7XG4gICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlciBqb2IgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgICAvLyBoYXZlIG11dGF0ZWQuXG4gICAgICBpc09iamVjdCh2YWx1ZSkgfHxcbiAgICAgIHRoaXMuZGVlcFxuICAgICkge1xuICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHRoaXMudm0sIChcImNhbGxiYWNrIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XG4gIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICB0aGlzLmRpcnR5ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMkMS5kZXBzW2ldLmRlcGVuZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZW1vdmUodGhpcy52bS5fd2F0Y2hlcnMsIHRoaXMpO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcyQxLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcbiAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gKiBpcyBjb2xsZWN0ZWQgYXMgYSBcImRlZXBcIiBkZXBlbmRlbmN5LlxuICovXG52YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xuICBzZWVuT2JqZWN0cy5jbGVhcigpO1xuICBfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XG59XG5cbmZ1bmN0aW9uIF90cmF2ZXJzZSAodmFsLCBzZWVuKSB7XG4gIHZhciBpLCBrZXlzO1xuICB2YXIgaXNBID0gQXJyYXkuaXNBcnJheSh2YWwpO1xuICBpZiAoKCFpc0EgJiYgIWlzT2JqZWN0KHZhbCkpIHx8ICFPYmplY3QuaXNFeHRlbnNpYmxlKHZhbCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsLl9fb2JfXykge1xuICAgIHZhciBkZXBJZCA9IHZhbC5fX29iX18uZGVwLmlkO1xuICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzZWVuLmFkZChkZXBJZCk7XG4gIH1cbiAgaWYgKGlzQSkge1xuICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7IH1cbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2tleXNbaV1dLCBzZWVuKTsgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogbm9vcCxcbiAgc2V0OiBub29wXG59O1xuXG5mdW5jdGlvbiBwcm94eSAodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICB9O1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgdm0uX3dhdGNoZXJzID0gW107XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnM7XG4gIGlmIChvcHRzLnByb3BzKSB7IGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7IH1cbiAgaWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpOyB9XG4gIGlmIChvcHRzLndhdGNoKSB7IGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7IH1cbn1cblxudmFyIGlzUmVzZXJ2ZWRQcm9wID0geyBrZXk6IDEsIHJlZjogMSwgc2xvdDogMSB9O1xuXG5mdW5jdGlvbiBpbml0UHJvcHMgKHZtLCBwcm9wc09wdGlvbnMpIHtcbiAgdmFyIHByb3BzRGF0YSA9IHZtLiRvcHRpb25zLnByb3BzRGF0YSB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxuICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xuICB2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG4gIC8vIHJvb3QgaW5zdGFuY2UgcHJvcHMgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBpc1Jvb3Q7XG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gICAgdmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaXNSZXNlcnZlZFByb3Bba2V5XSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIlxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodm0uJHBhcmVudCAmJiAhb2JzZXJ2ZXJTdGF0ZS5pc1NldHRpbmdQcm9wcykge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGEgcHJvcCBkaXJlY3RseSBzaW5jZSB0aGUgdmFsdWUgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwYXJlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiSW5zdGVhZCwgdXNlIGEgZGF0YSBvciBjb21wdXRlZCBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcHJvcCdzIFwiICtcbiAgICAgICAgICAgIFwidmFsdWUuIFByb3AgYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIHN0YXRpYyBwcm9wcyBhcmUgYWxyZWFkeSBwcm94aWVkIG9uIHRoZSBjb21wb25lbnQncyBwcm90b3R5cGVcbiAgICAvLyBkdXJpbmcgVnVlLmV4dGVuZCgpLiBXZSBvbmx5IG5lZWQgdG8gcHJveHkgcHJvcHMgZGVmaW5lZCBhdFxuICAgIC8vIGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBwcm94eSh2bSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIga2V5IGluIHByb3BzT3B0aW9ucykgbG9vcCgga2V5ICk7XG4gIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGluaXREYXRhICh2bSkge1xuICB2YXIgZGF0YSA9IHZtLiRvcHRpb25zLmRhdGE7XG4gIGRhdGEgPSB2bS5fZGF0YSA9IHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nXG4gICAgPyBnZXREYXRhKGRhdGEsIHZtKVxuICAgIDogZGF0YSB8fCB7fTtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgZGF0YSA9IHt9O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdDpcXG4nICtcbiAgICAgICdodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXlzW2ldKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIlRoZSBkYXRhIHByb3BlcnR5IFxcXCJcIiArIChrZXlzW2ldKSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gXCIgK1xuICAgICAgICBcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cIixcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZChrZXlzW2ldKSkge1xuICAgICAgcHJveHkodm0sIFwiX2RhdGFcIiwga2V5c1tpXSk7XG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRhdGEuY2FsbCh2bSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImRhdGEoKVwiKTtcbiAgICByZXR1cm4ge31cbiAgfVxufVxuXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xuICB2YXIgd2F0Y2hlcnMgPSB2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuICAgIHZhciBnZXR0ZXIgPSB0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJyA/IHVzZXJEZWYgOiB1c2VyRGVmLmdldDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTm8gZ2V0dGVyIGZ1bmN0aW9uIGhhcyBiZWVuIGRlZmluZWQgZm9yIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIi5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgICAgZ2V0dGVyID0gbm9vcDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cbiAgICB3YXRjaGVyc1trZXldID0gbmV3IFdhdGNoZXIodm0sIGdldHRlciwgbm9vcCwgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyk7XG5cbiAgICAvLyBjb21wb25lbnQtZGVmaW5lZCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBhbHJlYWR5IGRlZmluZWQgb24gdGhlXG4gICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcbiAgICAvLyBhdCBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgZGVmaW5lQ29tcHV0ZWQodm0sIGtleSwgdXNlckRlZik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkICh0YXJnZXQsIGtleSwgdXNlckRlZikge1xuICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KTtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcbiAgfSBlbHNlIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcbiAgICAgID8gdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgIDogdXNlckRlZi5nZXRcbiAgICAgIDogbm9vcDtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXRcbiAgICAgID8gdXNlckRlZi5zZXRcbiAgICAgIDogbm9vcDtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgIHZtW2tleV0gPSBtZXRob2RzW2tleV0gPT0gbnVsbCA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAobWV0aG9kc1trZXldID09IG51bGwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIm1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFuIHVuZGVmaW5lZCB2YWx1ZSBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIFwiICtcbiAgICAgICAgICBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKHZtLCBrZXksIGhhbmRsZXIpIHtcbiAgdmFyIG9wdGlvbnM7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHZtLiR3YXRjaChrZXksIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XG4gIC8vIHdoZW4gdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBzbyB3ZSBoYXZlIHRvIHByb2NlZHVyYWxseSBidWlsZCB1cFxuICAvLyB0aGUgb2JqZWN0IGhlcmUuXG4gIHZhciBkYXRhRGVmID0ge307XG4gIGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YSB9O1xuICB2YXIgcHJvcHNEZWYgPSB7fTtcbiAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxuICAgIGV4cE9yRm4sXG4gICAgY2IsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbi8vIGhvb2tzIHRvIGJlIGludm9rZWQgb24gY29tcG9uZW50IFZOb2RlcyBkdXJpbmcgcGF0Y2hcbnZhciBjb21wb25lbnRWTm9kZUhvb2tzID0ge1xuICBpbml0OiBmdW5jdGlvbiBpbml0IChcbiAgICB2bm9kZSxcbiAgICBoeWRyYXRpbmcsXG4gICAgcGFyZW50RWxtLFxuICAgIHJlZkVsbVxuICApIHtcbiAgICBpZiAoIXZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgYWN0aXZlSW5zdGFuY2UsXG4gICAgICAgIHBhcmVudEVsbSxcbiAgICAgICAgcmVmRWxtXG4gICAgICApO1xuICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcbiAgICB9IGVsc2UgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAvLyBrZXB0LWFsaXZlIGNvbXBvbmVudHMsIHRyZWF0IGFzIGEgcGF0Y2hcbiAgICAgIHZhciBtb3VudGVkTm9kZSA9IHZub2RlOyAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG4gICAgfVxuICB9LFxuXG4gIHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXG4gICAgICBjaGlsZCxcbiAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXG4gICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICk7XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG4gICAgaWYgKCF2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkKSB7XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxIb29rKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm5vZGUuY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICB9XG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICBpZiAoIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZub2RlLmNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoY29tcG9uZW50Vk5vZGVIb29rcyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAoXG4gIEN0b3IsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICBpZiAoIUN0b3IpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG4gIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gIH1cblxuICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIiArIChTdHJpbmcoQ3RvcikpKSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIGlmICghQ3Rvci5jaWQpIHtcbiAgICBpZiAoQ3Rvci5yZXNvbHZlZCkge1xuICAgICAgQ3RvciA9IEN0b3IucmVzb2x2ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIEN0b3IgPSByZXNvbHZlQXN5bmNDb21wb25lbnQoQ3RvciwgYmFzZUN0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gaXQncyBvayB0byBxdWV1ZSB0aGlzIG9uIGV2ZXJ5IHJlbmRlciBiZWNhdXNlXG4gICAgICAgIC8vICRmb3JjZVVwZGF0ZSBpcyBidWZmZXJlZCBieSB0aGUgc2NoZWR1bGVyLlxuICAgICAgICBjb250ZXh0LiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIUN0b3IpIHtcbiAgICAgICAgLy8gcmV0dXJuIG5vdGhpbmcgaWYgdGhpcyBpcyBpbmRlZWQgYW4gYXN5bmMgY29tcG9uZW50XG4gICAgICAgIC8vIHdhaXQgZm9yIHRoZSBjYWxsYmFjayB0byB0cmlnZ2VyIHBhcmVudCB1cGRhdGUuXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcbiAgLy8gY29tcG9uZW50IGNvbnN0cnVjdG9yIGNyZWF0aW9uXG4gIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcik7XG5cbiAgZGF0YSA9IGRhdGEgfHwge307XG5cbiAgLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGRhdGEgaW50byBwcm9wcyAmIGV2ZW50c1xuICBpZiAoZGF0YS5tb2RlbCkge1xuICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gIH1cblxuICAvLyBleHRyYWN0IHByb3BzXG4gIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHMoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoQ3Rvci5vcHRpb25zLmZ1bmN0aW9uYWwpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxuICB9XG5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChDdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXG4gICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVyc1xuICAgIGRhdGEgPSB7fTtcbiAgfVxuXG4gIC8vIG1lcmdlIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgbWVyZ2VIb29rcyhkYXRhKTtcblxuICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciB2bm9kZVxuICB2YXIgbmFtZSA9IEN0b3Iub3B0aW9ucy5uYW1lIHx8IHRhZztcbiAgdmFyIHZub2RlID0gbmV3IFZOb2RlKFxuICAgIChcInZ1ZS1jb21wb25lbnQtXCIgKyAoQ3Rvci5jaWQpICsgKG5hbWUgPyAoXCItXCIgKyBuYW1lKSA6ICcnKSksXG4gICAgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCxcbiAgICB7IEN0b3I6IEN0b3IsIHByb3BzRGF0YTogcHJvcHNEYXRhLCBsaXN0ZW5lcnM6IGxpc3RlbmVycywgdGFnOiB0YWcsIGNoaWxkcmVuOiBjaGlsZHJlbiB9XG4gICk7XG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChwcm9wT3B0aW9ucykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEpO1xuICAgIH1cbiAgfVxuICAvLyBlbnN1cmUgdGhlIGNyZWF0ZUVsZW1lbnQgZnVuY3Rpb24gaW4gZnVuY3Rpb25hbCBjb21wb25lbnRzXG4gIC8vIGdldHMgYSB1bmlxdWUgY29udGV4dCAtIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBjb3JyZWN0IG5hbWVkIHNsb3QgY2hlY2tcbiAgdmFyIF9jb250ZXh0ID0gT2JqZWN0LmNyZWF0ZShjb250ZXh0KTtcbiAgdmFyIGggPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChfY29udGV4dCwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG4gIHZhciB2bm9kZSA9IEN0b3Iub3B0aW9ucy5yZW5kZXIuY2FsbChudWxsLCBoLCB7XG4gICAgcHJvcHM6IHByb3BzLFxuICAgIGRhdGE6IGRhdGEsXG4gICAgcGFyZW50OiBjb250ZXh0LFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBzbG90czogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBjb250ZXh0KTsgfVxuICB9KTtcbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICB2bm9kZS5mdW5jdGlvbmFsQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgaWYgKGRhdGEuc2xvdCkge1xuICAgICAgKHZub2RlLmRhdGEgfHwgKHZub2RlLmRhdGEgPSB7fSkpLnNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgfVxuICB9XG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcbiAgdm5vZGUsIC8vIHdlIGtub3cgaXQncyBNb3VudGVkQ29tcG9uZW50Vk5vZGUgYnV0IGZsb3cgZG9lc24ndFxuICBwYXJlbnQsIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuICBwYXJlbnRFbG0sXG4gIHJlZkVsbVxuKSB7XG4gIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgcHJvcHNEYXRhOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhLFxuICAgIF9jb21wb25lbnRUYWc6IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWcsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBfcGFyZW50TGlzdGVuZXJzOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzLFxuICAgIF9yZW5kZXJDaGlsZHJlbjogdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuLFxuICAgIF9wYXJlbnRFbG06IHBhcmVudEVsbSB8fCBudWxsLFxuICAgIF9yZWZFbG06IHJlZkVsbSB8fCBudWxsXG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICB9XG4gIHJldHVybiBuZXcgdm5vZGVDb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgZmFjdG9yeSxcbiAgYmFzZUN0b3IsXG4gIGNiXG4pIHtcbiAgaWYgKGZhY3RvcnkucmVxdWVzdGVkKSB7XG4gICAgLy8gcG9vbCBjYWxsYmFja3NcbiAgICBmYWN0b3J5LnBlbmRpbmdDYWxsYmFja3MucHVzaChjYik7XG4gIH0gZWxzZSB7XG4gICAgZmFjdG9yeS5yZXF1ZXN0ZWQgPSB0cnVlO1xuICAgIHZhciBjYnMgPSBmYWN0b3J5LnBlbmRpbmdDYWxsYmFja3MgPSBbY2JdO1xuICAgIHZhciBzeW5jID0gdHJ1ZTtcblxuICAgIHZhciByZXNvbHZlID0gZnVuY3Rpb24gKHJlcykge1xuICAgICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgICAgcmVzID0gYmFzZUN0b3IuZXh0ZW5kKHJlcyk7XG4gICAgICB9XG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IHJlcztcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGNic1tpXShyZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiBcIiArIChTdHJpbmcoZmFjdG9yeSkpICtcbiAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG4gICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgLy8gaGFuZGxlIHByb21pc2VcbiAgICBpZiAocmVzICYmIHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJiAhZmFjdG9yeS5yZXNvbHZlZCkge1xuICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzIChkYXRhLCBDdG9yLCB0YWcpIHtcbiAgLy8gd2UgYXJlIG9ubHkgZXh0cmFjdGluZyByYXcgdmFsdWVzIGhlcmUuXG4gIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAvLyBjb21wb25lbnQgaXRzZWxmLlxuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcE9wdGlvbnMpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XG4gIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gIHZhciBkb21Qcm9wcyA9IGRhdGEuZG9tUHJvcHM7XG4gIGlmIChhdHRycyB8fCBwcm9wcyB8fCBkb21Qcm9wcykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgYXR0cnMgJiYgYXR0cnMuaGFzT3duUHJvcGVydHkoa2V5SW5Mb3dlckNhc2UpXG4gICAgICAgICkge1xuICAgICAgICAgIHRpcChcbiAgICAgICAgICAgIFwiUHJvcCBcXFwiXCIgKyBrZXlJbkxvd2VyQ2FzZSArIFwiXFxcIiBpcyBwYXNzZWQgdG8gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHRhZyB8fCBDdG9yKSkgKyBcIiwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNcIiArXG4gICAgICAgICAgICBcIiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FtZWxDYXNlZCBcIiArXG4gICAgICAgICAgICBcInByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gXCIgK1xuICAgICAgICAgICAgXCJ0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIGFsdEtleSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGtleSArIFwiXFxcIi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoZWNrUHJvcChyZXMsIHByb3BzLCBrZXksIGFsdEtleSwgdHJ1ZSkgfHxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSkgfHxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGRvbVByb3BzLCBrZXksIGFsdEtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wIChcbiAgcmVzLFxuICBoYXNoLFxuICBrZXksXG4gIGFsdEtleSxcbiAgcHJlc2VydmVcbikge1xuICBpZiAoaGFzaCkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9va3MgKGRhdGEpIHtcbiAgaWYgKCFkYXRhLmhvb2spIHtcbiAgICBkYXRhLmhvb2sgPSB7fTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgdmFyIGZyb21QYXJlbnQgPSBkYXRhLmhvb2tba2V5XTtcbiAgICB2YXIgb3VycyA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgICBkYXRhLmhvb2tba2V5XSA9IGZyb21QYXJlbnQgPyBtZXJnZUhvb2skMShvdXJzLCBmcm9tUGFyZW50KSA6IG91cnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rJDEgKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgIG9uZShhLCBiLCBjLCBkKTtcbiAgICB0d28oYSwgYiwgYywgZCk7XG4gIH1cbn1cblxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICB2YXIgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcbiAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0JzsoZGF0YS5wcm9wcyB8fCAoZGF0YS5wcm9wcyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICBpZiAob25bZXZlbnRdKSB7XG4gICAgb25bZXZlbnRdID0gW2RhdGEubW9kZWwuY2FsbGJhY2tdLmNvbmNhdChvbltldmVudF0pO1xuICB9IGVsc2Uge1xuICAgIG9uW2V2ZW50XSA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBTSU1QTEVfTk9STUFMSVpFID0gMTtcbnZhciBBTFdBWVNfTk9STUFMSVpFID0gMjtcblxuLy8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2Vcbi8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlLFxuICBhbHdheXNOb3JtYWxpemVcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XG4gICAgY2hpbGRyZW4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGFsd2F5c05vcm1hbGl6ZSkgeyBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7IH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGRhdGEgJiYgZGF0YS5fX29iX18pIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgaWYgKCF0YWcpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGNvbXBvbmVudCA6aXMgc2V0IHRvIGZhbHN5IHZhbHVlXG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG4gIC8vIHN1cHBvcnQgc2luZ2xlIGZ1bmN0aW9uIGNoaWxkcmVuIGFzIGRlZmF1bHQgc2NvcGVkIHNsb3RcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmXG4gICAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cbiAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfVxuICB2YXIgdm5vZGUsIG5zO1xuICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgQ3RvcjtcbiAgICBucyA9IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xuICAgICAgLy8gY29tcG9uZW50XG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAodm5vZGUpIHtcbiAgICBpZiAobnMpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucykge1xuICB2bm9kZS5ucyA9IG5zO1xuICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyB1c2UgZGVmYXVsdCBuYW1lc3BhY2UgaW5zaWRlIGZvcmVpZ25PYmplY3RcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm5vZGUuY2hpbGRyZW4pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2hpbGQudGFnICYmICFjaGlsZC5ucykge1xuICAgICAgICBhcHBseU5TKGNoaWxkLCBucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgdi1mb3IgbGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckxpc3QgKFxuICB2YWwsXG4gIHJlbmRlclxuKSB7XG4gIHZhciByZXQsIGksIGwsIGtleXMsIGtleTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSB8fCB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHZhbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIoaSArIDEsIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2tleV0sIGtleSwgaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2xvdCAoXG4gIG5hbWUsXG4gIGZhbGxiYWNrLFxuICBwcm9wcyxcbiAgYmluZE9iamVjdFxuKSB7XG4gIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgIGV4dGVuZChwcm9wcywgYmluZE9iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiBzY29wZWRTbG90Rm4ocHJvcHMpIHx8IGZhbGxiYWNrXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsb3ROb2RlcyA9IHRoaXMuJHNsb3RzW25hbWVdO1xuICAgIC8vIHdhcm4gZHVwbGljYXRlIHNsb3QgdXNhZ2VcbiAgICBpZiAoc2xvdE5vZGVzICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHNsb3ROb2Rlcy5fcmVuZGVyZWQgJiYgd2FybihcbiAgICAgICAgXCJEdXBsaWNhdGUgcHJlc2VuY2Ugb2Ygc2xvdCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGZvdW5kIGluIHRoZSBzYW1lIHJlbmRlciB0cmVlIFwiICtcbiAgICAgICAgXCItIHRoaXMgd2lsbCBsaWtlbHkgY2F1c2UgcmVuZGVyIGVycm9ycy5cIixcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICAgIHNsb3ROb2Rlcy5fcmVuZGVyZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc2xvdE5vZGVzIHx8IGZhbGxiYWNrXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyBmaWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVGaWx0ZXIgKGlkKSB7XG4gIHJldHVybiByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBpZCwgdHJ1ZSkgfHwgaWRlbnRpdHlcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIGNoZWNraW5nIGtleUNvZGVzIGZyb20gY29uZmlnLlxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5BbGlhc1xuKSB7XG4gIHZhciBrZXlDb2RlcyA9IGNvbmZpZy5rZXlDb2Rlc1trZXldIHx8IGJ1aWx0SW5BbGlhcztcbiAgaWYgKEFycmF5LmlzQXJyYXkoa2V5Q29kZXMpKSB7XG4gICAgcmV0dXJuIGtleUNvZGVzLmluZGV4T2YoZXZlbnRLZXlDb2RlKSA9PT0gLTFcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ga2V5Q29kZXMgIT09IGV2ZW50S2V5Q29kZVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBtZXJnaW5nIHYtYmluZD1cIm9iamVjdFwiIGludG8gYSBWTm9kZSdzIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGJpbmRPYmplY3RQcm9wcyAoXG4gIGRhdGEsXG4gIHRhZyxcbiAgdmFsdWUsXG4gIGFzUHJvcFxuKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNoO1xuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycgfHwga2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGtleSBpbiBoYXNoKSkge1xuICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXG4gIGluZGV4LFxuICBpc0luRm9yXG4pIHtcbiAgdmFyIHRyZWUgPSB0aGlzLl9zdGF0aWNUcmVlc1tpbmRleF07XG4gIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxuICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZSBieSBkb2luZyBhIHNoYWxsb3cgY2xvbmUuXG4gIGlmICh0cmVlICYmICFpc0luRm9yKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodHJlZSlcbiAgICAgID8gY2xvbmVWTm9kZXModHJlZSlcbiAgICAgIDogY2xvbmVWTm9kZSh0cmVlKVxuICB9XG4gIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgdHJlZSA9IHRoaXMuX3N0YXRpY1RyZWVzW2luZGV4XSA9XG4gICAgdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwodGhpcy5fcmVuZGVyUHJveHkpO1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fc3RhdGljX19cIiArIGluZGV4KSwgZmFsc2UpO1xuICByZXR1cm4gdHJlZVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciB2LW9uY2UuXG4gKiBFZmZlY3RpdmVseSBpdCBtZWFucyBtYXJraW5nIHRoZSBub2RlIGFzIHN0YXRpYyB3aXRoIGEgdW5pcXVlIGtleS5cbiAqL1xuZnVuY3Rpb24gbWFya09uY2UgKFxuICB0cmVlLFxuICBpbmRleCxcbiAga2V5XG4pIHtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX29uY2VfX1wiICsgaW5kZXggKyAoa2V5ID8gKFwiX1wiICsga2V5KSA6IFwiXCIpKSwgdHJ1ZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMgKFxuICB0cmVlLFxuICBrZXksXG4gIGlzT25jZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRyZWUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJlZVtpXSAmJiB0eXBlb2YgdHJlZVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwgKGtleSArIFwiX1wiICsgaSksIGlzT25jZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljTm9kZSAobm9kZSwga2V5LCBpc09uY2UpIHtcbiAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XG4gIG5vZGUua2V5ID0ga2V5O1xuICBub2RlLmlzT25jZSA9IGlzT25jZTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLiR2bm9kZSA9IG51bGw7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7XG4gIHZhciBwYXJlbnRWbm9kZSA9IHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHModm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyTWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBuZXh0VGljayhmbiwgdGhpcylcbiAgfTtcblxuICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgcmVmID0gdm0uJG9wdGlvbnM7XG4gICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgdmFyIHN0YXRpY1JlbmRlckZucyA9IHJlZi5zdGF0aWNSZW5kZXJGbnM7XG4gICAgdmFyIF9wYXJlbnRWbm9kZSA9IHJlZi5fcGFyZW50Vm5vZGU7XG5cbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgLy8gY2xvbmUgc2xvdCBub2RlcyBvbiByZS1yZW5kZXJzXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdm0uJHNsb3RzKSB7XG4gICAgICAgIHZtLiRzbG90c1trZXldID0gY2xvbmVWTm9kZXModm0uJHNsb3RzW2tleV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZtLiRzY29wZWRTbG90cyA9IChfcGFyZW50Vm5vZGUgJiYgX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMpIHx8IGVtcHR5T2JqZWN0O1xuXG4gICAgaWYgKHN0YXRpY1JlbmRlckZucyAmJiAhdm0uX3N0YXRpY1RyZWVzKSB7XG4gICAgICB2bS5fc3RhdGljVHJlZXMgPSBbXTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcmVudCB2bm9kZS4gdGhpcyBhbGxvd3MgcmVuZGVyIGZ1bmN0aW9ucyB0byBoYXZlIGFjY2Vzc1xuICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgIHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcbiAgICAvLyByZW5kZXIgc2VsZlxuICAgIHZhciB2bm9kZTtcbiAgICB0cnkge1xuICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXIgZnVuY3Rpb25cIik7XG4gICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcbiAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvclxuICAgICAgICAgID8gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50LCBlKVxuICAgICAgICAgIDogdm0uX3Zub2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcbiAgICBpZiAoISh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnTXVsdGlwbGUgcm9vdCBub2RlcyByZXR1cm5lZCBmcm9tIHJlbmRlciBmdW5jdGlvbi4gUmVuZGVyIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICdzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHJvb3Qgbm9kZS4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2bm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcmVudFxuICAgIHZub2RlLnBhcmVudCA9IF9wYXJlbnRWbm9kZTtcbiAgICByZXR1cm4gdm5vZGVcbiAgfTtcblxuICAvLyBpbnRlcm5hbCByZW5kZXIgaGVscGVycy5cbiAgLy8gdGhlc2UgYXJlIGV4cG9zZWQgb24gdGhlIGluc3RhbmNlIHByb3RvdHlwZSB0byByZWR1Y2UgZ2VuZXJhdGVkIHJlbmRlclxuICAvLyBjb2RlIHNpemUuXG4gIFZ1ZS5wcm90b3R5cGUuX28gPSBtYXJrT25jZTtcbiAgVnVlLnByb3RvdHlwZS5fbiA9IHRvTnVtYmVyO1xuICBWdWUucHJvdG90eXBlLl9zID0gX3RvU3RyaW5nO1xuICBWdWUucHJvdG90eXBlLl9sID0gcmVuZGVyTGlzdDtcbiAgVnVlLnByb3RvdHlwZS5fdCA9IHJlbmRlclNsb3Q7XG4gIFZ1ZS5wcm90b3R5cGUuX3EgPSBsb29zZUVxdWFsO1xuICBWdWUucHJvdG90eXBlLl9pID0gbG9vc2VJbmRleE9mO1xuICBWdWUucHJvdG90eXBlLl9tID0gcmVuZGVyU3RhdGljO1xuICBWdWUucHJvdG90eXBlLl9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgVnVlLnByb3RvdHlwZS5fayA9IGNoZWNrS2V5Q29kZXM7XG4gIFZ1ZS5wcm90b3R5cGUuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XG4gIFZ1ZS5wcm90b3R5cGUuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIFZ1ZS5wcm90b3R5cGUuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICBWdWUucHJvdG90eXBlLl91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gIHZhciBwcm92aWRlID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcbiAgaWYgKHByb3ZpZGUpIHtcbiAgICB2bS5fcHJvdmlkZWQgPSB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBwcm92aWRlLmNhbGwodm0pXG4gICAgICA6IHByb3ZpZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdEluamVjdGlvbnMgKHZtKSB7XG4gIHZhciBpbmplY3QgPSB2bS4kb3B0aW9ucy5pbmplY3Q7XG4gIGlmIChpbmplY3QpIHtcbiAgICAvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxuICAgIC8vIGlzQXJyYXkgaGVyZVxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShpbmplY3QpO1xuICAgIHZhciBrZXlzID0gaXNBcnJheVxuICAgICAgPyBpbmplY3RcbiAgICAgIDogaGFzU3ltYm9sXG4gICAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcbiAgICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGkgKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciBwcm92aWRlS2V5ID0gaXNBcnJheSA/IGtleSA6IGluamVjdFtrZXldO1xuICAgICAgdmFyIHNvdXJjZSA9IHZtO1xuICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBwcm92aWRlS2V5IGluIHNvdXJjZS5fcHJvdmlkZWQpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwcm92aWRlZCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykgbG9vcCggaSApO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgdWlkID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhIHVpZFxuICAgIHZtLl91aWQgPSB1aWQrKztcblxuICAgIHZhciBzdGFydFRhZywgZW5kVGFnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICBzdGFydFRhZyA9IFwidnVlLXBlcmYtaW5pdDpcIiArICh2bS5fdWlkKTtcbiAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgfVxuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxuICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICB2bS5fc2VsZiA9IHZtO1xuICAgIGluaXRMaWZlY3ljbGUodm0pO1xuICAgIGluaXRFdmVudHModm0pO1xuICAgIGluaXRSZW5kZXIodm0pO1xuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG4gICAgaW5pdEluamVjdGlvbnModm0pOyAvLyByZXNvbHZlIGluamVjdGlvbnMgYmVmb3JlIGRhdGEvcHJvcHNcbiAgICBpbml0U3RhdGUodm0pO1xuICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICBjYWxsSG9vayh2bSwgJ2NyZWF0ZWQnKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKCh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9XG5cbiAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcbiAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICBvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBvcHRzLnByb3BzRGF0YSA9IG9wdGlvbnMucHJvcHNEYXRhO1xuICBvcHRzLl9wYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW47XG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcbiAgb3B0cy5fcGFyZW50RWxtID0gb3B0aW9ucy5fcGFyZW50RWxtO1xuICBvcHRzLl9yZWZFbG0gPSBvcHRpb25zLl9yZWZFbG07XG4gIGlmIChvcHRpb25zLnJlbmRlcikge1xuICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgb3B0cy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZucztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBpZiAoQ3Rvci5zdXBlcikge1xuICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxuICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICB2YXIgbW9kaWZpZWRPcHRpb25zID0gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKTtcbiAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG4gICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XG4gIHZhciBtb2RpZmllZDtcbiAgdmFyIGxhdGVzdCA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgZm9yICh2YXIga2V5IGluIGxhdGVzdCkge1xuICAgIGlmIChsYXRlc3Rba2V5XSAhPT0gc2VhbGVkW2tleV0pIHtcbiAgICAgIGlmICghbW9kaWZpZWQpIHsgbW9kaWZpZWQgPSB7fTsgfVxuICAgICAgbW9kaWZpZWRba2V5XSA9IGRlZHVwZShsYXRlc3Rba2V5XSwgc2VhbGVkW2tleV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kaWZpZWRcbn1cblxuZnVuY3Rpb24gZGVkdXBlIChsYXRlc3QsIHNlYWxlZCkge1xuICAvLyBjb21wYXJlIGxhdGVzdCBhbmQgc2VhbGVkIHRvIGVuc3VyZSBsaWZlY3ljbGUgaG9va3Mgd29uJ3QgYmUgZHVwbGljYXRlZFxuICAvLyBiZXR3ZWVuIG1lcmdlc1xuICBpZiAoQXJyYXkuaXNBcnJheShsYXRlc3QpKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHNlYWxlZCA9IEFycmF5LmlzQXJyYXkoc2VhbGVkKSA/IHNlYWxlZCA6IFtzZWFsZWRdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0ZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc2VhbGVkLmluZGV4T2YobGF0ZXN0W2ldKSA8IDApIHtcbiAgICAgICAgcmVzLnB1c2gobGF0ZXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsYXRlc3RcbiAgfVxufVxuXG5mdW5jdGlvbiBWdWUkMyAob3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICEodGhpcyBpbnN0YW5jZW9mIFZ1ZSQzKSkge1xuICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcbiAgfVxuICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuXG5pbml0TWl4aW4oVnVlJDMpO1xuc3RhdGVNaXhpbihWdWUkMyk7XG5ldmVudHNNaXhpbihWdWUkMyk7XG5saWZlY3ljbGVNaXhpbihWdWUkMyk7XG5yZW5kZXJNaXhpbihWdWUkMyk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocGx1Z2luLmluc3RhbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBwbHVnaW4uaW5zdGFsbGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdE1peGluJDEgKFZ1ZSkge1xuICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcbiAgLyoqXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgKi9cbiAgVnVlLmNpZCA9IDA7XG4gIHZhciBjaWQgPSAxO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgKi9cbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICB2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcbiAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xuICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xuICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIS9eW2EtekEtWl1bXFx3LV0qJC8udGVzdChuYW1lKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXG4gICAgICAgICAgJ2NhbiBvbmx5IGNvbnRhaW4gYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgYW5kIHRoZSBoeXBoZW4sICcgK1xuICAgICAgICAgICdhbmQgbXVzdCBzdGFydCB3aXRoIGEgbGV0dGVyLidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgU3ViID0gZnVuY3Rpb24gVnVlQ29tcG9uZW50IChvcHRpb25zKSB7XG4gICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgIH07XG4gICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgICBleHRlbmRPcHRpb25zXG4gICAgKTtcbiAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXG4gICAgLy8gdGhlIFZ1ZSBpbnN0YW5jZXMgYXQgZXh0ZW5zaW9uIHRpbWUsIG9uIHRoZSBleHRlbmRlZCBwcm90b3R5cGUuIFRoaXNcbiAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG4gICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XG4gICAgICBpbml0UHJvcHMkMShTdWIpO1xuICAgIH1cbiAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgIGluaXRDb21wdXRlZCQxKFN1Yik7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuXG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICBjb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cblxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XG5cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgIHJldHVybiBTdWJcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzJDEgKENvbXApIHtcbiAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSAoQ29tcCkge1xuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIGRlZmluZUNvbXB1dGVkKENvbXAucHJvdG90eXBlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgKi9cbiAgY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG4gICAgICBpZCxcbiAgICAgIGRlZmluaXRpb25cbiAgICApIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGNvbmZpZy5pc1Jlc2VydmVkVGFnKGlkKSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAgICAgICAgICdpZDogJyArIGlkXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcbiAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RpcmVjdGl2ZScgJiYgdHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cblxuLyogICovXG5cbnZhciBwYXR0ZXJuVHlwZXMgPSBbU3RyaW5nLCBSZWdFeHBdO1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGUgKGNhY2hlLCBmaWx0ZXIpIHtcbiAgZm9yICh2YXIga2V5IGluIGNhY2hlKSB7XG4gICAgdmFyIGNhY2hlZE5vZGUgPSBjYWNoZVtrZXldO1xuICAgIGlmIChjYWNoZWROb2RlKSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY2FjaGVkTm9kZS5jb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGlmIChuYW1lICYmICFmaWx0ZXIobmFtZSkpIHtcbiAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlZE5vZGUpO1xuICAgICAgICBjYWNoZVtrZXldID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5ICh2bm9kZSkge1xuICBpZiAodm5vZGUpIHtcbiAgICBpZiAoIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pbmFjdGl2ZSkge1xuICAgICAgY2FsbEhvb2sodm5vZGUuY29tcG9uZW50SW5zdGFuY2UsICdkZWFjdGl2YXRlZCcpO1xuICAgIH1cbiAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICB9XG59XG5cbnZhciBLZWVwQWxpdmUgPSB7XG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgZXhjbHVkZTogcGF0dGVyblR5cGVzXG4gIH0sXG5cbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0sXG5cbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMkMS5jYWNoZSkge1xuICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMkMS5jYWNoZVtrZXldKTtcbiAgICB9XG4gIH0sXG5cbiAgd2F0Y2g6IHtcbiAgICBpbmNsdWRlOiBmdW5jdGlvbiBpbmNsdWRlICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcy5jYWNoZSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSxcbiAgICBleGNsdWRlOiBmdW5jdGlvbiBleGNsdWRlICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcy5jYWNoZSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH1cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCh0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGlmIChuYW1lICYmIChcbiAgICAgICAgKHRoaXMuaW5jbHVkZSAmJiAhbWF0Y2hlcyh0aGlzLmluY2x1ZGUsIG5hbWUpKSB8fFxuICAgICAgICAodGhpcy5leGNsdWRlICYmIG1hdGNoZXModGhpcy5leGNsdWRlLCBuYW1lKSlcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5ID09IG51bGxcbiAgICAgICAgLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxuICAgICAgICA/IGNvbXBvbmVudE9wdGlvbnMuQ3Rvci5jaWQgKyAoY29tcG9uZW50T3B0aW9ucy50YWcgPyAoXCI6OlwiICsgKGNvbXBvbmVudE9wdGlvbnMudGFnKSkgOiAnJylcbiAgICAgICAgOiB2bm9kZS5rZXk7XG4gICAgICBpZiAodGhpcy5jYWNoZVtrZXldKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gdGhpcy5jYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYWNoZVtrZXldID0gdm5vZGU7XG4gICAgICB9XG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZVxuICB9XG59O1xuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gIC8vIGNvbmZpZ1xuICB2YXIgY29uZmlnRGVmID0ge307XG4gIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXG4gIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gIFZ1ZS51dGlsID0ge1xuICAgIHdhcm46IHdhcm4sXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlJCQxXG4gIH07XG5cbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSk7XG5cbiAgLy8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxuICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cbiAgVnVlLm9wdGlvbnMuX2Jhc2UgPSBWdWU7XG5cbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcblxuICBpbml0VXNlKFZ1ZSk7XG4gIGluaXRNaXhpbiQxKFZ1ZSk7XG4gIGluaXRFeHRlbmQoVnVlKTtcbiAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG59XG5cbmluaXRHbG9iYWxBUEkoVnVlJDMpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlJDMucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuICBnZXQ6IGlzU2VydmVyUmVuZGVyaW5nXG59KTtcblxuVnVlJDMudmVyc2lvbiA9ICcyLjIuNic7XG5cbi8qICAqL1xuXG4vLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG52YXIgYWNjZXB0VmFsdWUgPSBtYWtlTWFwKCdpbnB1dCx0ZXh0YXJlYSxvcHRpb24sc2VsZWN0Jyk7XG52YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XG4gIHJldHVybiAoXG4gICAgKGF0dHIgPT09ICd2YWx1ZScgJiYgYWNjZXB0VmFsdWUodGFnKSkgJiYgdHlwZSAhPT0gJ2J1dHRvbicgfHxcbiAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxuICAgIChhdHRyID09PSAnY2hlY2tlZCcgJiYgdGFnID09PSAnaW5wdXQnKSB8fFxuICAgIChhdHRyID09PSAnbXV0ZWQnICYmIHRhZyA9PT0gJ3ZpZGVvJylcbiAgKVxufTtcblxudmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcblxudmFyIGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKFxuICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcbiAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcbiAgJ2VuYWJsZWQsZm9ybW5vdmFsaWRhdGUsaGlkZGVuLGluZGV0ZXJtaW5hdGUsaW5lcnQsaXNtYXAsaXRlbXNjb3BlLGxvb3AsbXVsdGlwbGUsJyArXG4gICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xuICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRyYW5zbGF0ZSwnICtcbiAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG4pO1xuXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxudmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG52YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG59O1xuXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2Vcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgaWYgKGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoY2hpbGROb2RlLmRhdGEsIGRhdGEpO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdlbkNsYXNzRnJvbURhdGEoZGF0YSlcbn1cblxuZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgIGNsYXNzOiBjaGlsZC5jbGFzc1xuICAgICAgPyBbY2hpbGQuY2xhc3MsIHBhcmVudC5jbGFzc11cbiAgICAgIDogcGFyZW50LmNsYXNzXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuQ2xhc3NGcm9tRGF0YSAoZGF0YSkge1xuICB2YXIgZHluYW1pY0NsYXNzID0gZGF0YS5jbGFzcztcbiAgdmFyIHN0YXRpY0NsYXNzID0gZGF0YS5zdGF0aWNDbGFzcztcbiAgaWYgKHN0YXRpY0NsYXNzIHx8IGR5bmFtaWNDbGFzcykge1xuICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuICByZXR1cm4gYSA/IGIgPyAoYSArICcgJyArIGIpIDogYSA6IChiIHx8ICcnKVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIHN0cmluZ2lmaWVkO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVbaV0pIHtcbiAgICAgICAgaWYgKChzdHJpbmdpZmllZCA9IHN0cmluZ2lmeUNsYXNzKHZhbHVlW2ldKSkpIHtcbiAgICAgICAgICByZXMgKz0gc3RyaW5naWZpZWQgKyAnICc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWVba2V5XSkgeyByZXMgKz0ga2V5ICsgJyAnOyB9XG4gICAgfVxuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5hbWVzcGFjZU1hcCA9IHtcbiAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICBtYXRoOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcbn07XG5cbnZhciBpc0hUTUxUYWcgPSBtYWtlTWFwKFxuICAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoMSxoMixoMyxoNCxoNSxoNixoZ3JvdXAsbmF2LHNlY3Rpb24sJyArXG4gICdkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUnXG4pO1xuXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG52YXIgaXNTVkcgPSBtYWtlTWFwKFxuICAnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xuICAnZm9yZWlnbk9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXG4gICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JyxcbiAgdHJ1ZVxuKTtcblxudmFyIGlzUHJlVGFnID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGFnID09PSAncHJlJzsgfTtcblxudmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG52YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICApKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqL1xuZnVuY3Rpb24gcXVlcnkgKGVsKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XG4gIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm4gZWxtXG4gIH1cbiAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICB9XG4gIHJldHVybiBlbG1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG59XG5cbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG59XG5cbmZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZVxufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlIChub2RlLCBrZXksIHZhbCkge1xuICBub2RlLnNldEF0dHJpYnV0ZShrZXksIHZhbCk7XG59XG5cblxudmFyIG5vZGVPcHMgPSBPYmplY3QuZnJlZXplKHtcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuXHRjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcblx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuXHRjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuXHRpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcblx0cmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuXHRhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG5cdHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG5cdG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcblx0dGFnTmFtZTogdGFnTmFtZSxcblx0c2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuXHRzZXRBdHRyaWJ1dGU6IHNldEF0dHJpYnV0ZVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuICBpZiAoIWtleSkgeyByZXR1cm4gfVxuXG4gIHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XG4gIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gIHZhciByZWZzID0gdm0uJHJlZnM7XG4gIGlmIChpc1JlbW92YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICByZW1vdmUocmVmc1trZXldLCByZWYpO1xuICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcbiAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkgJiYgcmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWZzW2tleV0gPSByZWY7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxuICpcblxuLypcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcbiAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxuICovXG5cbnZhciBlbXB0eU5vZGUgPSBuZXcgVk5vZGUoJycsIHt9LCBbXSk7XG5cbnZhciBob29rcyA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xuXG5mdW5jdGlvbiBpc1VuZGVmICh2KSB7XG4gIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZiAodikge1xuICByZXR1cm4gdiAhPT0gdW5kZWZpbmVkICYmIHYgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNUcnVlICh2KSB7XG4gIHJldHVybiB2ID09PSB0cnVlXG59XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJlxuICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgIGlzRGVmKGEuZGF0YSkgPT09IGlzRGVmKGIuZGF0YSkgJiZcbiAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gIClcbn1cblxuLy8gU29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBkeW5hbWljYWxseSBjaGFuZ2luZyB0eXBlIGZvciA8aW5wdXQ+XG4vLyBzbyB0aGV5IG5lZWQgdG8gYmUgdHJlYXRlZCBhcyBkaWZmZXJlbnQgbm9kZXNcbmZ1bmN0aW9uIHNhbWVJbnB1dFR5cGUgKGEsIGIpIHtcbiAgaWYgKGEudGFnICE9PSAnaW5wdXQnKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGk7XG4gIHZhciB0eXBlQSA9IGlzRGVmKGkgPSBhLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHZhciB0eXBlQiA9IGlzRGVmKGkgPSBiLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHJldHVybiB0eXBlQSA9PT0gdHlwZUJcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlJCQxICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZSQkMS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSQkMS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZSQkMVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaW5QcmUgPSAwO1xuICBmdW5jdGlvbiBjcmVhdGVFbG0gKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBuZXN0ZWQpIHtcbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBpblByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhaW5QcmUgJiZcbiAgICAgICAgICAhdm5vZGUubnMgJiZcbiAgICAgICAgICAhKGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuaW5kZXhPZih0YWcpID4gLTEpICYmXG4gICAgICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodGFnKVxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgaW5QcmUtLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLywgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgfVxuICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICB9XG4gICAgdm5vZGUuZWxtID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGVsO1xuICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbXB0eSBjb21wb25lbnQgcm9vdC5cbiAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGluc2VydCBob29rXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhY3RpdmF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaTtcbiAgICAvLyBoYWNrIGZvciAjNDMzOTogYSByZWFjdGl2YXRlZCBjb21wb25lbnQgd2l0aCBpbm5lciB0cmFuc2l0aW9uXG4gICAgLy8gZG9lcyBub3QgdHJpZ2dlciBiZWNhdXNlIHRoZSBpbm5lciBub2RlJ3MgY3JlYXRlZCBob29rcyBhcmUgbm90IGNhbGxlZFxuICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxuICAgIC8vIHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGJldHRlciB3YXkgdG8gZG8gaXQuXG4gICAgdmFyIGlubmVyTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGlubmVyTm9kZSA9IGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGlubmVyTm9kZS5kYXRhKSAmJiBpc0RlZihpID0gaS50cmFuc2l0aW9uKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY2JzLmFjdGl2YXRlW2ldKGVtcHR5Tm9kZSwgaW5uZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB1bmxpa2UgYSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudCxcbiAgICAvLyBhIHJlYWN0aXZhdGVkIGtlZXAtYWxpdmUgY29tcG9uZW50IGRvZXNuJ3QgaW5zZXJ0IGl0c2VsZlxuICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydCAocGFyZW50LCBlbG0sIHJlZikge1xuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBpZiAoaXNEZWYocmVmKSkge1xuICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKHZub2RlLnRleHQpKSB7XG4gICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHZub2RlLmVsbSwgbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGFuY2VzdG9yLmNvbnRleHQpICYmIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuICAgICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICAgIH1cbiAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgIH1cbiAgICAvLyBmb3Igc2xvdCBjb250ZW50IHRoZXkgc2hvdWxkIGFsc28gZ2V0IHRoZSBzY29wZUlkIGZyb20gdGhlIGhvc3QgaW5zdGFuY2UuXG4gICAgaWYgKGlzRGVmKGkgPSBhY3RpdmVJbnN0YW5jZSkgJiZcbiAgICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgICBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZub2RlcyAocGFyZW50RWxtLCByZWZFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIHZhciBpLCBqO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgdmFyIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcbiAgICAgIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGNoKTtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgIHJlbW92ZU5vZGUoY2guZWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuICAgIGlmIChpc0RlZihybSkgfHwgaXNEZWYodm5vZGUuZGF0YSkpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIGVsbVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgLy8gcmVtb3ZlT25seSBpcyBhIHNwZWNpYWwgZmxhZyB1c2VkIG9ubHkgYnkgPHRyYW5zaXRpb24tZ3JvdXA+XG4gICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgdmFyIGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KSA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XSA6IG51bGw7XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbG1Ub01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWVsbVRvTW92ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ0l0IHNlZW1zIHRoZXJlIGFyZSBkdXBsaWNhdGUga2V5cyB0aGF0IGlzIGNhdXNpbmcgYW4gdXBkYXRlIGVycm9yLiAnICtcbiAgICAgICAgICAgICAgJ01ha2Ugc3VyZSBlYWNoIHYtZm9yIGl0ZW0gaGFzIGEgdW5pcXVlIGtleS4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2FtZVZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG5ld1N0YXJ0Vm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cbiAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBpO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wb3N0cGF0Y2gpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhaWxlZCA9IGZhbHNlO1xuICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLHN0eWxlLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgdm5vZGUuZWxtID0gZWxtO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgLy8gbG9uZ2VyIHRoYW4gdGhlIHZpcnR1YWwgY2hpbGRyZW4gbGlzdC5cbiAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFiYWlsZWQpIHtcbiAgICAgICAgICAgICAgYmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWlzbWF0Y2hpbmcgY2hpbGROb2RlcyB2cy4gVk5vZGVzOiAnLCBlbG0uY2hpbGROb2RlcywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICBpZiAoIWlzUmVuZGVyZWRNb2R1bGUoa2V5KSkge1xuICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIGVsbS5kYXRhID0gdm5vZGUudGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUudGFnKSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fFxuICAgICAgICB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT0gKG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09ICh2bm9kZS5pc0NvbW1lbnQgPyA4IDogMylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5LCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSkgeyBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7IH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG4gICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cbiAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKCdzZXJ2ZXItcmVuZGVyZWQnKSkge1xuICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKCdzZXJ2ZXItcmVuZGVyZWQnKTtcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1RydWUoaHlkcmF0aW5nKSkge1xuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgdmFyIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgdmFyIHBhcmVudEVsbSQxID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG4gICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0kMSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgICAgIC8vIGNvbXBvbmVudCByb290IGVsZW1lbnQgcmVwbGFjZWQuXG4gICAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xuICAgICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBjYnMuY3JlYXRlW2ldKGVtcHR5Tm9kZSwgdm5vZGUucGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtJDEpKSB7XG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSQxLCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmNvbXBvbmVudFVwZGF0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcbiAgICB2YXIgY2FsbEluc2VydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0NyZWF0ZSkge1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdpbnNlcnQnLCBjYWxsSW5zZXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbEluc2VydCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGgpIHtcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aFBvc3RwYXRjaFtpXSwgJ2NvbXBvbmVudFVwZGF0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFpc0NyZWF0ZSkge1xuICAgIGZvciAoa2V5IGluIG9sZERpcnMpIHtcbiAgICAgIGlmICghbmV3RGlyc1trZXldKSB7XG4gICAgICAgIC8vIG5vIGxvbmdlciBwcmVzZW50LCB1bmJpbmRcbiAgICAgICAgY2FsbEhvb2skMShvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBlbXB0eU1vZGlmaWVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXG4gIGRpcnMsXG4gIHZtXG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghZGlycykge1xuICAgIHJldHVybiByZXNcbiAgfVxuICB2YXIgaSwgZGlyO1xuICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XG4gICAgfVxuICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xuICAgIGRpci5kZWYgPSByZXNvbHZlQXNzZXQodm0uJG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyLm5hbWUsIHRydWUpO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XG4gIHJldHVybiBkaXIucmF3TmFtZSB8fCAoKGRpci5uYW1lKSArIFwiLlwiICsgKE9iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKSkpXG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rJDEgKGRpciwgaG9vaywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcbiAgdmFyIGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xuICBpZiAoZm4pIHtcbiAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICB9XG59XG5cbnZhciBiYXNlTW9kdWxlcyA9IFtcbiAgcmVmLFxuICBkaXJlY3RpdmVzXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQXR0cnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoIW9sZFZub2RlLmRhdGEuYXR0cnMgJiYgIXZub2RlLmRhdGEuYXR0cnMpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXIsIG9sZDtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgdmFyIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChhdHRycy5fX29iX18pIHtcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICB9XG4gIH1cbiAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFOSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGF0dHJzW2tleV0gPT0gbnVsbCkge1xuICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgICAgfSBlbHNlIGlmICghaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXG4gICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBrZXkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJyA/ICdmYWxzZScgOiAndHJ1ZScpO1xuICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYXR0cnMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQXR0cnMsXG4gIHVwZGF0ZTogdXBkYXRlQXR0cnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVDbGFzcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG4gIGlmICghZGF0YS5zdGF0aWNDbGFzcyAmJiAhZGF0YS5jbGFzcyAmJlxuICAgICAgKCFvbGREYXRhIHx8ICghb2xkRGF0YS5zdGF0aWNDbGFzcyAmJiAhb2xkRGF0YS5jbGFzcykpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAodHJhbnNpdGlvbkNsYXNzKSB7XG4gICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gIH1cblxuICAvLyBzZXQgdGhlIGNsYXNzXG4gIGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcbiAgICBlbC5fcHJldkNsYXNzID0gY2xzO1xuICB9XG59XG5cbnZhciBrbGFzcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcbiAgdXBkYXRlOiB1cGRhdGVDbGFzc1xufTtcblxuLyogICovXG5cbnZhciB2YWxpZERpdmlzaW9uQ2hhclJFID0gL1tcXHcpLitcXC1fJFxcXV0vO1xuXG5mdW5jdGlvbiBwYXJzZUZpbHRlcnMgKGV4cCkge1xuICB2YXIgaW5TaW5nbGUgPSBmYWxzZTtcbiAgdmFyIGluRG91YmxlID0gZmFsc2U7XG4gIHZhciBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XG4gIHZhciBpblJlZ2V4ID0gZmFsc2U7XG4gIHZhciBjdXJseSA9IDA7XG4gIHZhciBzcXVhcmUgPSAwO1xuICB2YXIgcGFyZW4gPSAwO1xuICB2YXIgbGFzdEZpbHRlckluZGV4ID0gMDtcbiAgdmFyIGMsIHByZXYsIGksIGV4cHJlc3Npb24sIGZpbHRlcnM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4cC5sZW5ndGg7IGkrKykge1xuICAgIHByZXYgPSBjO1xuICAgIGMgPSBleHAuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoaW5TaW5nbGUpIHtcbiAgICAgIGlmIChjID09PSAweDI3ICYmIHByZXYgIT09IDB4NUMpIHsgaW5TaW5nbGUgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5Eb3VibGUpIHtcbiAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NUMpIHsgaW5Eb3VibGUgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5UZW1wbGF0ZVN0cmluZykge1xuICAgICAgaWYgKGMgPT09IDB4NjAgJiYgcHJldiAhPT0gMHg1QykgeyBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluUmVnZXgpIHtcbiAgICAgIGlmIChjID09PSAweDJmICYmIHByZXYgIT09IDB4NUMpIHsgaW5SZWdleCA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGMgPT09IDB4N0MgJiYgLy8gcGlwZVxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSArIDEpICE9PSAweDdDICYmXG4gICAgICBleHAuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N0MgJiZcbiAgICAgICFjdXJseSAmJiAhc3F1YXJlICYmICFwYXJlblxuICAgICkge1xuICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgMHgyMjogaW5Eb3VibGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vIFwiXG4gICAgICAgIGNhc2UgMHgyNzogaW5TaW5nbGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vICdcbiAgICAgICAgY2FzZSAweDYwOiBpblRlbXBsYXRlU3RyaW5nID0gdHJ1ZTsgYnJlYWsgLy8gYFxuICAgICAgICBjYXNlIDB4Mjg6IHBhcmVuKys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyAoXG4gICAgICAgIGNhc2UgMHgyOTogcGFyZW4tLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIClcbiAgICAgICAgY2FzZSAweDVCOiBzcXVhcmUrKzsgYnJlYWsgICAgICAgICAgICAgICAgLy8gW1xuICAgICAgICBjYXNlIDB4NUQ6IHNxdWFyZS0tOyBicmVhayAgICAgICAgICAgICAgICAvLyBdXG4gICAgICAgIGNhc2UgMHg3QjogY3VybHkrKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgY2FzZSAweDdEOiBjdXJseS0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgfVxuICAgICAgaWYgKGMgPT09IDB4MmYpIHsgLy8gL1xuICAgICAgICB2YXIgaiA9IGkgLSAxO1xuICAgICAgICB2YXIgcCA9ICh2b2lkIDApO1xuICAgICAgICAvLyBmaW5kIGZpcnN0IG5vbi13aGl0ZXNwYWNlIHByZXYgY2hhclxuICAgICAgICBmb3IgKDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBwID0gZXhwLmNoYXJBdChqKTtcbiAgICAgICAgICBpZiAocCAhPT0gJyAnKSB7IGJyZWFrIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXAgfHwgIXZhbGlkRGl2aXNpb25DaGFyUkUudGVzdChwKSkge1xuICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICB9IGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xuICAgIHB1c2hGaWx0ZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hGaWx0ZXIgKCkge1xuICAgIChmaWx0ZXJzIHx8IChmaWx0ZXJzID0gW10pKS5wdXNoKGV4cC5zbGljZShsYXN0RmlsdGVySW5kZXgsIGkpLnRyaW0oKSk7XG4gICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gIH1cblxuICBpZiAoZmlsdGVycykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleHByZXNzaW9uID0gd3JhcEZpbHRlcihleHByZXNzaW9uLCBmaWx0ZXJzW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwcmVzc2lvblxufVxuXG5mdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xuICB2YXIgaSA9IGZpbHRlci5pbmRleE9mKCcoJyk7XG4gIGlmIChpIDwgMCkge1xuICAgIC8vIF9mOiByZXNvbHZlRmlsdGVyXG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIGZpbHRlciArIFwiXFxcIikoXCIgKyBleHAgKyBcIilcIilcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIG5hbWUgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIsXCIgKyBhcmdzKVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiYXNlV2FybiAobXNnKSB7XG4gIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSBjb21waWxlcl06IFwiICsgbXNnKSk7XG59XG5cbmZ1bmN0aW9uIHBsdWNrTW9kdWxlRnVuY3Rpb24gKFxuICBtb2R1bGVzLFxuICBrZXlcbikge1xuICByZXR1cm4gbW9kdWxlc1xuICAgID8gbW9kdWxlcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1ba2V5XTsgfSkuZmlsdGVyKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9KVxuICAgIDogW11cbn1cblxuZnVuY3Rpb24gYWRkUHJvcCAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHIgKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAoZWwuYXR0cnMgfHwgKGVsLmF0dHJzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xufVxuXG5mdW5jdGlvbiBhZGREaXJlY3RpdmUgKFxuICBlbCxcbiAgbmFtZSxcbiAgcmF3TmFtZSxcbiAgdmFsdWUsXG4gIGFyZyxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgKGVsLmRpcmVjdGl2ZXMgfHwgKGVsLmRpcmVjdGl2ZXMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCByYXdOYW1lOiByYXdOYW1lLCB2YWx1ZTogdmFsdWUsIGFyZzogYXJnLCBtb2RpZmllcnM6IG1vZGlmaWVycyB9KTtcbn1cblxuZnVuY3Rpb24gYWRkSGFuZGxlciAoXG4gIGVsLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzLFxuICBpbXBvcnRhbnRcbikge1xuICAvLyBjaGVjayBjYXB0dXJlIG1vZGlmaWVyXG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLmNhcHR1cmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLmNhcHR1cmU7XG4gICAgbmFtZSA9ICchJyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIGNhcHR1cmVkXG4gIH1cbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMub25jZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMub25jZTtcbiAgICBuYW1lID0gJ34nICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgb25jZVxuICB9XG4gIHZhciBldmVudHM7XG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm5hdGl2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMubmF0aXZlO1xuICAgIGV2ZW50cyA9IGVsLm5hdGl2ZUV2ZW50cyB8fCAoZWwubmF0aXZlRXZlbnRzID0ge30pO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50cyA9IGVsLmV2ZW50cyB8fCAoZWwuZXZlbnRzID0ge30pO1xuICB9XG4gIHZhciBuZXdIYW5kbGVyID0geyB2YWx1ZTogdmFsdWUsIG1vZGlmaWVyczogbW9kaWZpZXJzIH07XG4gIHZhciBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgIGltcG9ydGFudCA/IGhhbmRsZXJzLnVuc2hpZnQobmV3SGFuZGxlcikgOiBoYW5kbGVycy5wdXNoKG5ld0hhbmRsZXIpO1xuICB9IGVsc2UgaWYgKGhhbmRsZXJzKSB7XG4gICAgZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzW25hbWVdID0gbmV3SGFuZGxlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICBnZXRTdGF0aWNcbikge1xuICB2YXIgZHluYW1pY1ZhbHVlID1cbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fFxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWJpbmQ6JyArIG5hbWUpO1xuICBpZiAoZHluYW1pY1ZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gcGFyc2VGaWx0ZXJzKGR5bmFtaWNWYWx1ZSlcbiAgfSBlbHNlIGlmIChnZXRTdGF0aWMgIT09IGZhbHNlKSB7XG4gICAgdmFyIHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XG4gICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoZWwsIG5hbWUpIHtcbiAgdmFyIHZhbDtcbiAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuLyogICovXG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxuICovXG5mdW5jdGlvbiBnZW5Db21wb25lbnRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG5cbiAgdmFyIGJhc2VWYWx1ZUV4cHJlc3Npb24gPSAnJCR2JztcbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9IGJhc2VWYWx1ZUV4cHJlc3Npb247XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID1cbiAgICAgIFwiKHR5cGVvZiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIiA9PT0gJ3N0cmluZydcIiArXG4gICAgICAgIFwiPyBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIi50cmltKClcIiArXG4gICAgICAgIFwiOiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIHZhciBhc3NpZ25tZW50ID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG5cbiAgZWwubW9kZWwgPSB7XG4gICAgdmFsdWU6IChcIihcIiArIHZhbHVlICsgXCIpXCIpLFxuICAgIGV4cHJlc3Npb246IChcIlxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLFxuICAgIGNhbGxiYWNrOiAoXCJmdW5jdGlvbiAoXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpIHtcIiArIGFzc2lnbm1lbnQgKyBcIn1cIilcbiAgfTtcbn1cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlZ2VuIGhlbHBlciBmb3IgZ2VuZXJhdGluZyB2LW1vZGVsIHZhbHVlIGFzc2lnbm1lbnQgY29kZS5cbiAqL1xuZnVuY3Rpb24gZ2VuQXNzaWdubWVudENvZGUgKFxuICB2YWx1ZSxcbiAgYXNzaWdubWVudFxuKSB7XG4gIHZhciBtb2RlbFJzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gIGlmIChtb2RlbFJzLmlkeCA9PT0gbnVsbCkge1xuICAgIHJldHVybiAodmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwidmFyICQkZXhwID0gXCIgKyAobW9kZWxScy5leHApICsgXCIsICQkaWR4ID0gXCIgKyAobW9kZWxScy5pZHgpICsgXCI7XCIgK1xuICAgICAgXCJpZiAoIUFycmF5LmlzQXJyYXkoJCRleHApKXtcIiArXG4gICAgICAgIHZhbHVlICsgXCI9XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIgK1xuICAgICAgXCJlbHNleyQkZXhwLnNwbGljZSgkJGlkeCwgMSwgXCIgKyBhc3NpZ25tZW50ICsgXCIpfVwiXG4gIH1cbn1cblxuLyoqXG4gKiBwYXJzZSBkaXJlY3RpdmUgbW9kZWwgdG8gZG8gdGhlIGFycmF5IHVwZGF0ZSB0cmFuc2Zvcm0uIGFbaWR4XSA9IHZhbCA9PiAkJGEuc3BsaWNlKCQkaWR4LCAxLCB2YWwpXG4gKlxuICogZm9yIGxvb3AgcG9zc2libGUgY2FzZXM6XG4gKlxuICogLSB0ZXN0XG4gKiAtIHRlc3RbaWR4XVxuICogLSB0ZXN0W3Rlc3QxW2lkeF1dXG4gKiAtIHRlc3RbXCJhXCJdW2lkeF1cbiAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtpZHhdXVxuICogLSB0ZXN0Lnh4eC5hW1wiYXNhXCJdW3Rlc3QxW2lkeF1dXG4gKlxuICovXG5cbnZhciBsZW47XG52YXIgc3RyO1xudmFyIGNocjtcbnZhciBpbmRleCQxO1xudmFyIGV4cHJlc3Npb25Qb3M7XG52YXIgZXhwcmVzc2lvbkVuZFBvcztcblxuZnVuY3Rpb24gcGFyc2VNb2RlbCAodmFsKSB7XG4gIHN0ciA9IHZhbDtcbiAgbGVuID0gc3RyLmxlbmd0aDtcbiAgaW5kZXgkMSA9IGV4cHJlc3Npb25Qb3MgPSBleHByZXNzaW9uRW5kUG9zID0gMDtcblxuICBpZiAodmFsLmluZGV4T2YoJ1snKSA8IDAgfHwgdmFsLmxhc3RJbmRleE9mKCddJykgPCBsZW4gLSAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cDogdmFsLFxuICAgICAgaWR4OiBudWxsXG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XG4gICAgICBwYXJzZUJyYWNrZXQoY2hyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cDogdmFsLnN1YnN0cmluZygwLCBleHByZXNzaW9uUG9zKSxcbiAgICBpZHg6IHZhbC5zdWJzdHJpbmcoZXhwcmVzc2lvblBvcyArIDEsIGV4cHJlc3Npb25FbmRQb3MpXG4gIH1cbn1cblxuZnVuY3Rpb24gbmV4dCAoKSB7XG4gIHJldHVybiBzdHIuY2hhckNvZGVBdCgrK2luZGV4JDEpXG59XG5cbmZ1bmN0aW9uIGVvZiAoKSB7XG4gIHJldHVybiBpbmRleCQxID49IGxlblxufVxuXG5mdW5jdGlvbiBpc1N0cmluZ1N0YXJ0IChjaHIpIHtcbiAgcmV0dXJuIGNociA9PT0gMHgyMiB8fCBjaHIgPT09IDB4Mjdcbn1cblxuZnVuY3Rpb24gcGFyc2VCcmFja2V0IChjaHIpIHtcbiAgdmFyIGluQnJhY2tldCA9IDE7XG4gIGV4cHJlc3Npb25Qb3MgPSBpbmRleCQxO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoY2hyID09PSAweDVCKSB7IGluQnJhY2tldCsrOyB9XG4gICAgaWYgKGNociA9PT0gMHg1RCkgeyBpbkJyYWNrZXQtLTsgfVxuICAgIGlmIChpbkJyYWNrZXQgPT09IDApIHtcbiAgICAgIGV4cHJlc3Npb25FbmRQb3MgPSBpbmRleCQxO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcgKGNocikge1xuICB2YXIgc3RyaW5nUXVvdGUgPSBjaHI7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGNociA9PT0gc3RyaW5nUXVvdGUpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiQxO1xuXG4vLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4vLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxudmFyIFJBTkdFX1RPS0VOID0gJ19fcic7XG52YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuZnVuY3Rpb24gbW9kZWwgKFxuICBlbCxcbiAgZGlyLFxuICBfd2FyblxuKSB7XG4gIHdhcm4kMSA9IF93YXJuO1xuICB2YXIgdmFsdWUgPSBkaXIudmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBkaXIubW9kaWZpZXJzO1xuICB2YXIgdGFnID0gZWwudGFnO1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgZHluYW1pY1R5cGUgPSBlbC5hdHRyc01hcFsndi1iaW5kOnR5cGUnXSB8fCBlbC5hdHRyc01hcFsnOnR5cGUnXTtcbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIGR5bmFtaWNUeXBlKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIFwiPGlucHV0IDp0eXBlPVxcXCJcIiArIGR5bmFtaWNUeXBlICsgXCJcXFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OlxcblwiICtcbiAgICAgICAgXCJ2LW1vZGVsIGRvZXMgbm90IHN1cHBvcnQgZHluYW1pYyBpbnB1dCB0eXBlcy4gVXNlIHYtaWYgYnJhbmNoZXMgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuICAgICAgICBcIkZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICBnZW5TZWxlY3QoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgZ2VuQ2hlY2tib3hNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDEoXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgIFwidi1tb2RlbCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZWxlbWVudCB0eXBlLiBcIiArXG4gICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nXG4gICAgKTtcbiAgfVxuXG4gIC8vIGVuc3VyZSBydW50aW1lIGRpcmVjdGl2ZSBtZXRhZGF0YVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZW5DaGVja2JveE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YXIgdHJ1ZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHJ1ZS12YWx1ZScpIHx8ICd0cnVlJztcbiAgdmFyIGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJyxcbiAgICBcIkFycmF5LmlzQXJyYXkoXCIgKyB2YWx1ZSArIFwiKVwiICtcbiAgICAgIFwiP19pKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKT4tMVwiICsgKFxuICAgICAgICB0cnVlVmFsdWVCaW5kaW5nID09PSAndHJ1ZSdcbiAgICAgICAgICA/IChcIjooXCIgKyB2YWx1ZSArIFwiKVwiKVxuICAgICAgICAgIDogKFwiOl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIilcIilcbiAgICAgIClcbiAgKTtcbiAgYWRkSGFuZGxlcihlbCwgQ0hFQ0tCT1hfUkFESU9fVE9LRU4sXG4gICAgXCJ2YXIgJCRhPVwiICsgdmFsdWUgKyBcIixcIiArXG4gICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXG4gICAgICAgIFwiJCRjPSQkZWwuY2hlY2tlZD8oXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpOihcIiArIGZhbHNlVmFsdWVCaW5kaW5nICsgXCIpO1wiICtcbiAgICAnaWYoQXJyYXkuaXNBcnJheSgkJGEpKXsnICtcbiAgICAgIFwidmFyICQkdj1cIiArIChudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZykgKyBcIixcIiArXG4gICAgICAgICAgJyQkaT1faSgkJGEsJCR2KTsnICtcbiAgICAgIFwiaWYoJCRjKXskJGk8MCYmKFwiICsgdmFsdWUgKyBcIj0kJGEuY29uY2F0KCQkdikpfVwiICtcbiAgICAgIFwiZWxzZXskJGk+LTEmJihcIiArIHZhbHVlICsgXCI9JCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSkpfVwiICtcbiAgICBcIn1lbHNle1wiICsgdmFsdWUgKyBcIj0kJGN9XCIsXG4gICAgbnVsbCwgdHJ1ZVxuICApO1xufVxuXG5mdW5jdGlvbiBnZW5SYWRpb01vZGVsIChcbiAgICBlbCxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YWx1ZUJpbmRpbmcgPSBudW1iZXIgPyAoXCJfbihcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSA6IHZhbHVlQmluZGluZztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLCAoXCJfcShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCBDSEVDS0JPWF9SQURJT19UT0tFTiwgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlQmluZGluZyksIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5TZWxlY3QgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHNlbGVjdGVkVmFsID0gXCJBcnJheS5wcm90b3R5cGUuZmlsdGVyXCIgK1xuICAgIFwiLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSlcIiArXG4gICAgXCIubWFwKGZ1bmN0aW9uKG8pe3ZhciB2YWwgPSBcXFwiX3ZhbHVlXFxcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO1wiICtcbiAgICBcInJldHVybiBcIiArIChudW1iZXIgPyAnX24odmFsKScgOiAndmFsJykgKyBcIn0pXCI7XG5cbiAgdmFyIGFzc2lnbm1lbnQgPSAnJGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdJztcbiAgdmFyIGNvZGUgPSBcInZhciAkJHNlbGVjdGVkVmFsID0gXCIgKyBzZWxlY3RlZFZhbCArIFwiO1wiO1xuICBjb2RlID0gY29kZSArIFwiIFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBhc3NpZ25tZW50KSk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBjb2RlLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuRGVmYXVsdE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBsYXp5ID0gcmVmLmxhenk7XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuICB2YXIgbmVlZENvbXBvc2l0aW9uR3VhcmQgPSAhbGF6eSAmJiB0eXBlICE9PSAncmFuZ2UnO1xuICB2YXIgZXZlbnQgPSBsYXp5XG4gICAgPyAnY2hhbmdlJ1xuICAgIDogdHlwZSA9PT0gJ3JhbmdlJ1xuICAgICAgPyBSQU5HRV9UT0tFTlxuICAgICAgOiAnaW5wdXQnO1xuXG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSAnJGV2ZW50LnRhcmdldC52YWx1ZSc7XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCIkZXZlbnQudGFyZ2V0LnZhbHVlLnRyaW0oKVwiO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cblxuICB2YXIgY29kZSA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuICBpZiAobmVlZENvbXBvc2l0aW9uR3VhcmQpIHtcbiAgICBjb2RlID0gXCJpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZylyZXR1cm47XCIgKyBjb2RlO1xuICB9XG5cbiAgYWRkUHJvcChlbCwgJ3ZhbHVlJywgKFwiKFwiICsgdmFsdWUgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCBldmVudCwgY29kZSwgbnVsbCwgdHJ1ZSk7XG4gIGlmICh0cmltIHx8IG51bWJlciB8fCB0eXBlID09PSAnbnVtYmVyJykge1xuICAgIGFkZEhhbmRsZXIoZWwsICdibHVyJywgJyRmb3JjZVVwZGF0ZSgpJyk7XG4gIH1cbn1cblxuLyogICovXG5cbi8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cbi8vIGl0J3MgaW1wb3J0YW50IHRvIHBsYWNlIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgaW4gdGhlIGFycmF5IGJlY2F1c2Vcbi8vIHRoZSB3aG9sZSBwb2ludCBpcyBlbnN1cmluZyB0aGUgdi1tb2RlbCBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmVcbi8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXG5mdW5jdGlvbiBub3JtYWxpemVFdmVudHMgKG9uKSB7XG4gIHZhciBldmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChvbltSQU5HRV9UT0tFTl0pIHtcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XG4gICAgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcbiAgfVxuICBpZiAob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSB7XG4gICAgLy8gQ2hyb21lIGZpcmVzIG1pY3JvdGFza3MgaW4gYmV0d2VlbiBjbGljay9jaGFuZ2UsIGxlYWRzIHRvICM0NTIxXG4gICAgZXZlbnQgPSBpc0Nocm9tZSA/ICdjbGljaycgOiAnY2hhbmdlJztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG4gIH1cbn1cblxudmFyIHRhcmdldCQxO1xuXG5mdW5jdGlvbiBhZGQkMSAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBvbmNlLFxuICBjYXB0dXJlXG4pIHtcbiAgaWYgKG9uY2UpIHtcbiAgICB2YXIgb2xkSGFuZGxlciA9IGhhbmRsZXI7XG4gICAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgICBoYW5kbGVyID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICB2YXIgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IG9sZEhhbmRsZXIoZXYpXG4gICAgICAgIDogb2xkSGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgICByZW1vdmUkMihldmVudCwgaGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDIgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgX3RhcmdldFxuKSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKCFvbGRWbm9kZS5kYXRhLm9uICYmICF2bm9kZS5kYXRhLm9uKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9uID0gdm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XG4gIG5vcm1hbGl6ZUV2ZW50cyhvbik7XG4gIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgdm5vZGUuY29udGV4dCk7XG59XG5cbnZhciBldmVudHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuICB1cGRhdGU6IHVwZGF0ZURPTUxpc3RlbmVyc1xufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKCFvbGRWbm9kZS5kYXRhLmRvbVByb3BzICYmICF2bm9kZS5kYXRhLmRvbVByb3BzKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKHByb3BzLl9fb2JfXykge1xuICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICBpZiAocHJvcHNba2V5XSA9PSBudWxsKSB7XG4gICAgICBlbG1ba2V5XSA9ICcnO1xuICAgIH1cbiAgfVxuICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgIGN1ciA9IHByb3BzW2tleV07XG4gICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAvLyBvbiBzdWJzZXF1ZW50IHBhdGNoZXMgKCMzMzYwKVxuICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pIHsgY29udGludWUgfVxuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScpIHtcbiAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXG4gICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG4gICAgICBlbG0uX3ZhbHVlID0gY3VyO1xuICAgICAgLy8gYXZvaWQgcmVzZXR0aW5nIGN1cnNvciBwb3NpdGlvbiB3aGVuIHZhbHVlIGlzIHRoZSBzYW1lXG4gICAgICB2YXIgc3RyQ3VyID0gY3VyID09IG51bGwgPyAnJyA6IFN0cmluZyhjdXIpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgdm5vZGUsIHN0ckN1cikpIHtcbiAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICB9XG4gIH1cbn1cblxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXG5cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKFxuICBlbG0sXG4gIHZub2RlLFxuICBjaGVja1ZhbFxuKSB7XG4gIHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxuICAgIHZub2RlLnRhZyA9PT0gJ29wdGlvbicgfHxcbiAgICBpc0RpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XG4gICAgaXNJbnB1dENoYW5nZWQoZWxtLCBjaGVja1ZhbClcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcbn1cblxuZnVuY3Rpb24gaXNJbnB1dENoYW5nZWQgKGVsbSwgbmV3VmFsKSB7XG4gIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gIGlmICgobW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXIpIHx8IGVsbS50eXBlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgfVxuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy50cmltKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGNoaWxkTm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKSkge1xuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xuICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gIH1cblxuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBjc3NWYXJSRSA9IC9eLS0vO1xudmFyIGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG52YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIGVsLnN0eWxlW25vcm1hbGl6ZShuYW1lKV0gPSB2YWw7XG4gIH1cbn07XG5cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG52YXIgdGVzdEVsO1xudmFyIG5vcm1hbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAocHJvcCkge1xuICB0ZXN0RWwgPSB0ZXN0RWwgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIHRlc3RFbC5zdHlsZSkpIHtcbiAgICByZXR1cm4gcHJvcFxuICB9XG4gIHZhciB1cHBlciA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByZWZpeGVkID0gcHJlZml4ZXNbaV0gKyB1cHBlcjtcbiAgICBpZiAocHJlZml4ZWQgaW4gdGVzdEVsLnN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ZWRcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmICghZGF0YS5zdGF0aWNTdHlsZSAmJiAhZGF0YS5zdHlsZSAmJlxuICAgICAgIW9sZERhdGEuc3RhdGljU3R5bGUgJiYgIW9sZERhdGEuc3R5bGUpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjdXIsIG5hbWU7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFN0YXRpY1N0eWxlID0gb2xkVm5vZGUuZGF0YS5zdGF0aWNTdHlsZTtcbiAgdmFyIG9sZFN0eWxlQmluZGluZyA9IG9sZFZub2RlLmRhdGEuc3R5bGUgfHwge307XG5cbiAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcbiAgdmFyIG9sZFN0eWxlID0gb2xkU3RhdGljU3R5bGUgfHwgb2xkU3R5bGVCaW5kaW5nO1xuXG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcblxuICB2bm9kZS5kYXRhLnN0eWxlID0gc3R5bGUuX19vYl9fID8gZXh0ZW5kKHt9LCBzdHlsZSkgOiBzdHlsZTtcblxuICB2YXIgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XG5cbiAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgaWYgKG5ld1N0eWxlW25hbWVdID09IG51bGwpIHtcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHN0eWxlID0ge1xuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG59O1xuXG4vKiAgKi9cblxuLyoqXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIudHJpbSgpKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb24gKGRlZiQkMSkge1xuICBpZiAoIWRlZiQkMSkge1xuICAgIHJldHVyblxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgZGVmJCQxID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICBpZiAoZGVmJCQxLmNzcyAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuZChyZXMsIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMS5uYW1lIHx8ICd2JykpO1xuICAgIH1cbiAgICBleHRlbmQocmVzLCBkZWYkJDEpO1xuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmJCQxID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEpXG4gIH1cbn1cblxudmFyIGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB7XG4gICAgZW50ZXJDbGFzczogKG5hbWUgKyBcIi1lbnRlclwiKSxcbiAgICBlbnRlclRvQ2xhc3M6IChuYW1lICsgXCItZW50ZXItdG9cIiksXG4gICAgZW50ZXJBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1lbnRlci1hY3RpdmVcIiksXG4gICAgbGVhdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZVwiKSxcbiAgICBsZWF2ZVRvQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtdG9cIiksXG4gICAgbGVhdmVBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZS1hY3RpdmVcIilcbiAgfVxufSk7XG5cbnZhciBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcbnZhciBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xudmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuXG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG52YXIgdHJhbnNpdGlvblByb3AgPSAndHJhbnNpdGlvbic7XG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xudmFyIGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcbnZhciBhbmltYXRpb25FbmRFdmVudCA9ICdhbmltYXRpb25lbmQnO1xuaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gIH1cbiAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gIDogc2V0VGltZW91dDtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pKS5wdXNoKGNscyk7XG4gIGFkZENsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgIHJlbW92ZShlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XG4gIH1cbiAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyAoXG4gIGVsLFxuICBleHBlY3RlZFR5cGUsXG4gIGNiXG4pIHtcbiAgdmFyIHJlZiA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICB2YXIgdGltZW91dCA9IHJlZi50aW1lb3V0O1xuICB2YXIgcHJvcENvdW50ID0gcmVmLnByb3BDb3VudDtcbiAgaWYgKCF0eXBlKSB7IHJldHVybiBjYigpIH1cbiAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICB2YXIgZW5kZWQgPSAwO1xuICB2YXIgZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgICBjYigpO1xuICB9O1xuICB2YXIgb25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgIGlmICgrK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgICBlbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9LCB0aW1lb3V0ICsgMSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbn1cblxudmFyIHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcblxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgdmFyIHRyYW5zaXRpb25EZWxheXMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgdmFyIGFuaW1hdGlvbkRlbGF5cyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gIHZhciB0eXBlO1xuICB2YXIgdGltZW91dCA9IDA7XG4gIHZhciBwcm9wQ291bnQgPSAwO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxuICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgIDogQU5JTUFUSU9OXG4gICAgICA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICA6IDA7XG4gIH1cbiAgdmFyIGhhc1RyYW5zZm9ybSA9XG4gICAgdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxuICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVvdXQgKGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcbiAgfSkpXG59XG5cbmZ1bmN0aW9uIHRvTXMgKHMpIHtcbiAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKSkgKiAxMDAwXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnRlciAodm5vZGUsIHRvZ2dsZURpc3BsYXkpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgbGVhdmUgY2FsbGJhY2sgbm93XG4gIGlmIChlbC5fbGVhdmVDYikge1xuICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2xlYXZlQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKCFkYXRhKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGVsLl9lbnRlckNiIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcbiAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcbiAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG4gIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xuICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcbiAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgfVxuXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgPyBhcHBlYXJDbGFzc1xuICAgIDogZW50ZXJDbGFzcztcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICA/IGFwcGVhclRvQ2xhc3NcbiAgICA6IGVudGVyVG9DbGFzcztcblxuICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgOiBiZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcilcbiAgICA6IGFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBleHBsaWNpdEVudGVyRHVyYXRpb24gIT0gbnVsbCkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZW50ZXJIb29rKTtcblxuICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICB9XG4gICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xuICAgIH1cbiAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgLy8gcmVtb3ZlIHBlbmRpbmcgbGVhdmUgZWxlbWVudCBvbiBlbnRlciBieSBpbmplY3RpbmcgYW4gaW5zZXJ0IGhvb2tcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ2luc2VydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgdmFyIHBlbmRpbmdOb2RlID0gcGFyZW50ICYmIHBhcmVudC5fcGVuZGluZyAmJiBwYXJlbnQuX3BlbmRpbmdbdm5vZGUua2V5XTtcbiAgICAgIGlmIChwZW5kaW5nTm9kZSAmJlxuICAgICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uKSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gIGlmIChlbC5fZW50ZXJDYikge1xuICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2VudGVyQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKCFkYXRhKSB7XG4gICAgcmV0dXJuIHJtKClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwuX2xlYXZlQ2IgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBsZWF2ZUNsYXNzID0gZGF0YS5sZWF2ZUNsYXNzO1xuICB2YXIgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3M7XG4gIHZhciBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlTGVhdmUgPSBkYXRhLmJlZm9yZUxlYXZlO1xuICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xuICB2YXIgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZTtcbiAgdmFyIGxlYXZlQ2FuY2VsbGVkID0gZGF0YS5sZWF2ZUNhbmNlbGxlZDtcbiAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcblxuICB2YXIgZXhwbGljaXRMZWF2ZUR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmxlYXZlXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZXhwbGljaXRMZWF2ZUR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbdm5vZGUua2V5XSA9IHZub2RlO1xuICAgIH1cbiAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxuZnVuY3Rpb24gY2hlY2tEdXJhdGlvbiAodmFsLCBuYW1lLCB2bm9kZSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gXCIgK1xuICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIgK1xuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICBpZiAoIWZuKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaW52b2tlckZucykge1xuICAgIC8vIGludm9rZXJcbiAgICByZXR1cm4gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChcbiAgICAgIEFycmF5LmlzQXJyYXkoaW52b2tlckZucylcbiAgICAgICAgPyBpbnZva2VyRm5zWzBdXG4gICAgICAgIDogaW52b2tlckZuc1xuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKGZuLl9sZW5ndGggfHwgZm4ubGVuZ3RoKSA+IDFcbiAgfVxufVxuXG5mdW5jdGlvbiBfZW50ZXIgKF8sIHZub2RlKSB7XG4gIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUkJDEgKHZub2RlLCBybSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge307XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG4gIGF0dHJzLFxuICBrbGFzcyxcbiAgZXZlbnRzLFxuICBkb21Qcm9wcyxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb25cbl07XG5cbi8qICAqL1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG52YXIgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xuXG52YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyB9KTtcblxuLyoqXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoaXNJRTkpIHtcbiAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBtb2RlbCQxID0ge1xuICBpbnNlcnRlZDogZnVuY3Rpb24gaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICB2YXIgY2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBjYigpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSB8fCBpc0VkZ2UpIHtcbiAgICAgICAgc2V0VGltZW91dChjYiwgMCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgZWwudHlwZSA9PT0gJ3RleHQnIHx8IGVsLnR5cGUgPT09ICdwYXNzd29yZCcpIHtcbiAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcbiAgICAgICAgaWYgKCFpc0FuZHJvaWQpIHtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNJRTkpIHtcbiAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgdmFyIG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXG4gICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGVsLm9wdGlvbnMpOyB9KVxuICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBlbC5vcHRpb25zKTtcbiAgICAgIGlmIChuZWVkUmVzZXQpIHtcbiAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFwiXCIgKyAoYmluZGluZy5leHByZXNzaW9uKSArIFwiXFxcIj4gXCIgK1xuICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlbGVjdGVkLCBvcHRpb247XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gb3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb25zW2ldKSwgdmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uXG4gICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgOiBvcHRpb24udmFsdWVcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gIHRyaWdnZXIoZS50YXJnZXQsICdpbnB1dCcpO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG4vKiAgKi9cblxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuZnVuY3Rpb24gbG9jYXRlTm9kZSAodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxuICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgOiB2bm9kZVxufVxuXG52YXIgc2hvdyA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG5cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgdmFyIG9yaWdpbmFsRGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24gJiYgIWlzSUU5KSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICB2YXIgb2xkVmFsdWUgPSByZWYub2xkVmFsdWU7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodmFsdWUgPT09IG9sZFZhbHVlKSB7IHJldHVybiB9XG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIGlmICh0cmFuc2l0aW9uICYmICFpc0lFOSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCAoXG4gICAgZWwsXG4gICAgYmluZGluZyxcbiAgICB2bm9kZSxcbiAgICBvbGRWbm9kZSxcbiAgICBpc0Rlc3Ryb3lcbiAgKSB7XG4gICAgaWYgKCFpc0Rlc3Ryb3kpIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xuICBtb2RlbDogbW9kZWwkMSxcbiAgc2hvdzogc2hvd1xufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgYSBzaW5nbGUgZWxlbWVudC9jb21wb25lbnQuXG4vLyBzdXBwb3J0cyB0cmFuc2l0aW9uIG1vZGUgKG91dC1pbiAvIGluLW91dClcblxudmFyIHRyYW5zaXRpb25Qcm9wcyA9IHtcbiAgbmFtZTogU3RyaW5nLFxuICBhcHBlYXI6IEJvb2xlYW4sXG4gIGNzczogQm9vbGVhbixcbiAgbW9kZTogU3RyaW5nLFxuICB0eXBlOiBTdHJpbmcsXG4gIGVudGVyQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmcsXG4gIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJDbGFzczogU3RyaW5nLFxuICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gIGR1cmF0aW9uOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF1cbn07XG5cbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuLy8gd2Ugd2FudCB0byByZWN1cnNpdmVseSByZXRyaWV2ZSB0aGUgcmVhbCBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWRcbmZ1bmN0aW9uIGdldFJlYWxDaGlsZCAodm5vZGUpIHtcbiAgdmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGNvbXBPcHRpb25zICYmIGNvbXBPcHRpb25zLkN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHJldHVybiBnZXRSZWFsQ2hpbGQoZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjb21wT3B0aW9ucy5jaGlsZHJlbikpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhIChjb21wKSB7XG4gIHZhciBkYXRhID0ge307XG4gIHZhciBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcbiAgLy8gcHJvcHNcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XG4gICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICB9XG4gIC8vIGV2ZW50cy5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gIHZhciBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGZvciAodmFyIGtleSQxIGluIGxpc3RlbmVycykge1xuICAgIGRhdGFbY2FtZWxpemUoa2V5JDEpXSA9IGxpc3RlbmVyc1trZXkkMV07XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gcGxhY2Vob2xkZXIgKGgsIHJhd0NoaWxkKSB7XG4gIHJldHVybiAvXFxkLWtlZXAtYWxpdmUkLy50ZXN0KHJhd0NoaWxkLnRhZylcbiAgICA/IGgoJ2tlZXAtYWxpdmUnKVxuICAgIDogbnVsbFxufVxuXG5mdW5jdGlvbiBoYXNQYXJlbnRUcmFuc2l0aW9uICh2bm9kZSkge1xuICB3aGlsZSAoKHZub2RlID0gdm5vZGUucGFyZW50KSkge1xuICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2FtZUNoaWxkIChjaGlsZCwgb2xkQ2hpbGQpIHtcbiAgcmV0dXJuIG9sZENoaWxkLmtleSA9PT0gY2hpbGQua2V5ICYmIG9sZENoaWxkLnRhZyA9PT0gY2hpbGQudGFnXG59XG5cbnZhciBUcmFuc2l0aW9uID0ge1xuICBuYW1lOiAndHJhbnNpdGlvbicsXG4gIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudGFnOyB9KTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgbW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJykge1xuICAgICAgd2FybihcbiAgICAgICAgJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXG4gICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcbiAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXG4gICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgIH1cblxuICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICB2YXIgaWQgPSBcIl9fdHJhbnNpdGlvbi1cIiArICh0aGlzLl91aWQpICsgXCItXCI7XG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgID8gaWQgKyBjaGlsZC50YWdcbiAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICA6IGNoaWxkLmtleTtcblxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH0pKSB7XG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvbGRDaGlsZCAmJiBvbGRDaGlsZC5kYXRhICYmICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpKSB7XG4gICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcbiAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgIHZhciBvbGREYXRhID0gb2xkQ2hpbGQgJiYgKG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSkpO1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcyQxLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xuICAgICAgICB2YXIgZGVsYXllZExlYXZlO1xuICAgICAgICB2YXIgcGVyZm9ybUxlYXZlID0gZnVuY3Rpb24gKCkgeyBkZWxheWVkTGVhdmUoKTsgfTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGZ1bmN0aW9uIChsZWF2ZSkgeyBkZWxheWVkTGVhdmUgPSBsZWF2ZTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd0NoaWxkXG4gIH1cbn07XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGxpc3QgaXRlbXMuXG4vLyBzdXBwb3J0cyBtb3ZlIHRyYW5zaXRpb25zIHVzaW5nIHRoZSBGTElQIHRlY2huaXF1ZS5cblxuLy8gQmVjYXVzZSB0aGUgdmRvbSdzIGNoaWxkcmVuIHVwZGF0ZSBhbGdvcml0aG0gaXMgXCJ1bnN0YWJsZVwiIC0gaS5lLlxuLy8gaXQgZG9lc24ndCBndWFyYW50ZWUgdGhlIHJlbGF0aXZlIHBvc2l0aW9uaW5nIG9mIHJlbW92ZWQgZWxlbWVudHMsXG4vLyB3ZSBmb3JjZSB0cmFuc2l0aW9uLWdyb3VwIHRvIHVwZGF0ZSBpdHMgY2hpbGRyZW4gaW50byB0d28gcGFzc2VzOlxuLy8gaW4gdGhlIGZpcnN0IHBhc3MsIHdlIHJlbW92ZSBhbGwgbm9kZXMgdGhhdCBuZWVkIHRvIGJlIHJlbW92ZWQsXG4vLyB0cmlnZ2VyaW5nIHRoZWlyIGxlYXZpbmcgdHJhbnNpdGlvbjsgaW4gdGhlIHNlY29uZCBwYXNzLCB3ZSBpbnNlcnQvbW92ZVxuLy8gaW50byB0aGUgZmluYWwgZGVzaXJlZCBzdGF0ZS4gVGhpcyB3YXkgaW4gdGhlIHNlY29uZCBwYXNzIHJlbW92ZWRcbi8vIG5vZGVzIHdpbGwgcmVtYWluIHdoZXJlIHRoZXkgc2hvdWxkIGJlLlxuXG52YXIgcHJvcHMgPSBleHRlbmQoe1xuICB0YWc6IFN0cmluZyxcbiAgbW92ZUNsYXNzOiBTdHJpbmdcbn0sIHRyYW5zaXRpb25Qcm9wcyk7XG5cbmRlbGV0ZSBwcm9wcy5tb2RlO1xuXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xuICBwcm9wczogcHJvcHMsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGFnID0gdGhpcy50YWcgfHwgdGhpcy4kdm5vZGUuZGF0YS50YWcgfHwgJ3NwYW4nO1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgdmFyIHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdmFyIHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSByYXdDaGlsZHJlbltpXTtcbiAgICAgIGlmIChjLnRhZykge1xuICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XG4gICAgICAgICAgbWFwW2Mua2V5XSA9IGNcbiAgICAgICAgICA7KGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgIHZhciBuYW1lID0gb3B0cyA/IChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnIHx8ICcnKSA6IGMudGFnO1xuICAgICAgICAgIHdhcm4oKFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcIiArIG5hbWUgKyBcIj5cIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgdmFyIGtlcHQgPSBbXTtcbiAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICB2YXIgYyQxID0gcHJldkNoaWxkcmVuW2kkMV07XG4gICAgICAgIGMkMS5kYXRhLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgYyQxLmRhdGEucG9zID0gYyQxLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1hcFtjJDEua2V5XSkge1xuICAgICAgICAgIGtlcHQucHVzaChjJDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZWQucHVzaChjJDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmtlcHQgPSBoKHRhZywgbnVsbCwga2VwdCk7XG4gICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgIH1cblxuICAgIHJldHVybiBoKHRhZywgbnVsbCwgY2hpbGRyZW4pXG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbiBiZWZvcmVVcGRhdGUgKCkge1xuICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICB0aGlzLl9fcGF0Y2hfXyhcbiAgICAgIHRoaXMuX3Zub2RlLFxuICAgICAgdGhpcy5rZXB0LFxuICAgICAgZmFsc2UsIC8vIGh5ZHJhdGluZ1xuICAgICAgdHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50LCBhdm9pZHMgdW5uZWNlc3NhcnkgbW92ZXMpXG4gICAgKTtcbiAgICB0aGlzLl92bm9kZSA9IHRoaXMua2VwdDtcbiAgfSxcblxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkICgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcbiAgICB2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgIHZhciBmID0gYm9keS5vZmZzZXRIZWlnaHQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgdmFyIGVsID0gYy5lbG07XG4gICAgICAgIHZhciBzID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IgKGUpIHtcbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgaGFzTW92ZTogZnVuY3Rpb24gaGFzTW92ZSAoZWwsIG1vdmVDbGFzcykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faGFzTW92ZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXG4gICAgICB9XG4gICAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcbiAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXG4gICAgICAvLyBpcyBhcHBsaWVkLlxuICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xuICAgICAgfVxuICAgICAgYWRkQ2xhc3MoY2xvbmUsIG1vdmVDbGFzcyk7XG4gICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgdmFyIGluZm8gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gICAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzIChjKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX21vdmVDYikge1xuICAgIGMuZWxtLl9tb3ZlQ2IoKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XG4gICAgYy5lbG0uX2VudGVyQ2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbiAoYykge1xuICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24gKGMpIHtcbiAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gIHZhciBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xuICB2YXIgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcbiAgICB2YXIgcyA9IGMuZWxtLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIGR4ICsgXCJweCxcIiArIGR5ICsgXCJweClcIjtcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gIH1cbn1cblxudmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcbiAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgVHJhbnNpdGlvbkdyb3VwOiBUcmFuc2l0aW9uR3JvdXBcbn07XG5cbi8qICAqL1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXG5WdWUkMy5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcblZ1ZSQzLmNvbmZpZy5pc1Jlc2VydmVkVGFnID0gaXNSZXNlcnZlZFRhZztcblZ1ZSQzLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUkMy5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZSQzLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbmV4dGVuZChWdWUkMy5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZSQzLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZSQzLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlJDMpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0Nocm9tZSkge1xuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgY29uZmlnLnByb2R1Y3Rpb25UaXAgIT09IGZhbHNlICYmXG4gICAgICBpbkJyb3dzZXIgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICBcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5cIiArXG4gICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICBcIlNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sXCJcbiAgICApO1xuICB9XG59LCAwKTtcblxuLyogICovXG5cbi8vIGNoZWNrIHdoZXRoZXIgY3VycmVudCBicm93c2VyIGVuY29kZXMgYSBjaGFyIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzXG5mdW5jdGlvbiBzaG91bGREZWNvZGUgKGNvbnRlbnQsIGVuY29kZWQpIHtcbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gXCI8ZGl2IGE9XFxcIlwiICsgY29udGVudCArIFwiXFxcIj5cIjtcbiAgcmV0dXJuIGRpdi5pbm5lckhUTUwuaW5kZXhPZihlbmNvZGVkKSA+IDBcbn1cblxuLy8gIzM2NjNcbi8vIElFIGVuY29kZXMgbmV3bGluZXMgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2hpbGUgb3RoZXIgYnJvd3NlcnMgZG9uJ3RcbnZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IGluQnJvd3NlciA/IHNob3VsZERlY29kZSgnXFxuJywgJyYjMTA7JykgOiBmYWxzZTtcblxuLyogICovXG5cbnZhciBpc1VuYXJ5VGFnID0gbWFrZU1hcChcbiAgJ2FyZWEsYmFzZSxicixjb2wsZW1iZWQsZnJhbWUsaHIsaW1nLGlucHV0LGlzaW5kZXgsa2V5Z2VuLCcgK1xuICAnbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnInXG4pO1xuXG4vLyBFbGVtZW50cyB0aGF0IHlvdSBjYW4sIGludGVudGlvbmFsbHksIGxlYXZlIG9wZW5cbi8vIChhbmQgd2hpY2ggY2xvc2UgdGhlbXNlbHZlcylcbnZhciBjYW5CZUxlZnRPcGVuVGFnID0gbWFrZU1hcChcbiAgJ2NvbGdyb3VwLGRkLGR0LGxpLG9wdGlvbnMscCx0ZCx0Zm9vdCx0aCx0aGVhZCx0cixzb3VyY2UnXG4pO1xuXG4vLyBIVE1MNSB0YWdzIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbCNlbGVtZW50cy0zXG4vLyBQaHJhc2luZyBDb250ZW50IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI3BocmFzaW5nLWNvbnRlbnRcbnZhciBpc05vblBocmFzaW5nVGFnID0gbWFrZU1hcChcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxiYXNlLGJsb2NrcXVvdGUsYm9keSxjYXB0aW9uLGNvbCxjb2xncm91cCxkZCwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLGRpdixkbCxkdCxmaWVsZHNldCxmaWdjYXB0aW9uLGZpZ3VyZSxmb290ZXIsZm9ybSwnICtcbiAgJ2gxLGgyLGgzLGg0LGg1LGg2LGhlYWQsaGVhZGVyLGhncm91cCxocixodG1sLGxlZ2VuZCxsaSxtZW51aXRlbSxtZXRhLCcgK1xuICAnb3B0Z3JvdXAsb3B0aW9uLHBhcmFtLHJwLHJ0LHNvdXJjZSxzdHlsZSxzdW1tYXJ5LHRib2R5LHRkLHRmb290LHRoLHRoZWFkLCcgK1xuICAndGl0bGUsdHIsdHJhY2snXG4pO1xuXG4vKiAgKi9cblxudmFyIGRlY29kZXI7XG5cbmZ1bmN0aW9uIGRlY29kZSAoaHRtbCkge1xuICBkZWNvZGVyID0gZGVjb2RlciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGVjb2Rlci5pbm5lckhUTUwgPSBodG1sO1xuICByZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudFxufVxuXG4vKipcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGl0J3MgbW9zdGx5IHZlbmRvciBjb2RlLlxuICovXG5cbi8qIVxuICogSFRNTCBQYXJzZXIgQnkgSm9obiBSZXNpZyAoZWpvaG4ub3JnKVxuICogTW9kaWZpZWQgYnkgSnVyaXkgXCJrYW5nYXhcIiBaYXl0c2V2XG4gKiBPcmlnaW5hbCBjb2RlIGJ5IEVyaWsgQXJ2aWRzc29uLCBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlXG4gKiBodHRwOi8vZXJpay5lYWUubmV0L3NpbXBsZWh0bWxwYXJzZXIvc2ltcGxlaHRtbHBhcnNlci5qc1xuICovXG5cbi8vIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIHBhcnNpbmcgdGFncyBhbmQgYXR0cmlidXRlc1xudmFyIHNpbmdsZUF0dHJJZGVudGlmaWVyID0gLyhbXlxcc1wiJzw+Lz1dKykvO1xudmFyIHNpbmdsZUF0dHJBc3NpZ24gPSAvKD86PSkvO1xudmFyIHNpbmdsZUF0dHJWYWx1ZXMgPSBbXG4gIC8vIGF0dHIgdmFsdWUgZG91YmxlIHF1b3Rlc1xuICAvXCIoW15cIl0qKVwiKy8uc291cmNlLFxuICAvLyBhdHRyIHZhbHVlLCBzaW5nbGUgcXVvdGVzXG4gIC8nKFteJ10qKScrLy5zb3VyY2UsXG4gIC8vIGF0dHIgdmFsdWUsIG5vIHF1b3Rlc1xuICAvKFteXFxzXCInPTw+YF0rKS8uc291cmNlXG5dO1xudmFyIGF0dHJpYnV0ZSA9IG5ldyBSZWdFeHAoXG4gICdeXFxcXHMqJyArIHNpbmdsZUF0dHJJZGVudGlmaWVyLnNvdXJjZSArXG4gICcoPzpcXFxccyooJyArIHNpbmdsZUF0dHJBc3NpZ24uc291cmNlICsgJyknICtcbiAgJ1xcXFxzKig/OicgKyBzaW5nbGVBdHRyVmFsdWVzLmpvaW4oJ3wnKSArICcpKT8nXG4pO1xuXG4vLyBjb3VsZCB1c2UgaHR0cHM6Ly93d3cudzMub3JnL1RSLzE5OTkvUkVDLXhtbC1uYW1lcy0xOTk5MDExNC8jTlQtUU5hbWVcbi8vIGJ1dCBmb3IgVnVlIHRlbXBsYXRlcyB3ZSBjYW4gZW5mb3JjZSBhIHNpbXBsZSBjaGFyc2V0XG52YXIgbmNuYW1lID0gJ1thLXpBLVpfXVtcXFxcd1xcXFwtXFxcXC5dKic7XG52YXIgcW5hbWVDYXB0dXJlID0gJygoPzonICsgbmNuYW1lICsgJ1xcXFw6KT8nICsgbmNuYW1lICsgJyknO1xudmFyIHN0YXJ0VGFnT3BlbiA9IG5ldyBSZWdFeHAoJ148JyArIHFuYW1lQ2FwdHVyZSk7XG52YXIgc3RhcnRUYWdDbG9zZSA9IC9eXFxzKihcXC8/KT4vO1xudmFyIGVuZFRhZyA9IG5ldyBSZWdFeHAoJ148XFxcXC8nICsgcW5hbWVDYXB0dXJlICsgJ1tePl0qPicpO1xudmFyIGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcbnZhciBjb21tZW50ID0gL148IS0tLztcbnZhciBjb25kaXRpb25hbENvbW1lbnQgPSAvXjwhXFxbLztcblxudmFyIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBmYWxzZTtcbid4Jy5yZXBsYWNlKC94KC4pPy9nLCBmdW5jdGlvbiAobSwgZykge1xuICBJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOID0gZyA9PT0gJyc7XG59KTtcblxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXG52YXIgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgcmVDYWNoZSA9IHt9O1xuXG52YXIgZGVjb2RpbmdNYXAgPSB7XG4gICcmbHQ7JzogJzwnLFxuICAnJmd0Oyc6ICc+JyxcbiAgJyZxdW90Oyc6ICdcIicsXG4gICcmYW1wOyc6ICcmJyxcbiAgJyYjMTA7JzogJ1xcbidcbn07XG52YXIgZW5jb2RlZEF0dHIgPSAvJig/Omx0fGd0fHF1b3R8YW1wKTsvZztcbnZhciBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzEwKTsvZztcblxuZnVuY3Rpb24gZGVjb2RlQXR0ciAodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKSB7XG4gIHZhciByZSA9IHNob3VsZERlY29kZU5ld2xpbmVzID8gZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgOiBlbmNvZGVkQXR0cjtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmUsIGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gZGVjb2RpbmdNYXBbbWF0Y2hdOyB9KVxufVxuXG5mdW5jdGlvbiBwYXJzZUhUTUwgKGh0bWwsIG9wdGlvbnMpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBleHBlY3RIVE1MID0gb3B0aW9ucy5leHBlY3RIVE1MO1xuICB2YXIgaXNVbmFyeVRhZyQkMSA9IG9wdGlvbnMuaXNVbmFyeVRhZyB8fCBubztcbiAgdmFyIGNhbkJlTGVmdE9wZW5UYWckJDEgPSBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcgfHwgbm87XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0LCBsYXN0VGFnO1xuICB3aGlsZSAoaHRtbCkge1xuICAgIGxhc3QgPSBodG1sO1xuICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgaW4gYSBwbGFpbnRleHQgY29udGVudCBlbGVtZW50IGxpa2Ugc2NyaXB0L3N0eWxlXG4gICAgaWYgKCFsYXN0VGFnIHx8ICFpc1BsYWluVGV4dEVsZW1lbnQobGFzdFRhZykpIHtcbiAgICAgIHZhciB0ZXh0RW5kID0gaHRtbC5pbmRleE9mKCc8Jyk7XG4gICAgICBpZiAodGV4dEVuZCA9PT0gMCkge1xuICAgICAgICAvLyBDb21tZW50OlxuICAgICAgICBpZiAoY29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgdmFyIGNvbW1lbnRFbmQgPSBodG1sLmluZGV4T2YoJy0tPicpO1xuXG4gICAgICAgICAgaWYgKGNvbW1lbnRFbmQgPj0gMCkge1xuICAgICAgICAgICAgYWR2YW5jZShjb21tZW50RW5kICsgMyk7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29uZGl0aW9uYWxfY29tbWVudCNEb3dubGV2ZWwtcmV2ZWFsZWRfY29uZGl0aW9uYWxfY29tbWVudFxuICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29uZGl0aW9uYWxFbmQgPSBodG1sLmluZGV4T2YoJ10+Jyk7XG5cbiAgICAgICAgICBpZiAoY29uZGl0aW9uYWxFbmQgPj0gMCkge1xuICAgICAgICAgICAgYWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb2N0eXBlOlxuICAgICAgICB2YXIgZG9jdHlwZU1hdGNoID0gaHRtbC5tYXRjaChkb2N0eXBlKTtcbiAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xuICAgICAgICAgIGFkdmFuY2UoZG9jdHlwZU1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuZCB0YWc6XG4gICAgICAgIHZhciBlbmRUYWdNYXRjaCA9IGh0bWwubWF0Y2goZW5kVGFnKTtcbiAgICAgICAgaWYgKGVuZFRhZ01hdGNoKSB7XG4gICAgICAgICAgdmFyIGN1ckluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgYWR2YW5jZShlbmRUYWdNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCB0YWc6XG4gICAgICAgIHZhciBzdGFydFRhZ01hdGNoID0gcGFyc2VTdGFydFRhZygpO1xuICAgICAgICBpZiAoc3RhcnRUYWdNYXRjaCkge1xuICAgICAgICAgIGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHRleHQgPSAodm9pZCAwKSwgcmVzdCQxID0gKHZvaWQgMCksIG5leHQgPSAodm9pZCAwKTtcbiAgICAgIGlmICh0ZXh0RW5kID49IDApIHtcbiAgICAgICAgcmVzdCQxID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICFlbmRUYWcudGVzdChyZXN0JDEpICYmXG4gICAgICAgICAgIXN0YXJ0VGFnT3Blbi50ZXN0KHJlc3QkMSkgJiZcbiAgICAgICAgICAhY29tbWVudC50ZXN0KHJlc3QkMSkgJiZcbiAgICAgICAgICAhY29uZGl0aW9uYWxDb21tZW50LnRlc3QocmVzdCQxKVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyA8IGluIHBsYWluIHRleHQsIGJlIGZvcmdpdmluZyBhbmQgdHJlYXQgaXQgYXMgdGV4dFxuICAgICAgICAgIG5leHQgPSByZXN0JDEuaW5kZXhPZignPCcsIDEpO1xuICAgICAgICAgIGlmIChuZXh0IDwgMCkgeyBicmVhayB9XG4gICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xuICAgICAgICAgIHJlc3QkMSA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKDAsIHRleHRFbmQpO1xuICAgICAgICBhZHZhbmNlKHRleHRFbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dEVuZCA8IDApIHtcbiAgICAgICAgdGV4dCA9IGh0bWw7XG4gICAgICAgIGh0bWwgPSAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuY2hhcnMgJiYgdGV4dCkge1xuICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2tlZFRhZyA9IGxhc3RUYWcudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciByZVN0YWNrZWRUYWcgPSByZUNhY2hlW3N0YWNrZWRUYWddIHx8IChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcbiAgICAgIHZhciBlbmRUYWdMZW5ndGggPSAwO1xuICAgICAgdmFyIHJlc3QgPSBodG1sLnJlcGxhY2UocmVTdGFja2VkVGFnLCBmdW5jdGlvbiAoYWxsLCB0ZXh0LCBlbmRUYWcpIHtcbiAgICAgICAgZW5kVGFnTGVuZ3RoID0gZW5kVGFnLmxlbmd0aDtcbiAgICAgICAgaWYgKCFpc1BsYWluVGV4dEVsZW1lbnQoc3RhY2tlZFRhZykgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xuICAgICAgICAgIHRleHQgPSB0ZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvPCEtLShbXFxzXFxTXSo/KS0tPi9nLCAnJDEnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFxbQ0RBVEFcXFsoW1xcc1xcU10qPyldXT4vZywgJyQxJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMpIHtcbiAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgfSk7XG4gICAgICBpbmRleCArPSBodG1sLmxlbmd0aCAtIHJlc3QubGVuZ3RoO1xuICAgICAgaHRtbCA9IHJlc3Q7XG4gICAgICBwYXJzZUVuZFRhZyhzdGFja2VkVGFnLCBpbmRleCAtIGVuZFRhZ0xlbmd0aCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGlmIChodG1sID09PSBsYXN0KSB7XG4gICAgICBvcHRpb25zLmNoYXJzICYmIG9wdGlvbnMuY2hhcnMoaHRtbCk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhc3RhY2subGVuZ3RoICYmIG9wdGlvbnMud2Fybikge1xuICAgICAgICBvcHRpb25zLndhcm4oKFwiTWFsLWZvcm1hdHRlZCB0YWcgYXQgZW5kIG9mIHRlbXBsYXRlOiBcXFwiXCIgKyBodG1sICsgXCJcXFwiXCIpKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXG4gIHBhcnNlRW5kVGFnKCk7XG5cbiAgZnVuY3Rpb24gYWR2YW5jZSAobikge1xuICAgIGluZGV4ICs9IG47XG4gICAgaHRtbCA9IGh0bWwuc3Vic3RyaW5nKG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZyAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gaHRtbC5tYXRjaChzdGFydFRhZ09wZW4pO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgdmFyIG1hdGNoID0ge1xuICAgICAgICB0YWdOYW1lOiBzdGFydFsxXSxcbiAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICBzdGFydDogaW5kZXhcbiAgICAgIH07XG4gICAgICBhZHZhbmNlKHN0YXJ0WzBdLmxlbmd0aCk7XG4gICAgICB2YXIgZW5kLCBhdHRyO1xuICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGF0dHJpYnV0ZSkpKSB7XG4gICAgICAgIGFkdmFuY2UoYXR0clswXS5sZW5ndGgpO1xuICAgICAgICBtYXRjaC5hdHRycy5wdXNoKGF0dHIpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCkge1xuICAgICAgICBtYXRjaC51bmFyeVNsYXNoID0gZW5kWzFdO1xuICAgICAgICBhZHZhbmNlKGVuZFswXS5sZW5ndGgpO1xuICAgICAgICBtYXRjaC5lbmQgPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIG1hdGNoXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlU3RhcnRUYWcgKG1hdGNoKSB7XG4gICAgdmFyIHRhZ05hbWUgPSBtYXRjaC50YWdOYW1lO1xuICAgIHZhciB1bmFyeVNsYXNoID0gbWF0Y2gudW5hcnlTbGFzaDtcblxuICAgIGlmIChleHBlY3RIVE1MKSB7XG4gICAgICBpZiAobGFzdFRhZyA9PT0gJ3AnICYmIGlzTm9uUGhyYXNpbmdUYWcodGFnTmFtZSkpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcobGFzdFRhZyk7XG4gICAgICB9XG4gICAgICBpZiAoY2FuQmVMZWZ0T3BlblRhZyQkMSh0YWdOYW1lKSAmJiBsYXN0VGFnID09PSB0YWdOYW1lKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKHRhZ05hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmFyeSA9IGlzVW5hcnlUYWckJDEodGFnTmFtZSkgfHwgdGFnTmFtZSA9PT0gJ2h0bWwnICYmIGxhc3RUYWcgPT09ICdoZWFkJyB8fCAhIXVuYXJ5U2xhc2g7XG5cbiAgICB2YXIgbCA9IG1hdGNoLmF0dHJzLmxlbmd0aDtcbiAgICB2YXIgYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhcmdzID0gbWF0Y2guYXR0cnNbaV07XG4gICAgICAvLyBoYWNraXNoIHdvcmsgYXJvdW5kIEZGIGJ1ZyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0zNjk3NzhcbiAgICAgIGlmIChJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOICYmIGFyZ3NbMF0uaW5kZXhPZignXCJcIicpID09PSAtMSkge1xuICAgICAgICBpZiAoYXJnc1szXSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbM107IH1cbiAgICAgICAgaWYgKGFyZ3NbNF0gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzRdOyB9XG4gICAgICAgIGlmIChhcmdzWzVdID09PSAnJykgeyBkZWxldGUgYXJnc1s1XTsgfVxuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogYXJnc1sxXSxcbiAgICAgICAgdmFsdWU6IGRlY29kZUF0dHIoXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc1xuICAgICAgICApXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghdW5hcnkpIHtcbiAgICAgIHN0YWNrLnB1c2goeyB0YWc6IHRhZ05hbWUsIGxvd2VyQ2FzZWRUYWc6IHRhZ05hbWUudG9Mb3dlckNhc2UoKSwgYXR0cnM6IGF0dHJzIH0pO1xuICAgICAgbGFzdFRhZyA9IHRhZ05hbWU7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgYXR0cnMsIHVuYXJ5LCBtYXRjaC5zdGFydCwgbWF0Y2guZW5kKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUVuZFRhZyAodGFnTmFtZSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBwb3MsIGxvd2VyQ2FzZWRUYWdOYW1lO1xuICAgIGlmIChzdGFydCA9PSBudWxsKSB7IHN0YXJ0ID0gaW5kZXg7IH1cbiAgICBpZiAoZW5kID09IG51bGwpIHsgZW5kID0gaW5kZXg7IH1cblxuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICBsb3dlckNhc2VkVGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IG9wZW5lZCB0YWcgb2YgdGhlIHNhbWUgdHlwZVxuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICBpZiAoc3RhY2tbcG9zXS5sb3dlckNhc2VkVGFnID09PSBsb3dlckNhc2VkVGFnTmFtZSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcbiAgICAgIHBvcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAvLyBDbG9zZSBhbGwgdGhlIG9wZW4gZWxlbWVudHMsIHVwIHRoZSBzdGFja1xuICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgIChpID4gcG9zIHx8ICF0YWdOYW1lKSAmJlxuICAgICAgICAgICAgb3B0aW9ucy53YXJuKSB7XG4gICAgICAgICAgb3B0aW9ucy53YXJuKFxuICAgICAgICAgICAgKFwidGFnIDxcIiArIChzdGFja1tpXS50YWcpICsgXCI+IGhhcyBubyBtYXRjaGluZyBlbmQgdGFnLlwiKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgb3B0aW9ucy5lbmQoc3RhY2tbaV0udGFnLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIG9wZW4gZWxlbWVudHMgZnJvbSB0aGUgc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCA9IHBvcztcbiAgICAgIGxhc3RUYWcgPSBwb3MgJiYgc3RhY2tbcG9zIC0gMV0udGFnO1xuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdicicpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIHRydWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdwJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgZmFsc2UsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgIG9wdGlvbnMuZW5kKHRhZ05hbWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXG4pKz8pXFx9XFx9L2c7XG52YXIgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG5cbnZhciBidWlsZFJlZ2V4ID0gY2FjaGVkKGZ1bmN0aW9uIChkZWxpbWl0ZXJzKSB7XG4gIHZhciBvcGVuID0gZGVsaW1pdGVyc1swXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgdmFyIGNsb3NlID0gZGVsaW1pdGVyc1sxXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAob3BlbiArICcoKD86LnxcXFxcbikrPyknICsgY2xvc2UsICdnJylcbn0pO1xuXG5mdW5jdGlvbiBwYXJzZVRleHQgKFxuICB0ZXh0LFxuICBkZWxpbWl0ZXJzXG4pIHtcbiAgdmFyIHRhZ1JFID0gZGVsaW1pdGVycyA/IGJ1aWxkUmVnZXgoZGVsaW1pdGVycykgOiBkZWZhdWx0VGFnUkU7XG4gIGlmICghdGFnUkUudGVzdCh0ZXh0KSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIGxhc3RJbmRleCA9IHRhZ1JFLmxhc3RJbmRleCA9IDA7XG4gIHZhciBtYXRjaCwgaW5kZXg7XG4gIHdoaWxlICgobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSkge1xuICAgIGluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgLy8gcHVzaCB0ZXh0IHRva2VuXG4gICAgaWYgKGluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpKSk7XG4gICAgfVxuICAgIC8vIHRhZyB0b2tlblxuICAgIHZhciBleHAgPSBwYXJzZUZpbHRlcnMobWF0Y2hbMV0udHJpbSgpKTtcbiAgICB0b2tlbnMucHVzaCgoXCJfcyhcIiArIGV4cCArIFwiKVwiKSk7XG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gIH1cbiAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodGV4dC5zbGljZShsYXN0SW5kZXgpKSk7XG4gIH1cbiAgcmV0dXJuIHRva2Vucy5qb2luKCcrJylcbn1cblxuLyogICovXG5cbnZhciBvblJFID0gL15AfF52LW9uOi87XG52YXIgZGlyUkUgPSAvXnYtfF5AfF46LztcbnZhciBmb3JBbGlhc1JFID0gLyguKj8pXFxzKyg/OmlufG9mKVxccysoLiopLztcbnZhciBmb3JJdGVyYXRvclJFID0gL1xcKChcXHtbXn1dKlxcfXxbXixdKiksKFteLF0qKSg/OiwoW14sXSopKT9cXCkvO1xuXG52YXIgYXJnUkUgPSAvOiguKikkLztcbnZhciBiaW5kUkUgPSAvXjp8XnYtYmluZDovO1xudmFyIG1vZGlmaWVyUkUgPSAvXFwuW14uXSsvZztcblxudmFyIGRlY29kZUhUTUxDYWNoZWQgPSBjYWNoZWQoZGVjb2RlKTtcblxuLy8gY29uZmlndXJhYmxlIHN0YXRlXG52YXIgd2FybiQyO1xudmFyIGRlbGltaXRlcnM7XG52YXIgdHJhbnNmb3JtcztcbnZhciBwcmVUcmFuc2Zvcm1zO1xudmFyIHBvc3RUcmFuc2Zvcm1zO1xudmFyIHBsYXRmb3JtSXNQcmVUYWc7XG52YXIgcGxhdGZvcm1NdXN0VXNlUHJvcDtcbnZhciBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZTtcblxuLyoqXG4gKiBDb252ZXJ0IEhUTUwgc3RyaW5nIHRvIEFTVC5cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHdhcm4kMiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UgPSBvcHRpb25zLmdldFRhZ05hbWVzcGFjZSB8fCBubztcbiAgcGxhdGZvcm1NdXN0VXNlUHJvcCA9IG9wdGlvbnMubXVzdFVzZVByb3AgfHwgbm87XG4gIHBsYXRmb3JtSXNQcmVUYWcgPSBvcHRpb25zLmlzUHJlVGFnIHx8IG5vO1xuICBwcmVUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwcmVUcmFuc2Zvcm1Ob2RlJyk7XG4gIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcbiAgcG9zdFRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3Bvc3RUcmFuc2Zvcm1Ob2RlJyk7XG4gIGRlbGltaXRlcnMgPSBvcHRpb25zLmRlbGltaXRlcnM7XG5cbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2UgPSBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSAhPT0gZmFsc2U7XG4gIHZhciByb290O1xuICB2YXIgY3VycmVudFBhcmVudDtcbiAgdmFyIGluVlByZSA9IGZhbHNlO1xuICB2YXIgaW5QcmUgPSBmYWxzZTtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHdhcm5PbmNlIChtc2cpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHdhcm4kMihtc2cpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZFByZSAoZWxlbWVudCkge1xuICAgIC8vIGNoZWNrIHByZSBzdGF0ZVxuICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgaW5WUHJlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgaW5QcmUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwYXJzZUhUTUwodGVtcGxhdGUsIHtcbiAgICB3YXJuOiB3YXJuJDIsXG4gICAgZXhwZWN0SFRNTDogb3B0aW9ucy5leHBlY3RIVE1MLFxuICAgIGlzVW5hcnlUYWc6IG9wdGlvbnMuaXNVbmFyeVRhZyxcbiAgICBjYW5CZUxlZnRPcGVuVGFnOiBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcsXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0ICh0YWcsIGF0dHJzLCB1bmFyeSkge1xuICAgICAgLy8gY2hlY2sgbmFtZXNwYWNlLlxuICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICB2YXIgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xuXG4gICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgYXR0cnMgPSBndWFyZElFU1ZHQnVnKGF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnQgPSB7XG4gICAgICAgIHR5cGU6IDEsXG4gICAgICAgIHRhZzogdGFnLFxuICAgICAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgICAgICBhdHRyc01hcDogbWFrZUF0dHJzTWFwKGF0dHJzKSxcbiAgICAgICAgcGFyZW50OiBjdXJyZW50UGFyZW50LFxuICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgIH07XG4gICAgICBpZiAobnMpIHtcbiAgICAgICAgZWxlbWVudC5ucyA9IG5zO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcbiAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXG4gICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXG4gICAgICAgICAgXCI8XCIgKyB0YWcgKyBcIj5cIiArICcsIGFzIHRoZXkgd2lsbCBub3QgYmUgcGFyc2VkLidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgcHJlLXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcmVUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluVlByZSkge1xuICAgICAgICBwcm9jZXNzUHJlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgICAgICBpblZQcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgaW5QcmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGluVlByZSkge1xuICAgICAgICBwcm9jZXNzUmF3QXR0cnMoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzRm9yKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzSWYoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NPbmNlKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzS2V5KGVsZW1lbnQpO1xuXG4gICAgICAgIC8vIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSBwbGFpbiBlbGVtZW50IGFmdGVyXG4gICAgICAgIC8vIHJlbW92aW5nIHN0cnVjdHVyYWwgYXR0cmlidXRlc1xuICAgICAgICBlbGVtZW50LnBsYWluID0gIWVsZW1lbnQua2V5ICYmICFhdHRycy5sZW5ndGg7XG5cbiAgICAgICAgcHJvY2Vzc1JlZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc1Nsb3QoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NDb21wb25lbnQoZWxlbWVudCk7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgIHRyYW5zZm9ybXNbaSQxXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzQXR0cnMoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrUm9vdENvbnN0cmFpbnRzIChlbCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmIChlbC50YWcgPT09ICdzbG90JyB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICBcIkNhbm5vdCB1c2UgPFwiICsgKGVsLnRhZykgKyBcIj4gYXMgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlIGl0IG1heSBcIiArXG4gICAgICAgICAgICAgICdjb250YWluIG11bHRpcGxlIG5vZGVzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5hdHRyc01hcC5oYXNPd25Qcm9wZXJ0eSgndi1mb3InKSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcbiAgICAgICAgICAgICAgJ2l0IHJlbmRlcnMgbXVsdGlwbGUgZWxlbWVudHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgcm9vdCA9IGVsZW1lbnQ7XG4gICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKHJvb3QpO1xuICAgICAgfSBlbHNlIGlmICghc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIC8vIGFsbG93IHJvb3QgZWxlbWVudHMgd2l0aCB2LWlmLCB2LWVsc2UtaWYgYW5kIHYtZWxzZVxuICAgICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuICAgICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcbiAgICAgICAgICAgIGV4cDogZWxlbWVudC5lbHNlaWYsXG4gICAgICAgICAgICBibG9jazogZWxlbWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgIFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXCIgK1xuICAgICAgICAgICAgXCJJZiB5b3UgYXJlIHVzaW5nIHYtaWYgb24gbXVsdGlwbGUgZWxlbWVudHMsIFwiICtcbiAgICAgICAgICAgIFwidXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFBhcmVudCAmJiAhZWxlbWVudC5mb3JiaWRkZW4pIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkge1xuICAgICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHsgLy8gc2NvcGVkIHNsb3RcbiAgICAgICAgICBjdXJyZW50UGFyZW50LnBsYWluID0gZmFsc2U7XG4gICAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50LnNsb3RUYXJnZXQgfHwgJ1wiZGVmYXVsdFwiJzsoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyB8fCAoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyA9IHt9KSlbbmFtZV0gPSBlbGVtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcbiAgICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdW5hcnkpIHtcbiAgICAgICAgY3VycmVudFBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmRQcmUoZWxlbWVudCk7XG4gICAgICB9XG4gICAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHBvc3RUcmFuc2Zvcm1zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgcG9zdFRyYW5zZm9ybXNbaSQyXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW5kOiBmdW5jdGlvbiBlbmQgKCkge1xuICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICB2YXIgbGFzdE5vZGUgPSBlbGVtZW50LmNoaWxkcmVuW2VsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICBpZiAobGFzdE5vZGUgJiYgbGFzdE5vZGUudHlwZSA9PT0gMyAmJiBsYXN0Tm9kZS50ZXh0ID09PSAnICcgJiYgIWluUHJlKSB7XG4gICAgICAgIGVsZW1lbnQuY2hpbGRyZW4ucG9wKCk7XG4gICAgICB9XG4gICAgICAvLyBwb3Agc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCAtPSAxO1xuICAgICAgY3VycmVudFBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgZW5kUHJlKGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBjaGFyczogZnVuY3Rpb24gY2hhcnMgKHRleHQpIHtcbiAgICAgIGlmICghY3VycmVudFBhcmVudCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDb21wb25lbnQgdGVtcGxhdGUgcmVxdWlyZXMgYSByb290IGVsZW1lbnQsIHJhdGhlciB0aGFuIGp1c3QgdGV4dC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHRleHQgPSB0ZXh0LnRyaW0oKSkpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAoXCJ0ZXh0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyBJRSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiZcbiAgICAgICAgICBjdXJyZW50UGFyZW50LnRhZyA9PT0gJ3RleHRhcmVhJyAmJlxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuYXR0cnNNYXAucGxhY2Vob2xkZXIgPT09IHRleHQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW4gPSBjdXJyZW50UGFyZW50LmNoaWxkcmVuO1xuICAgICAgdGV4dCA9IGluUHJlIHx8IHRleHQudHJpbSgpXG4gICAgICAgID8gZGVjb2RlSFRNTENhY2hlZCh0ZXh0KVxuICAgICAgICAvLyBvbmx5IHByZXNlcnZlIHdoaXRlc3BhY2UgaWYgaXRzIG5vdCByaWdodCBhZnRlciBhIHN0YXJ0aW5nIHRhZ1xuICAgICAgICA6IHByZXNlcnZlV2hpdGVzcGFjZSAmJiBjaGlsZHJlbi5sZW5ndGggPyAnICcgOiAnJztcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uO1xuICAgICAgICBpZiAoIWluVlByZSAmJiB0ZXh0ICE9PSAnICcgJiYgKGV4cHJlc3Npb24gPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbixcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm9vdFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUHJlIChlbCkge1xuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuICAgIGVsLnByZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xuICB2YXIgbCA9IGVsLmF0dHJzTGlzdC5sZW5ndGg7XG4gIGlmIChsKSB7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBlbC5hdHRyc0xpc3RbaV0ubmFtZSxcbiAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGVsLmF0dHJzTGlzdFtpXS52YWx1ZSlcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlbC5wcmUpIHtcbiAgICAvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXG4gICAgZWwucGxhaW4gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xuICBpZiAoZXhwKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICB3YXJuJDIoXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICBlbC5rZXkgPSBleHA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1JlZiAoZWwpIHtcbiAgdmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG4gIGlmIChyZWYpIHtcbiAgICBlbC5yZWYgPSByZWY7XG4gICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRm9yIChlbCkge1xuICB2YXIgZXhwO1xuICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xuICAgIHZhciBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuICAgIGlmICghaW5NYXRjaCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDIoXG4gICAgICAgIChcIkludmFsaWQgdi1mb3IgZXhwcmVzc2lvbjogXCIgKyBleHApXG4gICAgICApO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGVsLmZvciA9IGluTWF0Y2hbMl0udHJpbSgpO1xuICAgIHZhciBhbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpO1xuICAgIHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICAgIGVsLmFsaWFzID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgICBlbC5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICAgIGlmIChpdGVyYXRvck1hdGNoWzNdKSB7XG4gICAgICAgIGVsLml0ZXJhdG9yMiA9IGl0ZXJhdG9yTWF0Y2hbM10udHJpbSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5hbGlhcyA9IGFsaWFzO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWYgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICBpZiAoZXhwKSB7XG4gICAgZWwuaWYgPSBleHA7XG4gICAgYWRkSWZDb25kaXRpb24oZWwsIHtcbiAgICAgIGV4cDogZXhwLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XG4gICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICBpZiAoZWxzZWlmKSB7XG4gICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMgKGVsLCBwYXJlbnQpIHtcbiAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcbiAgaWYgKHByZXYgJiYgcHJldi5pZikge1xuICAgIGFkZElmQ29uZGl0aW9uKHByZXYsIHtcbiAgICAgIGV4cDogZWwuZWxzZWlmLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMihcbiAgICAgIFwidi1cIiArIChlbC5lbHNlaWYgPyAoJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJykgOiAnZWxzZScpICsgXCIgXCIgK1xuICAgICAgXCJ1c2VkIG9uIGVsZW1lbnQgPFwiICsgKGVsLnRhZykgKyBcIj4gd2l0aG91dCBjb3JyZXNwb25kaW5nIHYtaWYuXCJcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRQcmV2RWxlbWVudCAoY2hpbGRyZW4pIHtcbiAgdmFyIGkgPSBjaGlsZHJlbi5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoY2hpbGRyZW5baV0udHlwZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJ0ZXh0IFxcXCJcIiArIChjaGlsZHJlbltpXS50ZXh0LnRyaW0oKSkgKyBcIlxcXCIgYmV0d2VlbiB2LWlmIGFuZCB2LWVsc2UoLWlmKSBcIiArXG4gICAgICAgICAgXCJ3aWxsIGJlIGlnbm9yZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuLnBvcCgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRJZkNvbmRpdGlvbiAoZWwsIGNvbmRpdGlvbikge1xuICBpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xuICAgIGVsLmlmQ29uZGl0aW9ucyA9IFtdO1xuICB9XG4gIGVsLmlmQ29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NPbmNlIChlbCkge1xuICB2YXIgb25jZSQkMSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LW9uY2UnKTtcbiAgaWYgKG9uY2UkJDEgIT0gbnVsbCkge1xuICAgIGVsLm9uY2UgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NTbG90IChlbCkge1xuICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICBlbC5zbG90TmFtZSA9IGdldEJpbmRpbmdBdHRyKGVsLCAnbmFtZScpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmtleSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcImBrZXlgIGRvZXMgbm90IHdvcmsgb24gPHNsb3Q+IGJlY2F1c2Ugc2xvdHMgYXJlIGFic3RyYWN0IG91dGxldHMgXCIgK1xuICAgICAgICBcImFuZCBjYW4gcG9zc2libHkgZXhwYW5kIGludG8gbXVsdGlwbGUgZWxlbWVudHMuIFwiICtcbiAgICAgICAgXCJVc2UgdGhlIGtleSBvbiBhIHdyYXBwaW5nIGVsZW1lbnQgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsb3RUYXJnZXQgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKTtcbiAgICBpZiAoc2xvdFRhcmdldCkge1xuICAgICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xuICAgIH1cbiAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICBlbC5zbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2NvcGUnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudCAoZWwpIHtcbiAgdmFyIGJpbmRpbmc7XG4gIGlmICgoYmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnaXMnKSkpIHtcbiAgICBlbC5jb21wb25lbnQgPSBiaW5kaW5nO1xuICB9XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAnaW5saW5lLXRlbXBsYXRlJykgIT0gbnVsbCkge1xuICAgIGVsLmlubGluZVRlbXBsYXRlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQXR0cnMgKGVsKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICB2YXIgaSwgbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIG1vZGlmaWVycywgaXNQcm9wO1xuICBmb3IgKGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBuYW1lID0gcmF3TmFtZSA9IGxpc3RbaV0ubmFtZTtcbiAgICB2YWx1ZSA9IGxpc3RbaV0udmFsdWU7XG4gICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIG1hcmsgZWxlbWVudCBhcyBkeW5hbWljXG4gICAgICBlbC5oYXNCaW5kaW5ncyA9IHRydWU7XG4gICAgICAvLyBtb2RpZmllcnNcbiAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUpO1xuICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkgeyAvLyB2LWJpbmRcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICBpc1Byb3AgPSBmYWxzZTtcbiAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMucHJvcCkge1xuICAgICAgICAgICAgaXNQcm9wID0gdHJ1ZTtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnaW5uZXJIdG1sJykgeyBuYW1lID0gJ2lubmVySFRNTCc7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5jYW1lbCkge1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcm9wIHx8IHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKSkge1xuICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRBdHRyKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7IC8vIHYtb25cbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShvblJFLCAnJyk7XG4gICAgICAgIGFkZEhhbmRsZXIoZWwsIG5hbWUsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xuICAgICAgICAvLyBwYXJzZSBhcmdcbiAgICAgICAgdmFyIGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XG4gICAgICAgIHZhciBhcmcgPSBhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXTtcbiAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0oYXJnLmxlbmd0aCArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUgPT09ICdtb2RlbCcpIHtcbiAgICAgICAgICBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsaXRlcmFsIGF0dHJpYnV0ZVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQodmFsdWUsIGRlbGltaXRlcnMpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWRkQXR0cihlbCwgbmFtZSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbkZvciAoZWwpIHtcbiAgdmFyIHBhcmVudCA9IGVsO1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC5mb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcbiAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIG1hdGNoLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VBdHRyc01hcCAoYXR0cnMpIHtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSkge1xuICAgICAgd2FybiQyKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSk7XG4gICAgfVxuICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xuICB9XG4gIHJldHVybiBtYXBcbn1cblxuZnVuY3Rpb24gaXNGb3JiaWRkZW5UYWcgKGVsKSB7XG4gIHJldHVybiAoXG4gICAgZWwudGFnID09PSAnc3R5bGUnIHx8XG4gICAgKGVsLnRhZyA9PT0gJ3NjcmlwdCcgJiYgKFxuICAgICAgIWVsLmF0dHJzTWFwLnR5cGUgfHxcbiAgICAgIGVsLmF0dHJzTWFwLnR5cGUgPT09ICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgKSlcbiAgKVxufVxuXG52YXIgaWVOU0J1ZyA9IC9eeG1sbnM6TlNcXGQrLztcbnZhciBpZU5TUHJlZml4ID0gL15OU1xcZCs6LztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGd1YXJkSUVTVkdCdWcgKGF0dHJzKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhdHRyID0gYXR0cnNbaV07XG4gICAgaWYgKCFpZU5TQnVnLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgYXR0ci5uYW1lID0gYXR0ci5uYW1lLnJlcGxhY2UoaWVOU1ByZWZpeCwgJycpO1xuICAgICAgcmVzLnB1c2goYXR0cik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3JBbGlhc01vZGVsIChlbCwgdmFsdWUpIHtcbiAgdmFyIF9lbCA9IGVsO1xuICB3aGlsZSAoX2VsKSB7XG4gICAgaWYgKF9lbC5mb3IgJiYgX2VsLmFsaWFzID09PSB2YWx1ZSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgICAgXCJZb3UgYXJlIGJpbmRpbmcgdi1tb2RlbCBkaXJlY3RseSB0byBhIHYtZm9yIGl0ZXJhdGlvbiBhbGlhcy4gXCIgK1xuICAgICAgICBcIlRoaXMgd2lsbCBub3QgYmUgYWJsZSB0byBtb2RpZnkgdGhlIHYtZm9yIHNvdXJjZSBhcnJheSBiZWNhdXNlIFwiICtcbiAgICAgICAgXCJ3cml0aW5nIHRvIHRoZSBhbGlhcyBpcyBsaWtlIG1vZGlmeWluZyBhIGZ1bmN0aW9uIGxvY2FsIHZhcmlhYmxlLiBcIiArXG4gICAgICAgIFwiQ29uc2lkZXIgdXNpbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgdXNlIHYtbW9kZWwgb24gYW4gb2JqZWN0IHByb3BlcnR5IGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIF9lbCA9IF9lbC5wYXJlbnQ7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBpc1N0YXRpY0tleTtcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWc7XG5cbnZhciBnZW5TdGF0aWNLZXlzQ2FjaGVkID0gY2FjaGVkKGdlblN0YXRpY0tleXMkMSk7XG5cbi8qKlxuICogR29hbCBvZiB0aGUgb3B0aW1pemVyOiB3YWxrIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgQVNUIHRyZWVcbiAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2ZcbiAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG4gKlxuICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XG4gKlxuICogMS4gSG9pc3QgdGhlbSBpbnRvIGNvbnN0YW50cywgc28gdGhhdCB3ZSBubyBsb25nZXIgbmVlZCB0b1xuICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xuICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG4gKi9cbmZ1bmN0aW9uIG9wdGltaXplIChyb290LCBvcHRpb25zKSB7XG4gIGlmICghcm9vdCkgeyByZXR1cm4gfVxuICBpc1N0YXRpY0tleSA9IGdlblN0YXRpY0tleXNDYWNoZWQob3B0aW9ucy5zdGF0aWNLZXlzIHx8ICcnKTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICBtYXJrU3RhdGljJDEocm9vdCk7XG4gIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cbiAgbWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyQxIChrZXlzKSB7XG4gIHJldHVybiBtYWtlTWFwKFxuICAgICd0eXBlLHRhZyxhdHRyc0xpc3QsYXR0cnNNYXAscGxhaW4scGFyZW50LGNoaWxkcmVuLGF0dHJzJyArXG4gICAgKGtleXMgPyAnLCcgKyBrZXlzIDogJycpXG4gIClcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyQxIChub2RlKSB7XG4gIG5vZGUuc3RhdGljID0gaXNTdGF0aWMobm9kZSk7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAvLyBkbyBub3QgbWFrZSBjb21wb25lbnQgc2xvdCBjb250ZW50IHN0YXRpYy4gdGhpcyBhdm9pZHNcbiAgICAvLyAxLiBjb21wb25lbnRzIG5vdCBhYmxlIHRvIG11dGF0ZSBzbG90IG5vZGVzXG4gICAgLy8gMi4gc3RhdGljIHNsb3QgY29udGVudCBmYWlscyBmb3IgaG90LXJlbG9hZGluZ1xuICAgIGlmIChcbiAgICAgICFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmXG4gICAgICBub2RlLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgICBub2RlLmF0dHJzTWFwWydpbmxpbmUtdGVtcGxhdGUnXSA9PSBudWxsXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIG1hcmtTdGF0aWMkMShjaGlsZCk7XG4gICAgICBpZiAoIWNoaWxkLnN0YXRpYykge1xuICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcbiAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xuICAgIH1cbiAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXG4gICAgLy8gb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIGFuZCBpdCdzIGJldHRlciBvZmYgdG8ganVzdCBhbHdheXMgcmVuZGVyIGl0IGZyZXNoLlxuICAgIGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKFxuICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gM1xuICAgICkpIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCBpc0luRm9yIHx8ICEhbm9kZS5mb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIHdhbGtUaHJvdWdoQ29uZGl0aW9uc0Jsb2Nrcyhub2RlLmlmQ29uZGl0aW9ucywgaXNJbkZvcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhbGtUaHJvdWdoQ29uZGl0aW9uc0Jsb2NrcyAoY29uZGl0aW9uQmxvY2tzLCBpc0luRm9yKSB7XG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSBjb25kaXRpb25CbG9ja3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBtYXJrU3RhdGljUm9vdHMoY29uZGl0aW9uQmxvY2tzW2ldLmJsb2NrLCBpc0luRm9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N0YXRpYyAobm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSAyKSB7IC8vIGV4cHJlc3Npb25cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAzKSB7IC8vIHRleHRcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiAhIShub2RlLnByZSB8fCAoXG4gICAgIW5vZGUuaGFzQmluZGluZ3MgJiYgLy8gbm8gZHluYW1pYyBiaW5kaW5nc1xuICAgICFub2RlLmlmICYmICFub2RlLmZvciAmJiAvLyBub3Qgdi1pZiBvciB2LWZvciBvciB2LWVsc2VcbiAgICAhaXNCdWlsdEluVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBidWlsdC1pblxuICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgY29tcG9uZW50XG4gICAgIWlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yKG5vZGUpICYmXG4gICAgT2JqZWN0LmtleXMobm9kZSkuZXZlcnkoaXNTdGF0aWNLZXkpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIChub2RlKSB7XG4gIHdoaWxlIChub2RlLnBhcmVudCkge1xuICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICBpZiAobm9kZS50YWcgIT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAobm9kZS5mb3IpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxudmFyIGZuRXhwUkUgPSAvXlxccyooW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeZnVuY3Rpb25cXHMqXFwoLztcbnZhciBzaW1wbGVQYXRoUkUgPSAvXlxccypbQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWycuKj8nXXxcXFtcIi4qP1wiXXxcXFtcXGQrXXxcXFtbQS1aYS16XyRdW1xcdyRdKl0pKlxccyokLztcblxuLy8ga2V5Q29kZSBhbGlhc2VzXG52YXIga2V5Q29kZXMgPSB7XG4gIGVzYzogMjcsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzcGFjZTogMzIsXG4gIHVwOiAzOCxcbiAgbGVmdDogMzcsXG4gIHJpZ2h0OiAzOSxcbiAgZG93bjogNDAsXG4gICdkZWxldGUnOiBbOCwgNDZdXG59O1xuXG4vLyAjNDg2ODogbW9kaWZpZXJzIHRoYXQgcHJldmVudCB0aGUgZXhlY3V0aW9uIG9mIHRoZSBsaXN0ZW5lclxuLy8gbmVlZCB0byBleHBsaWNpdGx5IHJldHVybiBudWxsIHNvIHRoYXQgd2UgY2FuIGRldGVybWluZSB3aGV0aGVyIHRvIHJlbW92ZVxuLy8gdGhlIGxpc3RlbmVyIGZvciAub25jZVxudmFyIGdlbkd1YXJkID0gZnVuY3Rpb24gKGNvbmRpdGlvbikgeyByZXR1cm4gKFwiaWYoXCIgKyBjb25kaXRpb24gKyBcIilyZXR1cm4gbnVsbDtcIik7IH07XG5cbnZhciBtb2RpZmllckNvZGUgPSB7XG4gIHN0b3A6ICckZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7JyxcbiAgcHJldmVudDogJyRldmVudC5wcmV2ZW50RGVmYXVsdCgpOycsXG4gIHNlbGY6IGdlbkd1YXJkKFwiJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXRcIiksXG4gIGN0cmw6IGdlbkd1YXJkKFwiISRldmVudC5jdHJsS2V5XCIpLFxuICBzaGlmdDogZ2VuR3VhcmQoXCIhJGV2ZW50LnNoaWZ0S2V5XCIpLFxuICBhbHQ6IGdlbkd1YXJkKFwiISRldmVudC5hbHRLZXlcIiksXG4gIG1ldGE6IGdlbkd1YXJkKFwiISRldmVudC5tZXRhS2V5XCIpLFxuICBsZWZ0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAwXCIpLFxuICBtaWRkbGU6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDFcIiksXG4gIHJpZ2h0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAyXCIpXG59O1xuXG5mdW5jdGlvbiBnZW5IYW5kbGVycyAoZXZlbnRzLCBuYXRpdmUpIHtcbiAgdmFyIHJlcyA9IG5hdGl2ZSA/ICduYXRpdmVPbjp7JyA6ICdvbjp7JztcbiAgZm9yICh2YXIgbmFtZSBpbiBldmVudHMpIHtcbiAgICByZXMgKz0gXCJcXFwiXCIgKyBuYW1lICsgXCJcXFwiOlwiICsgKGdlbkhhbmRsZXIobmFtZSwgZXZlbnRzW25hbWVdKSkgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICd9J1xufVxuXG5mdW5jdGlvbiBnZW5IYW5kbGVyIChcbiAgbmFtZSxcbiAgaGFuZGxlclxuKSB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICByZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKG5hbWUsIGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXG4gIH1cblxuICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIHZhciBpc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcblxuICBpZiAoIWhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgcmV0dXJuIGlzTWV0aG9kUGF0aCB8fCBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgPyBoYW5kbGVyLnZhbHVlXG4gICAgICA6IChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIn1cIikgLy8gaW5saW5lIHN0YXRlbWVudFxuICB9IGVsc2Uge1xuICAgIHZhciBjb2RlID0gJyc7XG4gICAgdmFyIGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIGhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgICBpZiAobW9kaWZpZXJDb2RlW2tleV0pIHtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IG1vZGlmaWVyQ29kZVtrZXldO1xuICAgICAgICAvLyBsZWZ0L3JpZ2h0XG4gICAgICAgIGlmIChrZXlDb2Rlc1trZXldKSB7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGNvZGUgKz0gZ2VuS2V5RmlsdGVyKGtleXMpO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xuICAgIGlmIChnZW5Nb2RpZmllckNvZGUpIHtcbiAgICAgIGNvZGUgKz0gZ2VuTW9kaWZpZXJDb2RlO1xuICAgIH1cbiAgICB2YXIgaGFuZGxlckNvZGUgPSBpc01ldGhvZFBhdGhcbiAgICAgID8gaGFuZGxlci52YWx1ZSArICcoJGV2ZW50KSdcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgPyAoXCIoXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIikoJGV2ZW50KVwiKVxuICAgICAgICA6IGhhbmRsZXIudmFsdWU7XG4gICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyBjb2RlICsgaGFuZGxlckNvZGUgKyBcIn1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5LZXlGaWx0ZXIgKGtleXMpIHtcbiAgcmV0dXJuIChcImlmKCEoJ2J1dHRvbicgaW4gJGV2ZW50KSYmXCIgKyAoa2V5cy5tYXAoZ2VuRmlsdGVyQ29kZSkuam9pbignJiYnKSkgKyBcIilyZXR1cm4gbnVsbDtcIilcbn1cblxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG4gIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcbiAgaWYgKGtleVZhbCkge1xuICAgIHJldHVybiAoXCIkZXZlbnQua2V5Q29kZSE9PVwiICsga2V5VmFsKVxuICB9XG4gIHZhciBhbGlhcyA9IGtleUNvZGVzW2tleV07XG4gIHJldHVybiAoXCJfaygkZXZlbnQua2V5Q29kZSxcIiArIChKU09OLnN0cmluZ2lmeShrZXkpKSArIChhbGlhcyA/ICcsJyArIEpTT04uc3RyaW5naWZ5KGFsaWFzKSA6ICcnKSArIFwiKVwiKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZCQxIChlbCwgZGlyKSB7XG4gIGVsLndyYXBEYXRhID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICByZXR1cm4gKFwiX2IoXCIgKyBjb2RlICsgXCIsJ1wiICsgKGVsLnRhZykgKyBcIicsXCIgKyAoZGlyLnZhbHVlKSArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMucHJvcCA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBiYXNlRGlyZWN0aXZlcyA9IHtcbiAgYmluZDogYmluZCQxLFxuICBjbG9hazogbm9vcFxufTtcblxuLyogICovXG5cbi8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxudmFyIHdhcm4kMztcbnZhciB0cmFuc2Zvcm1zJDE7XG52YXIgZGF0YUdlbkZucztcbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMkMTtcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWckMTtcbnZhciBzdGF0aWNSZW5kZXJGbnM7XG52YXIgb25jZUNvdW50O1xudmFyIGN1cnJlbnRPcHRpb25zO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZSAoXG4gIGFzdCxcbiAgb3B0aW9uc1xuKSB7XG4gIC8vIHNhdmUgcHJldmlvdXMgc3RhdGljUmVuZGVyRm5zIHNvIGdlbmVyYXRlIGNhbGxzIGNhbiBiZSBuZXN0ZWRcbiAgdmFyIHByZXZTdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG4gIHZhciBjdXJyZW50U3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zID0gW107XG4gIHZhciBwcmV2T25jZUNvdW50ID0gb25jZUNvdW50O1xuICBvbmNlQ291bnQgPSAwO1xuICBjdXJyZW50T3B0aW9ucyA9IG9wdGlvbnM7XG4gIHdhcm4kMyA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdHJhbnNmb3JtcyQxID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Db2RlJyk7XG4gIGRhdGFHZW5GbnMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ2dlbkRhdGEnKTtcbiAgcGxhdGZvcm1EaXJlY3RpdmVzJDEgPSBvcHRpb25zLmRpcmVjdGl2ZXMgfHwge307XG4gIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyQxID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICB2YXIgY29kZSA9IGFzdCA/IGdlbkVsZW1lbnQoYXN0KSA6ICdfYyhcImRpdlwiKSc7XG4gIHN0YXRpY1JlbmRlckZucyA9IHByZXZTdGF0aWNSZW5kZXJGbnM7XG4gIG9uY2VDb3VudCA9IHByZXZPbmNlQ291bnQ7XG4gIHJldHVybiB7XG4gICAgcmVuZGVyOiAoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIGNvZGUgKyBcIn1cIiksXG4gICAgc3RhdGljUmVuZGVyRm5zOiBjdXJyZW50U3RhdGljUmVuZGVyRm5zXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRWxlbWVudCAoZWwpIHtcbiAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwpXG4gIH0gZWxzZSBpZiAoZWwub25jZSAmJiAhZWwub25jZVByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5PbmNlKGVsKVxuICB9IGVsc2UgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvcihlbClcbiAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwpXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnICYmICFlbC5zbG90VGFyZ2V0KSB7XG4gICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsKSB8fCAndm9pZCAwJ1xuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgcmV0dXJuIGdlblNsb3QoZWwpXG4gIH0gZWxzZSB7XG4gICAgLy8gY29tcG9uZW50IG9yIGVsZW1lbnRcbiAgICB2YXIgY29kZTtcbiAgICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgICBjb2RlID0gZ2VuQ29tcG9uZW50KGVsLmNvbXBvbmVudCwgZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YSA9IGVsLnBsYWluID8gdW5kZWZpbmVkIDogZ2VuRGF0YShlbCk7XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCB0cnVlKTtcbiAgICAgIGNvZGUgPSBcIl9jKCdcIiArIChlbC50YWcpICsgXCInXCIgKyAoZGF0YSA/IChcIixcIiArIGRhdGEpIDogJycpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCI7XG4gICAgfVxuICAgIC8vIG1vZHVsZSB0cmFuc2Zvcm1zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zJDEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvZGUgPSB0cmFuc2Zvcm1zJDFbaV0oZWwsIGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9XG59XG5cbi8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XG5mdW5jdGlvbiBnZW5TdGF0aWMgKGVsKSB7XG4gIGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XG4gIHN0YXRpY1JlbmRlckZucy5wdXNoKChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgKGdlbkVsZW1lbnQoZWwpKSArIFwifVwiKSk7XG4gIHJldHVybiAoXCJfbShcIiArIChzdGF0aWNSZW5kZXJGbnMubGVuZ3RoIC0gMSkgKyAoZWwuc3RhdGljSW5Gb3IgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG59XG5cbi8vIHYtb25jZVxuZnVuY3Rpb24gZ2VuT25jZSAoZWwpIHtcbiAgZWwub25jZVByb2Nlc3NlZCA9IHRydWU7XG4gIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwpXG4gIH0gZWxzZSBpZiAoZWwuc3RhdGljSW5Gb3IpIHtcbiAgICB2YXIga2V5ID0gJyc7XG4gICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LmZvcikge1xuICAgICAgICBrZXkgPSBwYXJlbnQua2V5O1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQzKFxuICAgICAgICBcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBnZW5FbGVtZW50KGVsKVxuICAgIH1cbiAgICByZXR1cm4gKFwiX28oXCIgKyAoZ2VuRWxlbWVudChlbCkpICsgXCIsXCIgKyAob25jZUNvdW50KyspICsgKGtleSA/IChcIixcIiArIGtleSkgOiBcIlwiKSArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSWYgKGVsKSB7XG4gIGVsLmlmUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiBnZW5JZkNvbmRpdGlvbnMoZWwuaWZDb25kaXRpb25zLnNsaWNlKCkpXG59XG5cbmZ1bmN0aW9uIGdlbklmQ29uZGl0aW9ucyAoY29uZGl0aW9ucykge1xuICBpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICdfZSgpJ1xuICB9XG5cbiAgdmFyIGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcbiAgaWYgKGNvbmRpdGlvbi5leHApIHtcbiAgICByZXR1cm4gKFwiKFwiICsgKGNvbmRpdGlvbi5leHApICsgXCIpP1wiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcIjpcIiArIChnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucykpKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXCJcIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpKVxuICB9XG5cbiAgLy8gdi1pZiB3aXRoIHYtb25jZSBzaG91bGQgZ2VuZXJhdGUgY29kZSBsaWtlIChhKT9fbSgwKTpfbSgxKVxuICBmdW5jdGlvbiBnZW5UZXJuYXJ5RXhwIChlbCkge1xuICAgIHJldHVybiBlbC5vbmNlID8gZ2VuT25jZShlbCkgOiBnZW5FbGVtZW50KGVsKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkZvciAoZWwpIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuXG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgbWF5YmVDb21wb25lbnQoZWwpICYmIGVsLnRhZyAhPT0gJ3Nsb3QnICYmIGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJiAhZWwua2V5XG4gICkge1xuICAgIHdhcm4kMyhcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LWZvcj1cXFwiXCIgKyBhbGlhcyArIFwiIGluIFwiICsgZXhwICsgXCJcXFwiPjogY29tcG9uZW50IGxpc3RzIHJlbmRlcmVkIHdpdGggXCIgK1xuICAgICAgXCJ2LWZvciBzaG91bGQgaGF2ZSBleHBsaWNpdCBrZXlzLiBcIiArXG4gICAgICBcIlNlZSBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9saXN0Lmh0bWwja2V5IGZvciBtb3JlIGluZm8uXCIsXG4gICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICk7XG4gIH1cblxuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIFwiX2woKFwiICsgZXhwICsgXCIpLFwiICtcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEgKGVsKSB7XG4gIHZhciBkYXRhID0gJ3snO1xuXG4gIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXG4gIC8vIGRpcmVjdGl2ZXMgbWF5IG11dGF0ZSB0aGUgZWwncyBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aGV5IGFyZSBnZW5lcmF0ZWQuXG4gIHZhciBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCk7XG4gIGlmIChkaXJzKSB7IGRhdGEgKz0gZGlycyArICcsJzsgfVxuXG4gIC8vIGtleVxuICBpZiAoZWwua2V5KSB7XG4gICAgZGF0YSArPSBcImtleTpcIiArIChlbC5rZXkpICsgXCIsXCI7XG4gIH1cbiAgLy8gcmVmXG4gIGlmIChlbC5yZWYpIHtcbiAgICBkYXRhICs9IFwicmVmOlwiICsgKGVsLnJlZikgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwucmVmSW5Gb3IpIHtcbiAgICBkYXRhICs9IFwicmVmSW5Gb3I6dHJ1ZSxcIjtcbiAgfVxuICAvLyBwcmVcbiAgaWYgKGVsLnByZSkge1xuICAgIGRhdGEgKz0gXCJwcmU6dHJ1ZSxcIjtcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgdGFnIG5hbWUgZm9yIGNvbXBvbmVudHMgdXNpbmcgXCJpc1wiIGF0dHJpYnV0ZVxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZGF0YSArPSBcInRhZzpcXFwiXCIgKyAoZWwudGFnKSArIFwiXFxcIixcIjtcbiAgfVxuICAvLyBtb2R1bGUgZGF0YSBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFHZW5GbnMubGVuZ3RoOyBpKyspIHtcbiAgICBkYXRhICs9IGRhdGFHZW5GbnNbaV0oZWwpO1xuICB9XG4gIC8vIGF0dHJpYnV0ZXNcbiAgaWYgKGVsLmF0dHJzKSB7XG4gICAgZGF0YSArPSBcImF0dHJzOntcIiArIChnZW5Qcm9wcyhlbC5hdHRycykpICsgXCJ9LFwiO1xuICB9XG4gIC8vIERPTSBwcm9wc1xuICBpZiAoZWwucHJvcHMpIHtcbiAgICBkYXRhICs9IFwiZG9tUHJvcHM6e1wiICsgKGdlblByb3BzKGVsLnByb3BzKSkgKyBcIn0sXCI7XG4gIH1cbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGVsLmV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLmV2ZW50cykpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLm5hdGl2ZUV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLm5hdGl2ZUV2ZW50cywgdHJ1ZSkpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2xvdCB0YXJnZXRcbiAgaWYgKGVsLnNsb3RUYXJnZXQpIHtcbiAgICBkYXRhICs9IFwic2xvdDpcIiArIChlbC5zbG90VGFyZ2V0KSArIFwiLFwiO1xuICB9XG4gIC8vIHNjb3BlZCBzbG90c1xuICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICBkYXRhICs9IChnZW5TY29wZWRTbG90cyhlbC5zY29wZWRTbG90cykpICsgXCIsXCI7XG4gIH1cbiAgLy8gY29tcG9uZW50IHYtbW9kZWxcbiAgaWYgKGVsLm1vZGVsKSB7XG4gICAgZGF0YSArPSBcIm1vZGVsOnt2YWx1ZTpcIiArIChlbC5tb2RlbC52YWx1ZSkgKyBcIixjYWxsYmFjazpcIiArIChlbC5tb2RlbC5jYWxsYmFjaykgKyBcIixleHByZXNzaW9uOlwiICsgKGVsLm1vZGVsLmV4cHJlc3Npb24pICsgXCJ9LFwiO1xuICB9XG4gIC8vIGlubGluZS10ZW1wbGF0ZVxuICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcbiAgICB2YXIgaW5saW5lVGVtcGxhdGUgPSBnZW5JbmxpbmVUZW1wbGF0ZShlbCk7XG4gICAgaWYgKGlubGluZVRlbXBsYXRlKSB7XG4gICAgICBkYXRhICs9IGlubGluZVRlbXBsYXRlICsgXCIsXCI7XG4gICAgfVxuICB9XG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UoLywkLywgJycpICsgJ30nO1xuICAvLyB2LWJpbmQgZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwRGF0YSkge1xuICAgIGRhdGEgPSBlbC53cmFwRGF0YShkYXRhKTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBnZW5EaXJlY3RpdmVzIChlbCkge1xuICB2YXIgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XG4gIGlmICghZGlycykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XG4gIHZhciBoYXNSdW50aW1lID0gZmFsc2U7XG4gIHZhciBpLCBsLCBkaXIsIG5lZWRSdW50aW1lO1xuICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcbiAgICB2YXIgZ2VuID0gcGxhdGZvcm1EaXJlY3RpdmVzJDFbZGlyLm5hbWVdIHx8IGJhc2VEaXJlY3RpdmVzW2Rpci5uYW1lXTtcbiAgICBpZiAoZ2VuKSB7XG4gICAgICAvLyBjb21waWxlLXRpbWUgZGlyZWN0aXZlIHRoYXQgbWFuaXB1bGF0ZXMgQVNULlxuICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIGl0IGFsc28gbmVlZHMgYSBydW50aW1lIGNvdW50ZXJwYXJ0LlxuICAgICAgbmVlZFJ1bnRpbWUgPSAhIWdlbihlbCwgZGlyLCB3YXJuJDMpO1xuICAgIH1cbiAgICBpZiAobmVlZFJ1bnRpbWUpIHtcbiAgICAgIGhhc1J1bnRpbWUgPSB0cnVlO1xuICAgICAgcmVzICs9IFwie25hbWU6XFxcIlwiICsgKGRpci5uYW1lKSArIFwiXFxcIixyYXdOYW1lOlxcXCJcIiArIChkaXIucmF3TmFtZSkgKyBcIlxcXCJcIiArIChkaXIudmFsdWUgPyAoXCIsdmFsdWU6KFwiICsgKGRpci52YWx1ZSkgKyBcIiksZXhwcmVzc2lvbjpcIiArIChKU09OLnN0cmluZ2lmeShkaXIudmFsdWUpKSkgOiAnJykgKyAoZGlyLmFyZyA/IChcIixhcmc6XFxcIlwiICsgKGRpci5hcmcpICsgXCJcXFwiXCIpIDogJycpICsgKGRpci5tb2RpZmllcnMgPyAoXCIsbW9kaWZpZXJzOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpKSkgOiAnJykgKyBcIn0sXCI7XG4gICAgfVxuICB9XG4gIGlmIChoYXNSdW50aW1lKSB7XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwpIHtcbiAgdmFyIGFzdCA9IGVsLmNoaWxkcmVuWzBdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAoXG4gICAgZWwuY2hpbGRyZW4ubGVuZ3RoID4gMSB8fCBhc3QudHlwZSAhPT0gMVxuICApKSB7XG4gICAgd2FybiQzKCdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nKTtcbiAgfVxuICBpZiAoYXN0LnR5cGUgPT09IDEpIHtcbiAgICB2YXIgaW5saW5lUmVuZGVyRm5zID0gZ2VuZXJhdGUoYXN0LCBjdXJyZW50T3B0aW9ucyk7XG4gICAgcmV0dXJuIChcImlubGluZVRlbXBsYXRlOntyZW5kZXI6ZnVuY3Rpb24oKXtcIiArIChpbmxpbmVSZW5kZXJGbnMucmVuZGVyKSArIFwifSxzdGF0aWNSZW5kZXJGbnM6W1wiICsgKGlubGluZVJlbmRlckZucy5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJmdW5jdGlvbigpe1wiICsgY29kZSArIFwifVwiKTsgfSkuam9pbignLCcpKSArIFwiXX1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90cyAoc2xvdHMpIHtcbiAgcmV0dXJuIChcInNjb3BlZFNsb3RzOl91KFtcIiArIChPYmplY3Qua2V5cyhzbG90cykubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGdlblNjb3BlZFNsb3Qoa2V5LCBzbG90c1trZXldKTsgfSkuam9pbignLCcpKSArIFwiXSlcIilcbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdCAoa2V5LCBlbCkge1xuICByZXR1cm4gXCJbXCIgKyBrZXkgKyBcIixmdW5jdGlvbihcIiArIChTdHJpbmcoZWwuYXR0cnNNYXAuc2NvcGUpKSArIFwiKXtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAoZWwudGFnID09PSAndGVtcGxhdGUnXG4gICAgICA/IGdlbkNoaWxkcmVuKGVsKSB8fCAndm9pZCAwJ1xuICAgICAgOiBnZW5FbGVtZW50KGVsKSkgKyBcIn1dXCJcbn1cblxuZnVuY3Rpb24gZ2VuQ2hpbGRyZW4gKGVsLCBjaGVja1NraXApIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB2YXIgZWwkMSA9IGNoaWxkcmVuWzBdO1xuICAgIC8vIG9wdGltaXplIHNpbmdsZSB2LWZvclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgZWwkMS5mb3IgJiZcbiAgICAgICAgZWwkMS50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAgICAgZWwkMS50YWcgIT09ICdzbG90Jykge1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwkMSlcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4pIDogMDtcbiAgICByZXR1cm4gKFwiW1wiICsgKGNoaWxkcmVuLm1hcChnZW5Ob2RlKS5qb2luKCcsJykpICsgXCJdXCIgKyAobm9ybWFsaXphdGlvblR5cGUgPyAoXCIsXCIgKyBub3JtYWxpemF0aW9uVHlwZSkgOiAnJykpXG4gIH1cbn1cblxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxuLy8gMDogbm8gbm9ybWFsaXphdGlvbiBuZWVkZWRcbi8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25UeXBlIChjaGlsZHJlbikge1xuICB2YXIgcmVzID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChlbC50eXBlICE9PSAxKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAobmVlZHNOb3JtYWxpemF0aW9uKGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBuZWVkc05vcm1hbGl6YXRpb24oYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChtYXliZUNvbXBvbmVudChlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbWF5YmVDb21wb25lbnQoYy5ibG9jayk7IH0pKSkge1xuICAgICAgcmVzID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBuZWVkc05vcm1hbGl6YXRpb24gKGVsKSB7XG4gIHJldHVybiBlbC5mb3IgIT09IHVuZGVmaW5lZCB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScgfHwgZWwudGFnID09PSAnc2xvdCdcbn1cblxuZnVuY3Rpb24gbWF5YmVDb21wb25lbnQgKGVsKSB7XG4gIHJldHVybiAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnJDEoZWwudGFnKVxufVxuXG5mdW5jdGlvbiBnZW5Ob2RlIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xuICByZXR1cm4gKFwiX3YoXCIgKyAodGV4dC50eXBlID09PSAyXG4gICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TbG90IChlbCkge1xuICB2YXIgc2xvdE5hbWUgPSBlbC5zbG90TmFtZSB8fCAnXCJkZWZhdWx0XCInO1xuICB2YXIgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCk7XG4gIHZhciByZXMgPSBcIl90KFwiICsgc2xvdE5hbWUgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJyk7XG4gIHZhciBhdHRycyA9IGVsLmF0dHJzICYmIChcIntcIiArIChlbC5hdHRycy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuICgoY2FtZWxpemUoYS5uYW1lKSkgKyBcIjpcIiArIChhLnZhbHVlKSk7IH0pLmpvaW4oJywnKSkgKyBcIn1cIik7XG4gIHZhciBiaW5kJCQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xuICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xuICAgIHJlcyArPSBcIixudWxsXCI7XG4gIH1cbiAgaWYgKGF0dHJzKSB7XG4gICAgcmVzICs9IFwiLFwiICsgYXR0cnM7XG4gIH1cbiAgaWYgKGJpbmQkJDEpIHtcbiAgICByZXMgKz0gKGF0dHJzID8gJycgOiAnLG51bGwnKSArIFwiLFwiICsgYmluZCQkMTtcbiAgfVxuICByZXR1cm4gcmVzICsgJyknXG59XG5cbi8vIGNvbXBvbmVudE5hbWUgaXMgZWwuY29tcG9uZW50LCB0YWtlIGl0IGFzIGFyZ3VtZW50IHRvIHNodW4gZmxvdydzIHBlc3NpbWlzdGljIHJlZmluZW1lbnRcbmZ1bmN0aW9uIGdlbkNvbXBvbmVudCAoY29tcG9uZW50TmFtZSwgZWwpIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHRydWUpO1xuICByZXR1cm4gKFwiX2MoXCIgKyBjb21wb25lbnROYW1lICsgXCIsXCIgKyAoZ2VuRGF0YShlbCkpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblByb3BzIChwcm9wcykge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgIHJlcyArPSBcIlxcXCJcIiArIChwcm9wLm5hbWUpICsgXCJcXFwiOlwiICsgKHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKSkgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxufVxuXG4vLyAjMzg5NSwgIzQyNjhcbmZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyAodGV4dCkge1xuICByZXR1cm4gdGV4dFxuICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKVxuICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKVxufVxuXG4vKiAgKi9cblxuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2Vcbi8vIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcbnZhciBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcbiAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcbiAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXGJ8XFxcXGInKSArICdcXFxcYicpO1xuXG4vLyB0aGVzZSB1bmFyeSBvcGVyYXRvcnMgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5L21ldGhvZCBuYW1lc1xudmFyIHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkZWxldGUsdHlwZW9mLHZvaWQnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcblxuLy8gY2hlY2sgdmFsaWQgaWRlbnRpZmllciBmb3Igdi1mb3JcbnZhciBpZGVudFJFID0gL1tBLVphLXpfJF1bXFx3JF0qLztcblxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xudmFyIHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcblxuLy8gZGV0ZWN0IHByb2JsZW1hdGljIGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGVcbmZ1bmN0aW9uIGRldGVjdEVycm9ycyAoYXN0KSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYgKGFzdCkge1xuICAgIGNoZWNrTm9kZShhc3QsIGVycm9ycyk7XG4gIH1cbiAgcmV0dXJuIGVycm9yc1xufVxuXG5mdW5jdGlvbiBjaGVja05vZGUgKG5vZGUsIGVycm9ycykge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBub2RlLmF0dHJzTWFwKSB7XG4gICAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmF0dHJzTWFwW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3YtZm9yJykge1xuICAgICAgICAgICAgY2hlY2tGb3Iobm9kZSwgKFwidi1mb3I9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGNoZWNrRXZlbnQodmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGVja05vZGUobm9kZS5jaGlsZHJlbltpXSwgZXJyb3JzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAyKSB7XG4gICAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50ZXh0LCBlcnJvcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXZlbnQgKGV4cCwgdGV4dCwgZXJyb3JzKSB7XG4gIHZhciBrZXl3b3JkTWF0Y2ggPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJykubWF0Y2godW5hcnlPcGVyYXRvcnNSRSk7XG4gIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICBlcnJvcnMucHVzaChcbiAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCB1bmFyeSBvcGVyYXRvciBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiIGluIGV4cHJlc3Npb24gXCIgKyAodGV4dC50cmltKCkpXG4gICAgKTtcbiAgfVxuICBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCBlcnJvcnMpO1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvciAobm9kZSwgdGV4dCwgZXJyb3JzKSB7XG4gIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuYWxpYXMsICd2LWZvciBhbGlhcycsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMSwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xufVxuXG5mdW5jdGlvbiBjaGVja0lkZW50aWZpZXIgKGlkZW50LCB0eXBlLCB0ZXh0LCBlcnJvcnMpIHtcbiAgaWYgKHR5cGVvZiBpZGVudCA9PT0gJ3N0cmluZycgJiYgIWlkZW50UkUudGVzdChpZGVudCkpIHtcbiAgICBlcnJvcnMucHVzaCgoXCJpbnZhbGlkIFwiICsgdHlwZSArIFwiIFxcXCJcIiArIGlkZW50ICsgXCJcXFwiIGluIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXhwcmVzc2lvbiAoZXhwLCB0ZXh0LCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oKFwicmV0dXJuIFwiICsgZXhwKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xuICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9ycy5wdXNoKChcImludmFsaWQgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpKSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiYXNlQ29tcGlsZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgdmFyIGFzdCA9IHBhcnNlKHRlbXBsYXRlLnRyaW0oKSwgb3B0aW9ucyk7XG4gIG9wdGltaXplKGFzdCwgb3B0aW9ucyk7XG4gIHZhciBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBhc3Q6IGFzdCxcbiAgICByZW5kZXI6IGNvZGUucmVuZGVyLFxuICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlRnVuY3Rpb24gKGNvZGUsIGVycm9ycykge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3JzLnB1c2goeyBlcnI6IGVyciwgY29kZTogY29kZSB9KTtcbiAgICByZXR1cm4gbm9vcFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuICB2YXIgZnVuY3Rpb25Db21waWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZ1bmN0aW9uIGNvbXBpbGUgKFxuICAgIHRlbXBsYXRlLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgdGlwcyA9IFtdO1xuICAgIGZpbmFsT3B0aW9ucy53YXJuID0gZnVuY3Rpb24gKG1zZywgdGlwJCQxKSB7XG4gICAgICAodGlwJCQxID8gdGlwcyA6IGVycm9ycykucHVzaChtc2cpO1xuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgLy8gbWVyZ2UgY3VzdG9tIG1vZHVsZXNcbiAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMpIHtcbiAgICAgICAgZmluYWxPcHRpb25zLm1vZHVsZXMgPSAoYmFzZU9wdGlvbnMubW9kdWxlcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMubW9kdWxlcyk7XG4gICAgICB9XG4gICAgICAvLyBtZXJnZSBjdXN0b20gZGlyZWN0aXZlc1xuICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICBmaW5hbE9wdGlvbnMuZGlyZWN0aXZlcyA9IGV4dGVuZChcbiAgICAgICAgICBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zLmRpcmVjdGl2ZXMpLFxuICAgICAgICAgIG9wdGlvbnMuZGlyZWN0aXZlc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLy8gY29weSBvdGhlciBvcHRpb25zXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAoa2V5ICE9PSAnbW9kdWxlcycgJiYga2V5ICE9PSAnZGlyZWN0aXZlcycpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjb21waWxlZCA9IGJhc2VDb21waWxlKHRlbXBsYXRlLCBmaW5hbE9wdGlvbnMpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QpKTtcbiAgICB9XG4gICAgY29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xuICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xuICAgIHJldHVybiBjb21waWxlZFxuICB9XG5cbiAgZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zIChcbiAgICB0ZW1wbGF0ZSxcbiAgICBvcHRpb25zLFxuICAgIHZtXG4gICkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIGRldGVjdCBwb3NzaWJsZSBDU1AgcmVzdHJpY3Rpb25cbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBGdW5jdGlvbigncmV0dXJuIDEnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5tYXRjaCgvdW5zYWZlLWV2YWx8Q1NQLykpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIHN0YW5kYWxvbmUgYnVpbGQgb2YgVnVlLmpzIGluIGFuICcgK1xuICAgICAgICAgICAgJ2Vudmlyb25tZW50IHdpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdGhhdCBwcm9oaWJpdHMgdW5zYWZlLWV2YWwuICcgK1xuICAgICAgICAgICAgJ1RoZSB0ZW1wbGF0ZSBjb21waWxlciBjYW5ub3Qgd29yayBpbiB0aGlzIGVudmlyb25tZW50LiBDb25zaWRlciAnICtcbiAgICAgICAgICAgICdyZWxheGluZyB0aGUgcG9saWN5IHRvIGFsbG93IHVuc2FmZS1ldmFsIG9yIHByZS1jb21waWxpbmcgeW91ciAnICtcbiAgICAgICAgICAgICd0ZW1wbGF0ZXMgaW50byByZW5kZXIgZnVuY3Rpb25zLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgY2FjaGVcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5kZWxpbWl0ZXJzXG4gICAgICA/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGVcbiAgICAgIDogdGVtcGxhdGU7XG4gICAgaWYgKGZ1bmN0aW9uQ29tcGlsZUNhY2hlW2tleV0pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbkNvbXBpbGVDYWNoZVtrZXldXG4gICAgfVxuXG4gICAgLy8gY29tcGlsZVxuICAgIHZhciBjb21waWxlZCA9IGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuXG4gICAgLy8gY2hlY2sgY29tcGlsYXRpb24gZXJyb3JzL3RpcHNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNvbXBpbGVkLmVycm9ycyAmJiBjb21waWxlZC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIgKyB0ZW1wbGF0ZSArIFwiXFxuXFxuXCIgK1xuICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChcIi0gXCIgKyBlKTsgfSkuam9pbignXFxuJykgKyAnXFxuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBpbGVkLnRpcHMgJiYgY29tcGlsZWQudGlwcy5sZW5ndGgpIHtcbiAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2cpIHsgcmV0dXJuIHRpcChtc2csIHZtKTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdHVybiBjb2RlIGludG8gZnVuY3Rpb25zXG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHZhciBmbkdlbkVycm9ycyA9IFtdO1xuICAgIHJlcy5yZW5kZXIgPSBtYWtlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XG4gICAgdmFyIGwgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoO1xuICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJlcy5zdGF0aWNSZW5kZXJGbnNbaV0gPSBtYWtlRnVuY3Rpb24oY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zW2ldLCBmbkdlbkVycm9ycyk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZnVuY3Rpb24gZ2VuZXJhdGlvbiBlcnJvcnMuXG4gICAgLy8gdGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlcmUgaXMgYSBidWcgaW4gdGhlIGNvbXBpbGVyIGl0c2VsZi5cbiAgICAvLyBtb3N0bHkgZm9yIGNvZGVnZW4gZGV2ZWxvcG1lbnQgdXNlXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICgoIWNvbXBpbGVkLmVycm9ycyB8fCAhY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkgJiYgZm5HZW5FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJGYWlsZWQgdG8gZ2VuZXJhdGUgcmVuZGVyIGZ1bmN0aW9uOlxcblxcblwiICtcbiAgICAgICAgICBmbkdlbkVycm9ycy5tYXAoZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgdmFyIGVyciA9IHJlZi5lcnI7XG4gICAgICAgICAgICB2YXIgY29kZSA9IHJlZi5jb2RlO1xuXG4gICAgICAgICAgICByZXR1cm4gKChlcnIudG9TdHJpbmcoKSkgKyBcIiBpblxcblxcblwiICsgY29kZSArIFwiXFxuXCIpO1xuICAgICAgICB9KS5qb2luKCdcXG4nKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoZnVuY3Rpb25Db21waWxlQ2FjaGVba2V5XSA9IHJlcylcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29tcGlsZTogY29tcGlsZSxcbiAgICBjb21waWxlVG9GdW5jdGlvbnM6IGNvbXBpbGVUb0Z1bmN0aW9uc1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY0NsYXNzID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2NsYXNzJyk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRpY0NsYXNzKSB7XG4gICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiY2xhc3M9XFxcIlwiICsgc3RhdGljQ2xhc3MgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGNsYXNzPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6Y2xhc3M9XCJ2YWxcIj4uJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG4gIH1cbiAgdmFyIGNsYXNzQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnY2xhc3MnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoY2xhc3NCaW5kaW5nKSB7XG4gICAgZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY0NsYXNzKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY0NsYXNzOlwiICsgKGVsLnN0YXRpY0NsYXNzKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwiY2xhc3M6XCIgKyAoZWwuY2xhc3NCaW5kaW5nKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBrbGFzcyQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY0NsYXNzJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNTdHlsZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzdHlsZScpO1xuICBpZiAoc3RhdGljU3R5bGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQoc3RhdGljU3R5bGUsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XG4gIH1cblxuICB2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQyIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMlxufTtcblxudmFyIG1vZHVsZXMkMSA9IFtcbiAga2xhc3MkMSxcbiAgc3R5bGUkMVxuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRleHQgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICd0ZXh0Q29udGVudCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XG4gIH1cbn1cblxudmFyIGRpcmVjdGl2ZXMkMSA9IHtcbiAgbW9kZWw6IG1vZGVsLFxuICB0ZXh0OiB0ZXh0LFxuICBodG1sOiBodG1sXG59O1xuXG4vKiAgKi9cblxudmFyIGJhc2VPcHRpb25zID0ge1xuICBleHBlY3RIVE1MOiB0cnVlLFxuICBtb2R1bGVzOiBtb2R1bGVzJDEsXG4gIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMkMSxcbiAgaXNQcmVUYWc6IGlzUHJlVGFnLFxuICBpc1VuYXJ5VGFnOiBpc1VuYXJ5VGFnLFxuICBtdXN0VXNlUHJvcDogbXVzdFVzZVByb3AsXG4gIGNhbkJlTGVmdE9wZW5UYWc6IGNhbkJlTGVmdE9wZW5UYWcsXG4gIGlzUmVzZXJ2ZWRUYWc6IGlzUmVzZXJ2ZWRUYWcsXG4gIGdldFRhZ05hbWVzcGFjZTogZ2V0VGFnTmFtZXNwYWNlLFxuICBzdGF0aWNLZXlzOiBnZW5TdGF0aWNLZXlzKG1vZHVsZXMkMSlcbn07XG5cbnZhciByZWYkMSA9IGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKTtcbnZhciBjb21waWxlVG9GdW5jdGlvbnMgPSByZWYkMS5jb21waWxlVG9GdW5jdGlvbnM7XG5cbi8qICAqL1xuXG52YXIgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChpZCkge1xuICB2YXIgZWwgPSBxdWVyeShpZCk7XG4gIHJldHVybiBlbCAmJiBlbC5pbm5lckhUTUxcbn0pO1xuXG52YXIgbW91bnQgPSBWdWUkMy5wcm90b3R5cGUuJG1vdW50O1xuVnVlJDMucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgcXVlcnkoZWwpO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgKFwiVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6IFwiICsgKG9wdGlvbnMudGVtcGxhdGUpKSxcbiAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWYgPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IHNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgICAgICBkZWxpbWl0ZXJzOiBvcHRpb25zLmRlbGltaXRlcnNcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xuICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZSBlbmQnKTtcbiAgICAgICAgbWVhc3VyZSgoKHRoaXMuX25hbWUpICsgXCIgY29tcGlsZVwiKSwgJ2NvbXBpbGUnLCAnY29tcGlsZSBlbmQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vdW50LmNhbGwodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8qKlxuICogR2V0IG91dGVySFRNTCBvZiBlbGVtZW50cywgdGFraW5nIGNhcmVcbiAqIG9mIFNWRyBlbGVtZW50cyBpbiBJRSBhcyB3ZWxsLlxuICovXG5mdW5jdGlvbiBnZXRPdXRlckhUTUwgKGVsKSB7XG4gIGlmIChlbC5vdXRlckhUTUwpIHtcbiAgICByZXR1cm4gZWwub3V0ZXJIVE1MXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MXG4gIH1cbn1cblxuVnVlJDMuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcblxuZXhwb3J0IGRlZmF1bHQgVnVlJDM7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgcHJpY2VDdXJyZW5jaWVzID0gW3tcbiAgICBpZDogXCJkb2xsYXJfdXNcIixcbiAgICBuYW1lOiBcIlVTIERvbGxhclwiLFxuICAgIGxhYmVsOiBcIiRcIixcbiAgICB2YWw6IDFcbn0sIHtcbiAgICBpZDogXCJldXJvXCIsXG4gICAgbmFtZTogXCJFdXJvXCIsXG4gICAgbGFiZWw6IFwi4oKsXCIsXG4gICAgdmFsOiAwLjkxODYwM1xufSwge1xuICAgIGlkOiBcInBvdW5kXCIsXG4gICAgbmFtZTogXCJQb3VuZFwiLFxuICAgIGxhYmVsOiBcIsKjXCIsXG4gICAgdmFsOiAwLjc5Mzc1MlxufSwge1xuICAgIGlkOiBcImRvbGxhcl9jYVwiLFxuICAgIG5hbWU6IFwiQ2FuYWRpYW4gRG9sbGFyXCIsXG4gICAgbGFiZWw6IFwiJFwiLFxuICAgIHZhbDogMS4zMzQ0OFxufSwge1xuICAgIGlkOiBcImRvbGxhcl9hdVwiLFxuICAgIG5hbWU6IFwiQXVzdHJhbGlhbiBEb2xsYXJcIixcbiAgICBsYWJlbDogXCIkXCIsXG4gICAgdmFsOiAxLjMwOTMxXG59XTtcblxuZXhwb3J0IGRlZmF1bHQgcHJpY2VDdXJyZW5jaWVzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IHByaWNlTW9kZXMgPSBbe1xuICAgIGlkOiBcImxvd1wiLFxuICAgIG5hbWU6IFwiTG93XCIsXG59LCB7XG4gICAgaWQ6IFwiYXZlcmFnZVwiLFxuICAgIG5hbWU6IFwiQXZlcmFnZVwiLFxufSwge1xuICAgIGlkOiBcImhpZ2hcIixcbiAgICBuYW1lOiBcIkhpZ2hcIixcbn1dO1xuXG5leHBvcnQgZGVmYXVsdCBwcmljZU1vZGVzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IGRlY2tQYXJ0cyA9IFt7XG4gICAgaWQ6IFwibWFpblwiLFxuICAgIG5hbWU6IFwiTWFpblwiLFxuICAgIGZpbGVJZDogXCIjbWFpblwiLFxuICAgIHNpemU6IFs0MCwgNjBdXG59LCB7XG4gICAgaWQ6IFwiZXh0cmFcIixcbiAgICBuYW1lOiBcIkV4dHJhXCIsXG4gICAgZmlsZUlkOiBcIiNleHRyYVwiLFxuICAgIHNpemU6IFswLCAxNV1cbn0sIHtcbiAgICBpZDogXCJzaWRlXCIsXG4gICAgbmFtZTogXCJTaWRlXCIsXG4gICAgZmlsZUlkOiBcIiFzaWRlXCIsXG4gICAgc2l6ZTogWzAsIDE1XVxufV07XG5cbmV4cG9ydCBkZWZhdWx0IGRlY2tQYXJ0cztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgZGF0YVByaWNlQ3VycmVuY2llcyBmcm9tIFwiLi9kYXRhL3ByaWNlQ3VycmVuY2llc1wiO1xuaW1wb3J0IGRhdGFQcmljZU1vZGVzIGZyb20gXCIuL2RhdGEvcHJpY2VNb2Rlc1wiO1xuaW1wb3J0IGRhdGFEZWNrUGFydHMgZnJvbSBcIi4vZGF0YS9kZWNrUGFydHNcIjtcblxuY29uc3QgYXBwRGF0YSA9IHtcbiAgICBkZWNrcGFydHM6IGRhdGFEZWNrUGFydHMsXG4gICAgZGVjazoge1xuICAgICAgICBuYW1lOiBcIlVubmFtZWRcIixcbiAgICAgICAgbGluazogXCJcIixcbiAgICAgICAgbGlzdDoge1xuICAgICAgICAgICAgbWFpbjogW10sXG4gICAgICAgICAgICBleHRyYTogW10sXG4gICAgICAgICAgICBzaWRlOiBbXVxuICAgICAgICB9XG4gICAgfSxcbiAgICBjYXJkczoge1xuICAgICAgICBwYWlyczogW10sXG4gICAgICAgIGRhdGE6IHt9XG4gICAgfSxcbiAgICBidWlsZGVyOiB7XG4gICAgICAgIGZpbHRlcjogXCJcIixcbiAgICAgICAgcGFpcnNGaWx0ZXJlZDogW10sXG4gICAgfSxcbiAgICBwcmljZToge1xuICAgICAgICBhY3RpdmVDdXJyZW5jeTogXCJkb2xsYXJfdXNcIixcbiAgICAgICAgbW9kZXM6IGRhdGFQcmljZU1vZGVzLFxuICAgICAgICBjdXJyZW5jaWVzOiBkYXRhUHJpY2VDdXJyZW5jaWVzXG4gICAgfSxcbiAgICBhamF4OiB7XG4gICAgICAgIGN1cnJlbnRseUxvYWRpbmc6IGZhbHNlLFxuICAgICAgICBuYW1lc0xvYWRlZDogZmFsc2UsXG4gICAgICAgIHByaWNlc0xvYWRlZDogZmFsc2VcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBhcHBEYXRhO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IHVyaUxvY2F0aW9uTm9QYXJhbSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbG9jYXRpb24ub3JpZ2luICsgbG9jYXRpb24ucGF0aG5hbWU7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1cmlMb2NhdGlvbk5vUGFyYW07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgZWFjaE9iamVjdCA9IGZ1bmN0aW9uIChvYmplY3QsIGZuKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgY29uc3QgbCA9IGtleXMubGVuZ3RoO1xuICAgIGxldCBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgbCkge1xuICAgICAgICBjb25zdCBjdXJyZW50S2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBmbihvYmplY3RbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIGkpO1xuICAgICAgICBpKys7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZWFjaE9iamVjdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQge1xuICAgIG5hbWVBUEksXG4gICAgaW1hZ2VBUEksXG4gICAgYnV5QVBJXG59IGZyb20gXCIuLi9kYXRhL2FwaVVSTHNcIjtcbmltcG9ydCB1dGlsRWFjaE9iamVjdCBmcm9tIFwiLi91dGlsRWFjaE9iamVjdFwiO1xuXG5jb25zdCBhcGlMb2FkTmFtZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuXG4gICAgdm0uYWpheC5jdXJyZW50bHlMb2FkaW5nID0gdHJ1ZTtcbiAgICB2bS5hamF4Lm5hbWVzTG9hZGVkID0gZmFsc2U7XG5cbiAgICBmZXRjaChuYW1lQVBJKVxuICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbihqc29uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdERhdGEgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdFBhaXJzID0gW107XG4gICAgICAgICAgICBjb25zdCBuYW1lU3RvcmFnZSA9IFtdO1xuXG4gICAgICAgICAgICB1dGlsRWFjaE9iamVjdChqc29uLCAobmFtZSwgaWQpID0+IHtcbiAgICAgICAgICAgICAgICByZXN1bHREYXRhW2lkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgaW1nOiBgJHtpbWFnZUFQSX0vJHtpZH0uanBnYCxcbiAgICAgICAgICAgICAgICAgICAgbGluazogYCR7YnV5QVBJfSR7ZW5jb2RlVVJJKG5hbWUpfWAsXG4gICAgICAgICAgICAgICAgICAgIHByaWNlOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvL09ubHkgYWRkIGVhY2ggY2FyZCBvbmNlIHRvIHBhcnMsIHNraXAgYWx0ZXJuYXRlIGFydHNcbiAgICAgICAgICAgICAgICBpZiAobmFtZVN0b3JhZ2UuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0UGFpcnMucHVzaChbaWQsIG5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuYW1lU3RvcmFnZS5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZtLmNhcmRzLmRhdGEgPSByZXN1bHREYXRhO1xuICAgICAgICAgICAgdm0uY2FyZHMucGFpcnMgPSByZXN1bHRQYWlycy5zb3J0KChhLCBiKSA9PiBhWzFdLmxvY2FsZUNvbXBhcmUoYlsxXSkpO1xuICAgICAgICAgICAgdm0uYnVpbGRlclVwZGF0ZU5hbWVzKCk7XG5cbiAgICAgICAgICAgIHZtLmFqYXguY3VycmVudGx5TG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdm0uYWpheC5uYW1lc0xvYWRlZCA9IHRydWU7XG4gICAgICAgIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgYXBpTG9hZE5hbWVzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydCBjb25zdCBuYW1lQVBJID0gXCIuL2FwaS9uYW1lcy9uYW1lcy5taW4uanNvblwiO1xuZXhwb3J0IGNvbnN0IHByaWNlQVBJID0gXCIuL2FwaS9wcmljZXMvcHJpY2VzLnBocD9uPVwiO1xuZXhwb3J0IGNvbnN0IGltYWdlQVBJID0gXCJodHRwczovL3lnb3Byb2RlY2suY29tL3BpY3NcIjtcbmV4cG9ydCBjb25zdCBidXlBUEkgPSBcImh0dHA6Ly95dWdpb2hwcmljZXMuY29tL2NhcmRfcHJpY2U/bmFtZT1cIjtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQge1xuICAgIHByaWNlQVBJXG59IGZyb20gXCIuLi9kYXRhL2FwaVVSTHNcIjtcbi8vaW1wb3J0IHV0aWxFYWNoT2JqZWN0IGZyb20gXCIuL3V0aWxFYWNoT2JqZWN0XCI7XG5cbmNvbnN0IGFwaUxvYWRQcmljZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIC8vQXJyYXkgb2YgdW5pcXVlIGlkcywgbWludXMgdGhlIG9uZXMgd2hlcmUgcHJpY2VzIHdlcmUgYWxyZWFkeSBsb2FkZWRcbiAgICBjb25zdCBjYXJkSWRzID0gdm0uZGVja0NhcmRzV2l0aG91dFByaWNlRGF0YSgpO1xuXG4gICAgaWYgKGNhcmRJZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBjYXJkTmFtZXMgPSBjYXJkSWRzLm1hcChjYXJkSWQgPT4gdm0uY2FyZHMuZGF0YVtjYXJkSWRdLm5hbWUpO1xuICAgICAgICBjb25zdCBwcmljZVF1ZXJ5ID0gYnRvYShKU09OLnN0cmluZ2lmeShjYXJkTmFtZXMpKTtcblxuICAgICAgICB2bS5hamF4LmN1cnJlbnRseUxvYWRpbmcgPSB0cnVlO1xuICAgICAgICB2bS5hamF4LnByaWNlc0xvYWRlZCA9IGZhbHNlO1xuXG4gICAgICAgIGZldGNoKHByaWNlQVBJICsgcHJpY2VRdWVyeSlcbiAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGpzb24gPT4ge1xuICAgICAgICAgICAgICAgIGNhcmRJZHMuZm9yRWFjaCgoaWQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByaWNlRGF0YSA9IGpzb25baW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXJkID0gdm0uY2FyZHMuZGF0YVtpZF07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmQucHJpY2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93OiBwcmljZURhdGEubG93LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2ZXJhZ2U6IHByaWNlRGF0YS5hdmVyYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2g6IHByaWNlRGF0YS5oaWdoXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB2bS5hamF4LmN1cnJlbnRseUxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2bS5hamF4LnByaWNlc0xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2bS5hamF4LnByaWNlc0xvYWRlZCA9IHRydWU7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgYXBpTG9hZFByaWNlcztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgZGVja1BhcnRzIGZyb20gXCIuLi9kYXRhL2RlY2tQYXJ0c1wiO1xuXG5jb25zdCBjb252ZXJ0RmlsZVRvRGVjayA9IGZ1bmN0aW9uIChmaWxlQ29udGVudCkge1xuICAgIGNvbnN0IGZpbGVDb250ZW50VHJpbW1lZCA9IGZpbGVDb250ZW50LnJlcGxhY2UoLyNjcmVhdGVkLisvLCBcIlwiKS50cmltKCk7XG4gICAgY29uc3QgYXJyID0gZmlsZUNvbnRlbnRUcmltbWVkLnNwbGl0KC9bIyFdLisvZykuc3BsaWNlKDEpO1xuICAgIGNvbnN0IGFyclBhcnRzID0gYXJyLm1hcChwYXJ0ID0+IHBhcnQuc3BsaXQoXCJcXG5cIikuZmlsdGVyKGxpbmUgPT4gbGluZS5sZW5ndGggPiAxKS5tYXAoTnVtYmVyKSk7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG5cbiAgICBkZWNrUGFydHMuZm9yRWFjaCgoZGVja3BhcnQsIGluZGV4KSA9PiB7XG4gICAgICAgIHJlc3VsdFtkZWNrcGFydC5pZF0gPSBhcnJQYXJ0c1tpbmRleF07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY29udmVydEZpbGVUb0RlY2s7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IGNvbnZlcnRGaWxlVG9EZWNrIGZyb20gXCIuL2NvbnZlcnRGaWxlVG9EZWNrXCI7XG5cbmNvbnN0IGRlY2tMb2FkID0gZnVuY3Rpb24gKGZpbGUpIHtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIGNvbnN0IHZtID0gdGhpcztcblxuICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBjb25zdCBmaWxlQ29udGVudCA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgY29uc3QgZGVja0xpc3QgPSBjb252ZXJ0RmlsZVRvRGVjayhmaWxlQ29udGVudCk7XG5cbiAgICAgICAgdm0uZGVjay5uYW1lID0gZmlsZS5uYW1lLnJlcGxhY2UoXCIueWRrXCIsIFwiXCIpO1xuICAgICAgICB2bS5kZWNrLmxpc3QgPSBkZWNrTGlzdDtcbiAgICAgICAgdm0uZGVja1VwZGF0ZSgpO1xuICAgIH07XG5cbiAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGRlY2tMb2FkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBkZWNrUGFydHMgZnJvbSBcIi4uL2RhdGEvZGVja1BhcnRzXCI7XG5cbmNvbnN0IHVyaURlY2tEZWNvZGUgPSBmdW5jdGlvbiAoZGVja1VyaSkge1xuICAgIGNvbnN0IGRlY2tBcnJheSA9IEpTT04ucGFyc2UoYXRvYihkZWNrVXJpLnJlcGxhY2UoXCI/ZD1cIiwgXCJcIikpKTtcbiAgICBjb25zdCBkZWNrTGlzdCA9IHt9O1xuXG4gICAgZGVja1BhcnRzLmZvckVhY2goKGRlY2twYXJ0LCBpbmRleCkgPT4ge1xuICAgICAgICBkZWNrTGlzdFtkZWNrcGFydC5pZF0gPSBkZWNrQXJyYXlbMV1baW5kZXhdO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIFtkZWNrQXJyYXlbMF0sIGRlY2tMaXN0XTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVyaURlY2tEZWNvZGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHVyaURlY2tEZWNvZGUgZnJvbSBcIi4vdXJpRGVja0RlY29kZVwiO1xuXG5jb25zdCBkZWNrTG9hZFVyaSA9IGZ1bmN0aW9uICh1cmlEZWNrKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIGNvbnN0IGRlY2tBcnJheSA9IHVyaURlY2tEZWNvZGUodXJpRGVjayk7XG5cbiAgICB2bS5kZWNrLm5hbWUgPSBkZWNrQXJyYXlbMF07XG4gICAgdm0uZGVjay5saXN0ID0gZGVja0FycmF5WzFdO1xuICAgIHZtLmRlY2tVcGRhdGUodXJpRGVjayk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBkZWNrTG9hZFVyaTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5cbmNvbnN0IHVyaURlY2tFbmNvZGUgPSBmdW5jdGlvbiAoZGVjaykge1xuICAgIGNvbnN0IGRlY2tBcnJheSA9IFtkZWNrLm5hbWUsIE9iamVjdC52YWx1ZXMoZGVjay5saXN0KV07XG4gICAgY29uc3QgZGVja1VyaSA9IGJ0b2EoSlNPTi5zdHJpbmdpZnkoZGVja0FycmF5KSk7XG5cbiAgICByZXR1cm4gXCI/ZD1cIiArIGRlY2tVcmk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1cmlEZWNrRW5jb2RlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB1cmlEZWNrRW5jb2RlIGZyb20gXCIuL3VyaURlY2tFbmNvZGVcIjtcblxuY29uc3QgZGVja1VwZGF0ZSA9IGZ1bmN0aW9uIChkZWNrTGluaykge1xuICAgIGNvbnN0IHZtID0gdGhpcztcblxuICAgIHZtLmRlY2subGluayA9IGRlY2tMaW5rIHx8IHVyaURlY2tFbmNvZGUodm0uZGVjayk7XG4gICAgdm0uYWpheC5wcmljZXNMb2FkZWQgPSBmYWxzZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGRlY2tVcGRhdGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHV0aWxFYWNoT2JqZWN0IGZyb20gXCIuL3V0aWxFYWNoT2JqZWN0XCI7XG5cbmNvbnN0IGRlY2tDYXJkc1dpdGhvdXRQcmljZURhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIGNvbnN0IGRhdGEgPSB2bS5jYXJkcy5kYXRhO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgdXRpbEVhY2hPYmplY3Qodm0uZGVjay5saXN0LCBkZWNrcGFydCA9PiB7XG4gICAgICAgIGRlY2twYXJ0LmZvckVhY2goY2FyZElkID0+IHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuaW5kZXhPZihjYXJkSWQpID09PSAtMSAmJiAhZGF0YVtjYXJkSWRdLnByaWNlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2FyZElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZGVja0NhcmRzV2l0aG91dFByaWNlRGF0YTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBwcmljZUNvbnZlcnQgPSBmdW5jdGlvbiAocHJpY2UpIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgY29uc3QgY3VycmVuY3kgPSB2bS5wcmljZS5jdXJyZW5jaWVzLmZpbmQoaXRlbSA9PiBpdGVtLmlkID09PSB2bS5wcmljZS5hY3RpdmVDdXJyZW5jeSk7XG4gICAgY29uc3QgdmFsID0gKHByaWNlICogY3VycmVuY3kudmFsKS50b0ZpeGVkKDIpO1xuXG4gICAgcmV0dXJuIHZhbCArIGN1cnJlbmN5LmxhYmVsO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgcHJpY2VDb252ZXJ0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IHByaWNlRm9yQ2FyZCA9IGZ1bmN0aW9uIChpZCwgbW9kZSkge1xuICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICBjb25zdCBwcmljZSA9IHZtLmNhcmRzLmRhdGFbaWRdLnByaWNlW21vZGVdO1xuXG4gICAgaWYgKHByaWNlKSB7XG4gICAgICAgIHJldHVybiB2bS5wcmljZUNvbnZlcnQocHJpY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcIk5vdCBmb3VuZFwiO1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IHByaWNlRm9yQ2FyZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgdXRpbEVhY2hPYmplY3QgZnJvbSBcIi4vdXRpbEVhY2hPYmplY3RcIjtcblxuY29uc3QgcHJpY2VGb3JTZWN0aW9uID0gZnVuY3Rpb24gKHNlY3Rpb24sIG1vZGUpIHtcbiAgICBjb25zdCBwcmljZVN1bSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG5cbiAgICAgICAgaWYgKGFyciAmJiBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICBhcnIuZm9yRWFjaChpZCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FyZERhdGEgPSB2bS5jYXJkcy5kYXRhW2lkXTtcbiAgICAgICAgICAgICAgICBpZiAoY2FyZERhdGEgJiYgY2FyZERhdGEucHJpY2UgJiYgY2FyZERhdGEucHJpY2VbbW9kZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGNhcmREYXRhLnByaWNlW21vZGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICBsZXQgcHJpY2UgPSAwO1xuXG4gICAgaWYgKHNlY3Rpb24gPT09IFwiKlwiKSB7XG4gICAgICAgIHV0aWxFYWNoT2JqZWN0KHZtLmRlY2subGlzdCwgZGVja3BhcnQgPT4ge1xuICAgICAgICAgICAgcHJpY2UgKz0gcHJpY2VTdW0oZGVja3BhcnQpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwcmljZSA9IHByaWNlU3VtKHZtLmRlY2subGlzdFtzZWN0aW9uXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZtLnByaWNlQ29udmVydChwcmljZSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwcmljZUZvclNlY3Rpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgYnVpbGRlclVwZGF0ZU5hbWVzID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICBjb25zdCBmaWx0ZXIgPSB2bS5idWlsZGVyLmZpbHRlci50b0xvd2VyQ2FzZSgpO1xuICAgIGxldCByZXN1bHQgPSB2bS5jYXJkcy5wYWlycy5maWx0ZXIoY2FyZCA9PiB7XG4gICAgICAgIHJldHVybiBjYXJkWzFdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihmaWx0ZXIpICE9PSAtMTtcbiAgICB9KTtcblxuICAgIGlmIChyZXN1bHQubGVuZ3RoID4gNTAwKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zcGxpY2UoMCwgNTAwKTtcbiAgICB9XG5cbiAgICB2bS5idWlsZGVyLnBhaXJzRmlsdGVyZWQgPSByZXN1bHQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBidWlsZGVyVXBkYXRlTmFtZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgYnVpbGRlckRlY2tBZGQgPSBmdW5jdGlvbiAoaWQsIHBhcnQpIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgY29uc3QgY2FyZElkID0gTnVtYmVyKGlkKTtcbiAgICBjb25zdCBkZWNrUGFydCA9IHZtLmRlY2subGlzdFtwYXJ0XTtcbiAgICBjb25zdCBkZWNrUGFydE1heCA9IHZtLmRlY2twYXJ0cy5maW5kKGRlY2twYXJ0ID0+IGRlY2twYXJ0LmlkID09PSBwYXJ0KS5zaXplWzFdO1xuXG4gICAgaWYgKGRlY2tQYXJ0Lmxlbmd0aCA8IGRlY2tQYXJ0TWF4ICYmIGRlY2tQYXJ0LmZpbHRlcihpZCA9PiBpZCA9PT0gY2FyZElkKS5sZW5ndGggPCAzKSB7XG4gICAgICAgIGRlY2tQYXJ0LnB1c2goY2FyZElkKTtcbiAgICAgICAgdm0uZGVja1VwZGF0ZSgpO1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGJ1aWxkZXJEZWNrQWRkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IGJ1aWxkZXJEZWNrUmVtb3ZlID0gZnVuY3Rpb24gKGlkLCBwYXJ0KSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIGxldCBmb3VuZENhcmQgPSBmYWxzZTtcblxuICAgIHZtLmRlY2subGlzdFtwYXJ0XSA9IHZtLmRlY2subGlzdFtwYXJ0XS5maWx0ZXIoY2FyZElkID0+IHtcbiAgICAgICAgaWYgKCFmb3VuZENhcmQpIHtcbiAgICAgICAgICAgIGlmIChpZCA9PT0gY2FyZElkKSB7XG4gICAgICAgICAgICAgICAgZm91bmRDYXJkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgdm0uZGVja1VwZGF0ZSgpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgYnVpbGRlckRlY2tSZW1vdmU7XG4iLCIvKiBGaWxlU2F2ZXIuanNcbiAqIEEgc2F2ZUFzKCkgRmlsZVNhdmVyIGltcGxlbWVudGF0aW9uLlxuICogMS4zLjJcbiAqIDIwMTYtMDYtMTYgMTg6MjU6MTlcbiAqXG4gKiBCeSBFbGkgR3JleSwgaHR0cDovL2VsaWdyZXkuY29tXG4gKiBMaWNlbnNlOiBNSVRcbiAqICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGlncmV5L0ZpbGVTYXZlci5qcy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kXG4gKi9cblxuLypnbG9iYWwgc2VsZiAqL1xuLypqc2xpbnQgYml0d2lzZTogdHJ1ZSwgaW5kZW50OiA0LCBsYXhicmVhazogdHJ1ZSwgbGF4Y29tbWE6IHRydWUsIHNtYXJ0dGFiczogdHJ1ZSwgcGx1c3BsdXM6IHRydWUgKi9cblxuLyohIEBzb3VyY2UgaHR0cDovL3B1cmwuZWxpZ3JleS5jb20vZ2l0aHViL0ZpbGVTYXZlci5qcy9ibG9iL21hc3Rlci9GaWxlU2F2ZXIuanMgKi9cblxudmFyIHNhdmVBcyA9IHNhdmVBcyB8fCAoZnVuY3Rpb24odmlldykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0Ly8gSUUgPDEwIGlzIGV4cGxpY2l0bHkgdW5zdXBwb3J0ZWRcblx0aWYgKHR5cGVvZiB2aWV3ID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgL01TSUUgWzEtOV1cXC4vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcblx0XHRyZXR1cm47XG5cdH1cblx0dmFyXG5cdFx0ICBkb2MgPSB2aWV3LmRvY3VtZW50XG5cdFx0ICAvLyBvbmx5IGdldCBVUkwgd2hlbiBuZWNlc3NhcnkgaW4gY2FzZSBCbG9iLmpzIGhhc24ndCBvdmVycmlkZGVuIGl0IHlldFxuXHRcdCwgZ2V0X1VSTCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHZpZXcuVVJMIHx8IHZpZXcud2Via2l0VVJMIHx8IHZpZXc7XG5cdFx0fVxuXHRcdCwgc2F2ZV9saW5rID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIiwgXCJhXCIpXG5cdFx0LCBjYW5fdXNlX3NhdmVfbGluayA9IFwiZG93bmxvYWRcIiBpbiBzYXZlX2xpbmtcblx0XHQsIGNsaWNrID0gZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0dmFyIGV2ZW50ID0gbmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiKTtcblx0XHRcdG5vZGUuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdFx0fVxuXHRcdCwgaXNfc2FmYXJpID0gL2NvbnN0cnVjdG9yL2kudGVzdCh2aWV3LkhUTUxFbGVtZW50KSB8fCB2aWV3LnNhZmFyaVxuXHRcdCwgaXNfY2hyb21lX2lvcyA9L0NyaU9TXFwvW1xcZF0rLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG5cdFx0LCB0aHJvd19vdXRzaWRlID0gZnVuY3Rpb24oZXgpIHtcblx0XHRcdCh2aWV3LnNldEltbWVkaWF0ZSB8fCB2aWV3LnNldFRpbWVvdXQpKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aHJvdyBleDtcblx0XHRcdH0sIDApO1xuXHRcdH1cblx0XHQsIGZvcmNlX3NhdmVhYmxlX3R5cGUgPSBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiXG5cdFx0Ly8gdGhlIEJsb2IgQVBJIGlzIGZ1bmRhbWVudGFsbHkgYnJva2VuIGFzIHRoZXJlIGlzIG5vIFwiZG93bmxvYWRmaW5pc2hlZFwiIGV2ZW50IHRvIHN1YnNjcmliZSB0b1xuXHRcdCwgYXJiaXRyYXJ5X3Jldm9rZV90aW1lb3V0ID0gMTAwMCAqIDQwIC8vIGluIG1zXG5cdFx0LCByZXZva2UgPSBmdW5jdGlvbihmaWxlKSB7XG5cdFx0XHR2YXIgcmV2b2tlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIGZpbGUgPT09IFwic3RyaW5nXCIpIHsgLy8gZmlsZSBpcyBhbiBvYmplY3QgVVJMXG5cdFx0XHRcdFx0Z2V0X1VSTCgpLnJldm9rZU9iamVjdFVSTChmaWxlKTtcblx0XHRcdFx0fSBlbHNlIHsgLy8gZmlsZSBpcyBhIEZpbGVcblx0XHRcdFx0XHRmaWxlLnJlbW92ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0c2V0VGltZW91dChyZXZva2VyLCBhcmJpdHJhcnlfcmV2b2tlX3RpbWVvdXQpO1xuXHRcdH1cblx0XHQsIGRpc3BhdGNoID0gZnVuY3Rpb24oZmlsZXNhdmVyLCBldmVudF90eXBlcywgZXZlbnQpIHtcblx0XHRcdGV2ZW50X3R5cGVzID0gW10uY29uY2F0KGV2ZW50X3R5cGVzKTtcblx0XHRcdHZhciBpID0gZXZlbnRfdHlwZXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHR2YXIgbGlzdGVuZXIgPSBmaWxlc2F2ZXJbXCJvblwiICsgZXZlbnRfdHlwZXNbaV1dO1xuXHRcdFx0XHRpZiAodHlwZW9mIGxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0bGlzdGVuZXIuY2FsbChmaWxlc2F2ZXIsIGV2ZW50IHx8IGZpbGVzYXZlcik7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXgpIHtcblx0XHRcdFx0XHRcdHRocm93X291dHNpZGUoZXgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHQsIGF1dG9fYm9tID0gZnVuY3Rpb24oYmxvYikge1xuXHRcdFx0Ly8gcHJlcGVuZCBCT00gZm9yIFVURi04IFhNTCBhbmQgdGV4dC8qIHR5cGVzIChpbmNsdWRpbmcgSFRNTClcblx0XHRcdC8vIG5vdGU6IHlvdXIgYnJvd3NlciB3aWxsIGF1dG9tYXRpY2FsbHkgY29udmVydCBVVEYtMTYgVStGRUZGIHRvIEVGIEJCIEJGXG5cdFx0XHRpZiAoL15cXHMqKD86dGV4dFxcL1xcUyp8YXBwbGljYXRpb25cXC94bWx8XFxTKlxcL1xcUypcXCt4bWwpXFxzKjsuKmNoYXJzZXRcXHMqPVxccyp1dGYtOC9pLnRlc3QoYmxvYi50eXBlKSkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IEJsb2IoW1N0cmluZy5mcm9tQ2hhckNvZGUoMHhGRUZGKSwgYmxvYl0sIHt0eXBlOiBibG9iLnR5cGV9KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBibG9iO1xuXHRcdH1cblx0XHQsIEZpbGVTYXZlciA9IGZ1bmN0aW9uKGJsb2IsIG5hbWUsIG5vX2F1dG9fYm9tKSB7XG5cdFx0XHRpZiAoIW5vX2F1dG9fYm9tKSB7XG5cdFx0XHRcdGJsb2IgPSBhdXRvX2JvbShibG9iKTtcblx0XHRcdH1cblx0XHRcdC8vIEZpcnN0IHRyeSBhLmRvd25sb2FkLCB0aGVuIHdlYiBmaWxlc3lzdGVtLCB0aGVuIG9iamVjdCBVUkxzXG5cdFx0XHR2YXJcblx0XHRcdFx0ICBmaWxlc2F2ZXIgPSB0aGlzXG5cdFx0XHRcdCwgdHlwZSA9IGJsb2IudHlwZVxuXHRcdFx0XHQsIGZvcmNlID0gdHlwZSA9PT0gZm9yY2Vfc2F2ZWFibGVfdHlwZVxuXHRcdFx0XHQsIG9iamVjdF91cmxcblx0XHRcdFx0LCBkaXNwYXRjaF9hbGwgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkaXNwYXRjaChmaWxlc2F2ZXIsIFwid3JpdGVzdGFydCBwcm9ncmVzcyB3cml0ZSB3cml0ZWVuZFwiLnNwbGl0KFwiIFwiKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gb24gYW55IGZpbGVzeXMgZXJyb3JzIHJldmVydCB0byBzYXZpbmcgd2l0aCBvYmplY3QgVVJMc1xuXHRcdFx0XHQsIGZzX2Vycm9yID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKChpc19jaHJvbWVfaW9zIHx8IChmb3JjZSAmJiBpc19zYWZhcmkpKSAmJiB2aWV3LkZpbGVSZWFkZXIpIHtcblx0XHRcdFx0XHRcdC8vIFNhZmFyaSBkb2Vzbid0IGFsbG93IGRvd25sb2FkaW5nIG9mIGJsb2IgdXJsc1xuXHRcdFx0XHRcdFx0dmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdFx0XHRcdFx0XHRyZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB1cmwgPSBpc19jaHJvbWVfaW9zID8gcmVhZGVyLnJlc3VsdCA6IHJlYWRlci5yZXN1bHQucmVwbGFjZSgvXmRhdGE6W147XSo7LywgJ2RhdGE6YXR0YWNobWVudC9maWxlOycpO1xuXHRcdFx0XHRcdFx0XHR2YXIgcG9wdXAgPSB2aWV3Lm9wZW4odXJsLCAnX2JsYW5rJyk7XG5cdFx0XHRcdFx0XHRcdGlmKCFwb3B1cCkgdmlldy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuXHRcdFx0XHRcdFx0XHR1cmw9dW5kZWZpbmVkOyAvLyByZWxlYXNlIHJlZmVyZW5jZSBiZWZvcmUgZGlzcGF0Y2hpbmdcblx0XHRcdFx0XHRcdFx0ZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuRE9ORTtcblx0XHRcdFx0XHRcdFx0ZGlzcGF0Y2hfYWxsKCk7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0cmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG5cdFx0XHRcdFx0XHRmaWxlc2F2ZXIucmVhZHlTdGF0ZSA9IGZpbGVzYXZlci5JTklUO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBkb24ndCBjcmVhdGUgbW9yZSBvYmplY3QgVVJMcyB0aGFuIG5lZWRlZFxuXHRcdFx0XHRcdGlmICghb2JqZWN0X3VybCkge1xuXHRcdFx0XHRcdFx0b2JqZWN0X3VybCA9IGdldF9VUkwoKS5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChmb3JjZSkge1xuXHRcdFx0XHRcdFx0dmlldy5sb2NhdGlvbi5ocmVmID0gb2JqZWN0X3VybDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIG9wZW5lZCA9IHZpZXcub3BlbihvYmplY3RfdXJsLCBcIl9ibGFua1wiKTtcblx0XHRcdFx0XHRcdGlmICghb3BlbmVkKSB7XG5cdFx0XHRcdFx0XHRcdC8vIEFwcGxlIGRvZXMgbm90IGFsbG93IHdpbmRvdy5vcGVuLCBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvc2FmYXJpL2RvY3VtZW50YXRpb24vVG9vbHMvQ29uY2VwdHVhbC9TYWZhcmlFeHRlbnNpb25HdWlkZS9Xb3JraW5nd2l0aFdpbmRvd3NhbmRUYWJzL1dvcmtpbmd3aXRoV2luZG93c2FuZFRhYnMuaHRtbFxuXHRcdFx0XHRcdFx0XHR2aWV3LmxvY2F0aW9uLmhyZWYgPSBvYmplY3RfdXJsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmaWxlc2F2ZXIucmVhZHlTdGF0ZSA9IGZpbGVzYXZlci5ET05FO1xuXHRcdFx0XHRcdGRpc3BhdGNoX2FsbCgpO1xuXHRcdFx0XHRcdHJldm9rZShvYmplY3RfdXJsKTtcblx0XHRcdFx0fVxuXHRcdFx0O1xuXHRcdFx0ZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuSU5JVDtcblxuXHRcdFx0aWYgKGNhbl91c2Vfc2F2ZV9saW5rKSB7XG5cdFx0XHRcdG9iamVjdF91cmwgPSBnZXRfVVJMKCkuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHNhdmVfbGluay5ocmVmID0gb2JqZWN0X3VybDtcblx0XHRcdFx0XHRzYXZlX2xpbmsuZG93bmxvYWQgPSBuYW1lO1xuXHRcdFx0XHRcdGNsaWNrKHNhdmVfbGluayk7XG5cdFx0XHRcdFx0ZGlzcGF0Y2hfYWxsKCk7XG5cdFx0XHRcdFx0cmV2b2tlKG9iamVjdF91cmwpO1xuXHRcdFx0XHRcdGZpbGVzYXZlci5yZWFkeVN0YXRlID0gZmlsZXNhdmVyLkRPTkU7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGZzX2Vycm9yKCk7XG5cdFx0fVxuXHRcdCwgRlNfcHJvdG8gPSBGaWxlU2F2ZXIucHJvdG90eXBlXG5cdFx0LCBzYXZlQXMgPSBmdW5jdGlvbihibG9iLCBuYW1lLCBub19hdXRvX2JvbSkge1xuXHRcdFx0cmV0dXJuIG5ldyBGaWxlU2F2ZXIoYmxvYiwgbmFtZSB8fCBibG9iLm5hbWUgfHwgXCJkb3dubG9hZFwiLCBub19hdXRvX2JvbSk7XG5cdFx0fVxuXHQ7XG5cdC8vIElFIDEwKyAobmF0aXZlIHNhdmVBcylcblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oYmxvYiwgbmFtZSwgbm9fYXV0b19ib20pIHtcblx0XHRcdG5hbWUgPSBuYW1lIHx8IGJsb2IubmFtZSB8fCBcImRvd25sb2FkXCI7XG5cblx0XHRcdGlmICghbm9fYXV0b19ib20pIHtcblx0XHRcdFx0YmxvYiA9IGF1dG9fYm9tKGJsb2IpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKGJsb2IsIG5hbWUpO1xuXHRcdH07XG5cdH1cblxuXHRGU19wcm90by5hYm9ydCA9IGZ1bmN0aW9uKCl7fTtcblx0RlNfcHJvdG8ucmVhZHlTdGF0ZSA9IEZTX3Byb3RvLklOSVQgPSAwO1xuXHRGU19wcm90by5XUklUSU5HID0gMTtcblx0RlNfcHJvdG8uRE9ORSA9IDI7XG5cblx0RlNfcHJvdG8uZXJyb3IgPVxuXHRGU19wcm90by5vbndyaXRlc3RhcnQgPVxuXHRGU19wcm90by5vbnByb2dyZXNzID1cblx0RlNfcHJvdG8ub253cml0ZSA9XG5cdEZTX3Byb3RvLm9uYWJvcnQgPVxuXHRGU19wcm90by5vbmVycm9yID1cblx0RlNfcHJvdG8ub253cml0ZWVuZCA9XG5cdFx0bnVsbDtcblxuXHRyZXR1cm4gc2F2ZUFzO1xufShcblx0ICAgdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZlxuXHR8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvd1xuXHR8fCB0aGlzLmNvbnRlbnRcbikpO1xuLy8gYHNlbGZgIGlzIHVuZGVmaW5lZCBpbiBGaXJlZm94IGZvciBBbmRyb2lkIGNvbnRlbnQgc2NyaXB0IGNvbnRleHRcbi8vIHdoaWxlIGB0aGlzYCBpcyBuc0lDb250ZW50RnJhbWVNZXNzYWdlTWFuYWdlclxuLy8gd2l0aCBhbiBhdHRyaWJ1dGUgYGNvbnRlbnRgIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIHdpbmRvd1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cy5zYXZlQXMgPSBzYXZlQXM7XG59IGVsc2UgaWYgKCh0eXBlb2YgZGVmaW5lICE9PSBcInVuZGVmaW5lZFwiICYmIGRlZmluZSAhPT0gbnVsbCkgJiYgKGRlZmluZS5hbWQgIT09IG51bGwpKSB7XG4gIGRlZmluZShcIkZpbGVTYXZlci5qc1wiLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2F2ZUFzO1xuICB9KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgZGVja1BhcnRzIGZyb20gXCIuLi9kYXRhL2RlY2tQYXJ0c1wiO1xuXG5jb25zdCBjb252ZXJ0RGVja1RvRmlsZSA9IGZ1bmN0aW9uIChkZWNrTGlzdCkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcblxuICAgIGRlY2tQYXJ0cy5mb3JFYWNoKGRlY2twYXJ0ID0+IHtcbiAgICAgICAgcmVzdWx0LnB1c2goZGVja3BhcnQuZmlsZUlkKTtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChkZWNrTGlzdFtkZWNrcGFydC5pZF0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiXFxuXCIpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY29udmVydERlY2tUb0ZpbGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IEZpbGVTYXZlciBmcm9tIFwiZmlsZS1zYXZlci9GaWxlU2F2ZXIuanNcIjtcblxuaW1wb3J0IGNvbnZlcnREZWNrVG9GaWxlIGZyb20gXCIuL2NvbnZlcnREZWNrVG9GaWxlLmpzXCI7XG5cbmNvbnN0IGZpbGVEb3dubG9hZERlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIGNvbnN0IGZpbGVEYXRhID0gY29udmVydERlY2tUb0ZpbGUodm0uZGVjay5saXN0KTtcbiAgICBjb25zdCBmaWxlID0gbmV3IEZpbGUoW2ZpbGVEYXRhXSwgdm0uZGVjay5uYW1lICsgXCIueWRrXCIsIHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0L3lka1wiXG4gICAgfSk7XG5cbiAgICByZXR1cm4gRmlsZVNhdmVyLnNhdmVBcyhmaWxlKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZpbGVEb3dubG9hZERlY2s7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHVyaUxvY2F0aW9uTm9QYXJhbSBmcm9tIFwiLi9tZXRob2RzL3VyaUxvY2F0aW9uTm9QYXJhbVwiO1xuXG5pbXBvcnQgYXBpTG9hZE5hbWVzIGZyb20gXCIuL21ldGhvZHMvYXBpTG9hZE5hbWVzXCI7XG5pbXBvcnQgYXBpTG9hZFByaWNlcyBmcm9tIFwiLi9tZXRob2RzL2FwaUxvYWRQcmljZXNcIjtcblxuaW1wb3J0IGRlY2tMb2FkIGZyb20gXCIuL21ldGhvZHMvZGVja0xvYWRcIjtcbmltcG9ydCBkZWNrTG9hZFVyaSBmcm9tIFwiLi9tZXRob2RzL2RlY2tMb2FkVXJpXCI7XG5pbXBvcnQgZGVja1VwZGF0ZSBmcm9tIFwiLi9tZXRob2RzL2RlY2tVcGRhdGVcIjtcbmltcG9ydCBkZWNrQ2FyZHNXaXRob3V0UHJpY2VEYXRhIGZyb20gXCIuL21ldGhvZHMvZGVja0NhcmRzV2l0aG91dFByaWNlRGF0YVwiO1xuXG5pbXBvcnQgcHJpY2VDb252ZXJ0IGZyb20gXCIuL21ldGhvZHMvcHJpY2VDb252ZXJ0XCI7XG5pbXBvcnQgcHJpY2VGb3JDYXJkIGZyb20gXCIuL21ldGhvZHMvcHJpY2VGb3JDYXJkXCI7XG5pbXBvcnQgcHJpY2VGb3JTZWN0aW9uIGZyb20gXCIuL21ldGhvZHMvcHJpY2VGb3JTZWN0aW9uXCI7XG5cbmltcG9ydCBidWlsZGVyVXBkYXRlTmFtZXMgZnJvbSBcIi4vbWV0aG9kcy9idWlsZGVyVXBkYXRlTmFtZXNcIjtcbmltcG9ydCBidWlsZGVyRGVja0FkZCBmcm9tIFwiLi9tZXRob2RzL2J1aWxkZXJEZWNrQWRkXCI7XG5pbXBvcnQgYnVpbGRlckRlY2tSZW1vdmUgZnJvbSBcIi4vbWV0aG9kcy9idWlsZGVyRGVja1JlbW92ZVwiO1xuXG5pbXBvcnQgZmlsZURvd25sb2FkRGVjayBmcm9tIFwiLi9tZXRob2RzL2ZpbGVEb3dubG9hZERlY2tcIjtcblxuY29uc3QgYXBwTWV0aG9kcyA9IHtcbiAgICB1cmlMb2NhdGlvbk5vUGFyYW0sXG5cbiAgICBhcGlMb2FkTmFtZXMsXG4gICAgYXBpTG9hZFByaWNlcyxcblxuICAgIGRlY2tMb2FkLFxuICAgIGRlY2tMb2FkVXJpLFxuICAgIGRlY2tVcGRhdGUsXG4gICAgZGVja0NhcmRzV2l0aG91dFByaWNlRGF0YSxcblxuICAgIHByaWNlQ29udmVydCxcbiAgICBwcmljZUZvckNhcmQsXG4gICAgcHJpY2VGb3JTZWN0aW9uLFxuXG4gICAgYnVpbGRlclVwZGF0ZU5hbWVzLFxuICAgIGJ1aWxkZXJEZWNrQWRkLFxuICAgIGJ1aWxkZXJEZWNrUmVtb3ZlLFxuXG4gICAgZmlsZURvd25sb2FkRGVjayxcblxuICAgIG9uRmlsZUNoYW5nZShlKSB7XG4gICAgICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICAgICAgY29uc3QgZmlsZXMgPSBlLnRhcmdldC5maWxlcyB8fCBlLmRhdGFUcmFuc2Zlci5maWxlcztcblxuICAgICAgICB2bS5kZWNrTG9hZChmaWxlc1swXSk7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgYXBwTWV0aG9kcztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgVnVlIGZyb20gXCJ2dWUvZGlzdC92dWUuZXNtLmpzXCI7XG5pbXBvcnQgYXBwRGF0YSBmcm9tIFwiLi9hcHBEYXRhXCI7XG5pbXBvcnQgYXBwTWV0aG9kcyBmcm9tIFwiLi9hcHBNZXRob2RzXCI7XG5cbi8vcmVhZHktZXZlbnQgcmVxdWlyZWQgYmVjYXVzZSB5Z29wcm9kZWNrLmNvbSBsb2FkcyBzY3JpcHRzIGluIGhlYWRcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsICgpID0+IHtcbiAgICBjb25zdCB1cmxRdWVyeSA9IGxvY2F0aW9uLnNlYXJjaDtcbiAgICBjb25zdCBwcmljZUFwcCA9IG5ldyBWdWUoe1xuICAgICAgICBlbDogXCIjYXBwXCIsXG4gICAgICAgIGRhdGE6IGFwcERhdGEsXG4gICAgICAgIG1ldGhvZHM6IGFwcE1ldGhvZHNcbiAgICB9KTtcblxuICAgIHByaWNlQXBwLmFwaUxvYWROYW1lcygpO1xuXG4gICAgaWYgKHVybFF1ZXJ5LmluZGV4T2YoXCI/ZFwiKSAhPT0gLTEpIHtcbiAgICAgICAgcHJpY2VBcHAuZGVja0xvYWRVcmkodXJsUXVlcnkpO1xuICAgIH1cbn0pO1xuIl0sIm5hbWVzIjpbIl90b1N0cmluZyIsInZhbCIsIkpTT04iLCJzdHJpbmdpZnkiLCJTdHJpbmciLCJ0b051bWJlciIsIm4iLCJwYXJzZUZsb2F0IiwiaXNOYU4iLCJtYWtlTWFwIiwic3RyIiwiZXhwZWN0c0xvd2VyQ2FzZSIsIm1hcCIsIk9iamVjdCIsImNyZWF0ZSIsImxpc3QiLCJzcGxpdCIsImkiLCJsZW5ndGgiLCJ0b0xvd2VyQ2FzZSIsInJlbW92ZSIsImFyciIsIml0ZW0iLCJpbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJoYXNPd24iLCJvYmoiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpc1ByaW1pdGl2ZSIsInZhbHVlIiwiY2FjaGVkIiwiZm4iLCJjYWNoZSIsImJpbmQiLCJjdHgiLCJib3VuZEZuIiwiYSIsImwiLCJhcmd1bWVudHMiLCJhcHBseSIsIl9sZW5ndGgiLCJ0b0FycmF5Iiwic3RhcnQiLCJyZXQiLCJBcnJheSIsImV4dGVuZCIsInRvIiwiX2Zyb20iLCJpc09iamVjdCIsImlzUGxhaW5PYmplY3QiLCJ0b1N0cmluZyIsIk9CSkVDVF9TVFJJTkciLCJ0b09iamVjdCIsInJlcyIsIm5vb3AiLCJsb29zZUVxdWFsIiwiYiIsImlzT2JqZWN0QSIsImlzT2JqZWN0QiIsImUiLCJsb29zZUluZGV4T2YiLCJvbmNlIiwiY2FsbGVkIiwiaXNSZXNlcnZlZCIsImMiLCJjaGFyQ29kZUF0IiwiZGVmIiwiZW51bWVyYWJsZSIsImRlZmluZVByb3BlcnR5IiwicGFyc2VQYXRoIiwicGF0aCIsImJhaWxSRSIsInRlc3QiLCJzZWdtZW50cyIsImlzTmF0aXZlIiwiQ3RvciIsInB1c2hUYXJnZXQiLCJfdGFyZ2V0IiwiRGVwIiwidGFyZ2V0IiwicHVzaCIsInBvcFRhcmdldCIsInRhcmdldFN0YWNrIiwicG9wIiwicHJvdG9BdWdtZW50Iiwic3JjIiwiX19wcm90b19fIiwiY29weUF1Z21lbnQiLCJrZXlzIiwib2JzZXJ2ZSIsImFzUm9vdERhdGEiLCJvYiIsIl9fb2JfXyIsIk9ic2VydmVyIiwib2JzZXJ2ZXJTdGF0ZSIsInNob3VsZENvbnZlcnQiLCJpc1NlcnZlclJlbmRlcmluZyIsImlzQXJyYXkiLCJpc0V4dGVuc2libGUiLCJfaXNWdWUiLCJ2bUNvdW50IiwiZGVmaW5lUmVhY3RpdmUkJDEiLCJjdXN0b21TZXR0ZXIiLCJkZXAiLCJwcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImNvbmZpZ3VyYWJsZSIsImdldHRlciIsImdldCIsInNldHRlciIsInNldCIsImNoaWxkT2IiLCJkZXBlbmQiLCJuZXdWYWwiLCJub3RpZnkiLCJNYXRoIiwibWF4IiwiZGVsIiwiZGVwZW5kQXJyYXkiLCJtZXJnZURhdGEiLCJmcm9tIiwidG9WYWwiLCJmcm9tVmFsIiwibWVyZ2VIb29rIiwicGFyZW50VmFsIiwiY2hpbGRWYWwiLCJjb25jYXQiLCJtZXJnZUFzc2V0cyIsIm5vcm1hbGl6ZVByb3BzIiwib3B0aW9ucyIsInByb3BzIiwibmFtZSIsImNhbWVsaXplIiwidHlwZSIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMiLCJkaXJzIiwiZGlyZWN0aXZlcyIsInVwZGF0ZSIsIm1lcmdlT3B0aW9ucyIsInBhcmVudCIsImNoaWxkIiwidm0iLCJtZXJnZUZpZWxkIiwic3RyYXQiLCJzdHJhdHMiLCJkZWZhdWx0U3RyYXQiLCJleHRlbmRzRnJvbSIsImV4dGVuZHMiLCJtaXhpbnMiLCJtaXhpbiIsInByb3RvdHlwZSIsIlZ1ZSQzIiwicmVzb2x2ZUFzc2V0IiwiaWQiLCJ3YXJuTWlzc2luZyIsImFzc2V0cyIsImNhbWVsaXplZElkIiwiUGFzY2FsQ2FzZUlkIiwiY2FwaXRhbGl6ZSIsInZhbGlkYXRlUHJvcCIsInByb3BPcHRpb25zIiwicHJvcHNEYXRhIiwicHJvcCIsImFic2VudCIsImlzVHlwZSIsIkJvb2xlYW4iLCJoeXBoZW5hdGUiLCJ1bmRlZmluZWQiLCJnZXRQcm9wRGVmYXVsdFZhbHVlIiwicHJldlNob3VsZENvbnZlcnQiLCJkZWZhdWx0IiwiJG9wdGlvbnMiLCJfcHJvcHMiLCJnZXRUeXBlIiwibWF0Y2giLCJsZW4iLCJoYW5kbGVFcnJvciIsImVyciIsImluZm8iLCJjb25maWciLCJlcnJvckhhbmRsZXIiLCJpbkJyb3dzZXIiLCJjb25zb2xlIiwiZXJyb3IiLCJjcmVhdGVUZXh0Vk5vZGUiLCJWTm9kZSIsImNsb25lVk5vZGUiLCJ2bm9kZSIsImNsb25lZCIsInRhZyIsImRhdGEiLCJjaGlsZHJlbiIsInRleHQiLCJlbG0iLCJjb250ZXh0IiwiY29tcG9uZW50T3B0aW9ucyIsIm5zIiwiaXNTdGF0aWMiLCJpc0Nsb25lZCIsImNsb25lVk5vZGVzIiwidm5vZGVzIiwiY3JlYXRlRm5JbnZva2VyIiwiZm5zIiwiaW52b2tlciIsImFyZ3VtZW50cyQxIiwidXBkYXRlTGlzdGVuZXJzIiwib24iLCJvbGRPbiIsImFkZCIsInJlbW92ZSQkMSIsImN1ciIsIm9sZCIsImV2ZW50Iiwibm9ybWFsaXplRXZlbnQiLCJjYXB0dXJlIiwibWVyZ2VWTm9kZUhvb2siLCJob29rS2V5IiwiaG9vayIsIndyYXBwZWRIb29rIiwidGhpcyIsIm9sZEhvb2siLCJtZXJnZWQiLCJzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQXJyYXlDaGlsZHJlbiIsIm5lc3RlZEluZGV4IiwibGFzdCIsImdldEZpcnN0Q29tcG9uZW50Q2hpbGQiLCJmaWx0ZXIiLCJpbml0RXZlbnRzIiwiX2V2ZW50cyIsIl9oYXNIb29rRXZlbnQiLCJsaXN0ZW5lcnMiLCJfcGFyZW50TGlzdGVuZXJzIiwib25jZSQkMSIsIiRvbmNlIiwiJG9uIiwicmVtb3ZlJDEiLCIkb2ZmIiwidXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIiwib2xkTGlzdGVuZXJzIiwicmVzb2x2ZVNsb3RzIiwic2xvdHMiLCJkZWZhdWx0U2xvdCIsImZ1bmN0aW9uYWxDb250ZXh0Iiwic2xvdCIsImV2ZXJ5IiwiaXNXaGl0ZXNwYWNlIiwibm9kZSIsImlzQ29tbWVudCIsInJlc29sdmVTY29wZWRTbG90cyIsImluaXRMaWZlY3ljbGUiLCJhYnN0cmFjdCIsIiRwYXJlbnQiLCIkY2hpbGRyZW4iLCIkcm9vdCIsIiRyZWZzIiwiX3dhdGNoZXIiLCJfaW5hY3RpdmUiLCJfZGlyZWN0SW5hY3RpdmUiLCJfaXNNb3VudGVkIiwiX2lzRGVzdHJveWVkIiwiX2lzQmVpbmdEZXN0cm95ZWQiLCJtb3VudENvbXBvbmVudCIsImVsIiwiaHlkcmF0aW5nIiwiJGVsIiwicmVuZGVyIiwiY3JlYXRlRW1wdHlWTm9kZSIsInVwZGF0ZUNvbXBvbmVudCIsIl91cGRhdGUiLCJfcmVuZGVyIiwiV2F0Y2hlciIsIiR2bm9kZSIsInVwZGF0ZUNoaWxkQ29tcG9uZW50IiwicGFyZW50Vm5vZGUiLCJyZW5kZXJDaGlsZHJlbiIsImhhc0NoaWxkcmVuIiwiX3JlbmRlckNoaWxkcmVuIiwic2NvcGVkU2xvdHMiLCIkc2NvcGVkU2xvdHMiLCJlbXB0eU9iamVjdCIsIl9wYXJlbnRWbm9kZSIsIl92bm9kZSIsInByb3BLZXlzIiwiX3Byb3BLZXlzIiwiJHNsb3RzIiwiJGZvcmNlVXBkYXRlIiwiaXNJbkluYWN0aXZlVHJlZSIsImFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJkaXJlY3QiLCJkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJjYWxsSG9vayIsImhhbmRsZXJzIiwiaiIsIiRlbWl0IiwicmVzZXRTY2hlZHVsZXJTdGF0ZSIsImZsdXNoaW5nIiwiZmx1c2hTY2hlZHVsZXJRdWV1ZSIsIndhdGNoZXIiLCJzb3J0IiwicXVldWUiLCJydW4iLCJvbGRRdWV1ZSIsInNsaWNlIiwiZGV2dG9vbHMiLCJlbWl0IiwicXVldWVXYXRjaGVyIiwiaGFzIiwid2FpdGluZyIsInRyYXZlcnNlIiwiY2xlYXIiLCJzZWVuT2JqZWN0cyIsIl90cmF2ZXJzZSIsInNlZW4iLCJpc0EiLCJkZXBJZCIsInByb3h5Iiwic291cmNlS2V5Iiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwiaW5pdFN0YXRlIiwiX3dhdGNoZXJzIiwib3B0cyIsIm1ldGhvZHMiLCJfZGF0YSIsImNvbXB1dGVkIiwid2F0Y2giLCJpbml0UHJvcHMiLCJwcm9wc09wdGlvbnMiLCJpc1Jvb3QiLCJpbml0RGF0YSIsImdldERhdGEiLCJpbml0Q29tcHV0ZWQiLCJ3YXRjaGVycyIsIl9jb21wdXRlZFdhdGNoZXJzIiwidXNlckRlZiIsImNvbXB1dGVkV2F0Y2hlck9wdGlvbnMiLCJkZWZpbmVDb21wdXRlZCIsImNyZWF0ZUNvbXB1dGVkR2V0dGVyIiwiZGlydHkiLCJldmFsdWF0ZSIsImluaXRNZXRob2RzIiwiaW5pdFdhdGNoIiwiaGFuZGxlciIsImNyZWF0ZVdhdGNoZXIiLCIkd2F0Y2giLCJjcmVhdGVDb21wb25lbnQiLCJiYXNlQ3RvciIsIl9iYXNlIiwiY2lkIiwicmVzb2x2ZWQiLCJyZXNvbHZlQXN5bmNDb21wb25lbnQiLCJtb2RlbCIsImV4dHJhY3RQcm9wcyIsImZ1bmN0aW9uYWwiLCJjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IiwibmF0aXZlT24iLCJfY29udGV4dCIsImgiLCJkIiwiY3JlYXRlRWxlbWVudCIsImNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUiLCJwYXJlbnRFbG0iLCJyZWZFbG0iLCJ2bm9kZUNvbXBvbmVudE9wdGlvbnMiLCJpbmxpbmVUZW1wbGF0ZSIsInN0YXRpY1JlbmRlckZucyIsImZhY3RvcnkiLCJjYiIsInJlcXVlc3RlZCIsImNicyIsInBlbmRpbmdDYWxsYmFja3MiLCJzeW5jIiwicmVzb2x2ZSIsInJlamVjdCIsInJlYXNvbiIsInRoZW4iLCJhdHRycyIsImRvbVByb3BzIiwiYWx0S2V5IiwiY2hlY2tQcm9wIiwiaGFzaCIsInByZXNlcnZlIiwibWVyZ2VIb29rcyIsImhvb2tzVG9NZXJnZSIsImZyb21QYXJlbnQiLCJvdXJzIiwiY29tcG9uZW50Vk5vZGVIb29rcyIsIm1lcmdlSG9vayQxIiwib25lIiwidHdvIiwidHJhbnNmb3JtTW9kZWwiLCJjYWxsYmFjayIsIm5vcm1hbGl6YXRpb25UeXBlIiwiYWx3YXlzTm9ybWFsaXplIiwiQUxXQVlTX05PUk1BTElaRSIsIl9jcmVhdGVFbGVtZW50IiwiU0lNUExFX05PUk1BTElaRSIsImdldFRhZ05hbWVzcGFjZSIsImlzUmVzZXJ2ZWRUYWciLCJwYXJzZVBsYXRmb3JtVGFnTmFtZSIsImFwcGx5TlMiLCJyZW5kZXJMaXN0IiwicmVuZGVyU2xvdCIsImZhbGxiYWNrIiwiYmluZE9iamVjdCIsInNjb3BlZFNsb3RGbiIsInNsb3ROb2RlcyIsInJlc29sdmVGaWx0ZXIiLCJpZGVudGl0eSIsImNoZWNrS2V5Q29kZXMiLCJldmVudEtleUNvZGUiLCJidWlsdEluQWxpYXMiLCJrZXlDb2RlcyIsImJpbmRPYmplY3RQcm9wcyIsImFzUHJvcCIsIm11c3RVc2VQcm9wIiwicmVuZGVyU3RhdGljIiwiaXNJbkZvciIsInRyZWUiLCJfc3RhdGljVHJlZXMiLCJfcmVuZGVyUHJveHkiLCJtYXJrT25jZSIsIm1hcmtTdGF0aWMiLCJpc09uY2UiLCJtYXJrU3RhdGljTm9kZSIsImluaXRSZW5kZXIiLCJyZW5kZXJDb250ZXh0IiwiX2MiLCIkY3JlYXRlRWxlbWVudCIsImluaXRQcm92aWRlIiwicHJvdmlkZSIsIl9wcm92aWRlZCIsImluaXRJbmplY3Rpb25zIiwiaW5qZWN0IiwiaGFzU3ltYm9sIiwiUmVmbGVjdCIsIm93bktleXMiLCJwcm92aWRlS2V5Iiwic291cmNlIiwiaW5pdEludGVybmFsQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJfY29tcG9uZW50VGFnIiwiX3BhcmVudEVsbSIsIl9yZWZFbG0iLCJyZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIiwic3VwZXIiLCJzdXBlck9wdGlvbnMiLCJtb2RpZmllZE9wdGlvbnMiLCJyZXNvbHZlTW9kaWZpZWRPcHRpb25zIiwiZXh0ZW5kT3B0aW9ucyIsImNvbXBvbmVudHMiLCJtb2RpZmllZCIsImxhdGVzdCIsInNlYWxlZCIsInNlYWxlZE9wdGlvbnMiLCJkZWR1cGUiLCJfaW5pdCIsImluaXRVc2UiLCJWdWUiLCJ1c2UiLCJwbHVnaW4iLCJpbnN0YWxsZWQiLCJhcmdzIiwidW5zaGlmdCIsImluc3RhbGwiLCJpbml0TWl4aW4kMSIsImluaXRFeHRlbmQiLCJTdXBlciIsIlN1cGVySWQiLCJjYWNoZWRDdG9ycyIsIl9DdG9yIiwiU3ViIiwiX2Fzc2V0VHlwZXMiLCJmb3JFYWNoIiwiaW5pdFByb3BzJDEiLCJDb21wIiwiaW5pdENvbXB1dGVkJDEiLCJpbml0QXNzZXRSZWdpc3RlcnMiLCJkZWZpbml0aW9uIiwiZ2V0Q29tcG9uZW50TmFtZSIsIm1hdGNoZXMiLCJwYXR0ZXJuIiwiUmVnRXhwIiwicHJ1bmVDYWNoZSIsImNhY2hlZE5vZGUiLCJwcnVuZUNhY2hlRW50cnkiLCJjb21wb25lbnRJbnN0YW5jZSIsIiRkZXN0cm95IiwiZ2VuQ2xhc3NGb3JWbm9kZSIsInBhcmVudE5vZGUiLCJjaGlsZE5vZGUiLCJtZXJnZUNsYXNzRGF0YSIsImdlbkNsYXNzRnJvbURhdGEiLCJzdGF0aWNDbGFzcyIsImNsYXNzIiwiZHluYW1pY0NsYXNzIiwic3RyaW5naWZ5Q2xhc3MiLCJzdHJpbmdpZmllZCIsImlzU1ZHIiwiaXNVbmtub3duRWxlbWVudCIsInVua25vd25FbGVtZW50Q2FjaGUiLCJkb2N1bWVudCIsIndpbmRvdyIsIkhUTUxVbmtub3duRWxlbWVudCIsIkhUTUxFbGVtZW50IiwicXVlcnkiLCJzZWxlY3RlZCIsInF1ZXJ5U2VsZWN0b3IiLCJjcmVhdGVFbGVtZW50JDEiLCJ0YWdOYW1lIiwibXVsdGlwbGUiLCJzZXRBdHRyaWJ1dGUiLCJjcmVhdGVFbGVtZW50TlMiLCJuYW1lc3BhY2UiLCJuYW1lc3BhY2VNYXAiLCJjcmVhdGVUZXh0Tm9kZSIsImNyZWF0ZUNvbW1lbnQiLCJpbnNlcnRCZWZvcmUiLCJuZXdOb2RlIiwicmVmZXJlbmNlTm9kZSIsInJlbW92ZUNoaWxkIiwiYXBwZW5kQ2hpbGQiLCJuZXh0U2libGluZyIsInNldFRleHRDb250ZW50IiwidGV4dENvbnRlbnQiLCJyZWdpc3RlclJlZiIsImlzUmVtb3ZhbCIsInJlZiIsInJlZnMiLCJyZWZJbkZvciIsImlzVW5kZWYiLCJ2IiwiaXNEZWYiLCJpc1RydWUiLCJzYW1lVm5vZGUiLCJzYW1lSW5wdXRUeXBlIiwiY3JlYXRlS2V5VG9PbGRJZHgiLCJiZWdpbklkeCIsImVuZElkeCIsInVwZGF0ZURpcmVjdGl2ZXMiLCJvbGRWbm9kZSIsIm9sZERpciIsImRpciIsImlzQ3JlYXRlIiwiZW1wdHlOb2RlIiwiaXNEZXN0cm95Iiwib2xkRGlycyIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMkMSIsIm5ld0RpcnMiLCJkaXJzV2l0aEluc2VydCIsImRpcnNXaXRoUG9zdHBhdGNoIiwib2xkVmFsdWUiLCJjb21wb25lbnRVcGRhdGVkIiwiaW5zZXJ0ZWQiLCJjYWxsSW5zZXJ0IiwibW9kaWZpZXJzIiwiZW1wdHlNb2RpZmllcnMiLCJnZXRSYXdEaXJOYW1lIiwicmF3TmFtZSIsImpvaW4iLCJjYWxsSG9vayQxIiwidXBkYXRlQXR0cnMiLCJvbGRBdHRycyIsImlzSUU5IiwiaXNYbGluayIsInJlbW92ZUF0dHJpYnV0ZU5TIiwieGxpbmtOUyIsImdldFhsaW5rUHJvcCIsImlzRW51bWVyYXRlZEF0dHIiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzZXRBdHRyIiwiaXNCb29sZWFuQXR0ciIsImlzRmFsc3lBdHRyVmFsdWUiLCJzZXRBdHRyaWJ1dGVOUyIsInVwZGF0ZUNsYXNzIiwib2xkRGF0YSIsImNscyIsInRyYW5zaXRpb25DbGFzcyIsIl90cmFuc2l0aW9uQ2xhc3NlcyIsIl9wcmV2Q2xhc3MiLCJwYXJzZUZpbHRlcnMiLCJleHAiLCJwdXNoRmlsdGVyIiwiZmlsdGVycyIsImxhc3RGaWx0ZXJJbmRleCIsInRyaW0iLCJwcmV2IiwiZXhwcmVzc2lvbiIsImluU2luZ2xlIiwiaW5Eb3VibGUiLCJpblRlbXBsYXRlU3RyaW5nIiwiaW5SZWdleCIsImN1cmx5Iiwic3F1YXJlIiwicGFyZW4iLCJwIiwiY2hhckF0IiwidmFsaWREaXZpc2lvbkNoYXJSRSIsIndyYXBGaWx0ZXIiLCJiYXNlV2FybiIsIm1zZyIsInBsdWNrTW9kdWxlRnVuY3Rpb24iLCJtb2R1bGVzIiwibSIsIl8iLCJhZGRQcm9wIiwiYWRkQXR0ciIsImFkZERpcmVjdGl2ZSIsImFyZyIsImFkZEhhbmRsZXIiLCJpbXBvcnRhbnQiLCJldmVudHMiLCJuYXRpdmUiLCJuYXRpdmVFdmVudHMiLCJuZXdIYW5kbGVyIiwiZ2V0QmluZGluZ0F0dHIiLCJnZXRTdGF0aWMiLCJkeW5hbWljVmFsdWUiLCJnZXRBbmRSZW1vdmVBdHRyIiwic3RhdGljVmFsdWUiLCJhdHRyc01hcCIsImF0dHJzTGlzdCIsImdlbkNvbXBvbmVudE1vZGVsIiwibnVtYmVyIiwidmFsdWVFeHByZXNzaW9uIiwiYXNzaWdubWVudCIsImdlbkFzc2lnbm1lbnRDb2RlIiwibW9kZWxScyIsInBhcnNlTW9kZWwiLCJpZHgiLCJleHByZXNzaW9uUG9zIiwiZXhwcmVzc2lvbkVuZFBvcyIsImxhc3RJbmRleE9mIiwiZW9mIiwibmV4dCIsImlzU3RyaW5nU3RhcnQiLCJjaHIiLCJzdWJzdHJpbmciLCJpbmRleCQxIiwicGFyc2VCcmFja2V0IiwiaW5CcmFja2V0IiwicGFyc2VTdHJpbmciLCJzdHJpbmdRdW90ZSIsIl93YXJuIiwiZ2VuQ2hlY2tib3hNb2RlbCIsInZhbHVlQmluZGluZyIsInRydWVWYWx1ZUJpbmRpbmciLCJmYWxzZVZhbHVlQmluZGluZyIsIkNIRUNLQk9YX1JBRElPX1RPS0VOIiwiZ2VuUmFkaW9Nb2RlbCIsImdlblNlbGVjdCIsInNlbGVjdGVkVmFsIiwiY29kZSIsImdlbkRlZmF1bHRNb2RlbCIsImxhenkiLCJuZWVkQ29tcG9zaXRpb25HdWFyZCIsIlJBTkdFX1RPS0VOIiwibm9ybWFsaXplRXZlbnRzIiwiaXNJRSIsImlzQ2hyb21lIiwiYWRkJDEiLCJvbGRIYW5kbGVyIiwidGFyZ2V0JDEiLCJldiIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmUkMiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1cGRhdGVET01MaXN0ZW5lcnMiLCJ1cGRhdGVET01Qcm9wcyIsIm9sZFByb3BzIiwiX3ZhbHVlIiwic3RyQ3VyIiwic2hvdWxkVXBkYXRlVmFsdWUiLCJjaGVja1ZhbCIsImNvbXBvc2luZyIsImlzRGlydHkiLCJpc0lucHV0Q2hhbmdlZCIsImFjdGl2ZUVsZW1lbnQiLCJfdk1vZGlmaWVycyIsIm5vcm1hbGl6ZVN0eWxlRGF0YSIsInN0eWxlIiwibm9ybWFsaXplU3R5bGVCaW5kaW5nIiwic3RhdGljU3R5bGUiLCJiaW5kaW5nU3R5bGUiLCJwYXJzZVN0eWxlVGV4dCIsImdldFN0eWxlIiwiY2hlY2tDaGlsZCIsInN0eWxlRGF0YSIsInVwZGF0ZVN0eWxlIiwib2xkU3RhdGljU3R5bGUiLCJvbGRTdHlsZUJpbmRpbmciLCJvbGRTdHlsZSIsIm5ld1N0eWxlIiwiYWRkQ2xhc3MiLCJjbGFzc0xpc3QiLCJnZXRBdHRyaWJ1dGUiLCJyZW1vdmVDbGFzcyIsInRhciIsInJlcGxhY2UiLCJyZXNvbHZlVHJhbnNpdGlvbiIsImRlZiQkMSIsImNzcyIsImF1dG9Dc3NUcmFuc2l0aW9uIiwibmV4dEZyYW1lIiwiYWRkVHJhbnNpdGlvbkNsYXNzIiwicmVtb3ZlVHJhbnNpdGlvbkNsYXNzIiwid2hlblRyYW5zaXRpb25FbmRzIiwiZXhwZWN0ZWRUeXBlIiwiZ2V0VHJhbnNpdGlvbkluZm8iLCJ0aW1lb3V0IiwicHJvcENvdW50IiwiVFJBTlNJVElPTiIsInRyYW5zaXRpb25FbmRFdmVudCIsImFuaW1hdGlvbkVuZEV2ZW50IiwiZW5kZWQiLCJlbmQiLCJvbkVuZCIsInN0eWxlcyIsImdldENvbXB1dGVkU3R5bGUiLCJ0cmFuc2l0aW9uRGVsYXlzIiwidHJhbnNpdGlvblByb3AiLCJ0cmFuc2l0aW9uRHVyYXRpb25zIiwidHJhbnNpdGlvblRpbWVvdXQiLCJnZXRUaW1lb3V0IiwiYW5pbWF0aW9uRGVsYXlzIiwiYW5pbWF0aW9uUHJvcCIsImFuaW1hdGlvbkR1cmF0aW9ucyIsImFuaW1hdGlvblRpbWVvdXQiLCJBTklNQVRJT04iLCJ0cmFuc2Zvcm1SRSIsImRlbGF5cyIsImR1cmF0aW9ucyIsInRvTXMiLCJzIiwiTnVtYmVyIiwiZW50ZXIiLCJ0b2dnbGVEaXNwbGF5IiwiX2xlYXZlQ2IiLCJjYW5jZWxsZWQiLCJ0cmFuc2l0aW9uIiwiX2VudGVyQ2IiLCJub2RlVHlwZSIsImVudGVyQ2xhc3MiLCJlbnRlclRvQ2xhc3MiLCJlbnRlckFjdGl2ZUNsYXNzIiwiYXBwZWFyQ2xhc3MiLCJhcHBlYXJUb0NsYXNzIiwiYXBwZWFyQWN0aXZlQ2xhc3MiLCJiZWZvcmVFbnRlciIsImFmdGVyRW50ZXIiLCJlbnRlckNhbmNlbGxlZCIsImJlZm9yZUFwcGVhciIsImFwcGVhciIsImFmdGVyQXBwZWFyIiwiYXBwZWFyQ2FuY2VsbGVkIiwiZHVyYXRpb24iLCJhY3RpdmVJbnN0YW5jZSIsInRyYW5zaXRpb25Ob2RlIiwiaXNBcHBlYXIiLCJpc1Jvb3RJbnNlcnQiLCJzdGFydENsYXNzIiwiYWN0aXZlQ2xhc3MiLCJ0b0NsYXNzIiwiYmVmb3JlRW50ZXJIb29rIiwiZW50ZXJIb29rIiwiYWZ0ZXJFbnRlckhvb2siLCJlbnRlckNhbmNlbGxlZEhvb2siLCJleHBsaWNpdEVudGVyRHVyYXRpb24iLCJleHBlY3RzQ1NTIiwidXNlcldhbnRzQ29udHJvbCIsImdldEhvb2tBcmd1bWVudHNMZW5ndGgiLCJzaG93IiwicGVuZGluZ05vZGUiLCJfcGVuZGluZyIsImlzVmFsaWREdXJhdGlvbiIsImxlYXZlIiwicm0iLCJwZXJmb3JtTGVhdmUiLCJiZWZvcmVMZWF2ZSIsImxlYXZlQ2xhc3MiLCJsZWF2ZUFjdGl2ZUNsYXNzIiwibGVhdmVUb0NsYXNzIiwiZXhwbGljaXRMZWF2ZUR1cmF0aW9uIiwiYWZ0ZXJMZWF2ZSIsImxlYXZlQ2FuY2VsbGVkIiwiZGVsYXlMZWF2ZSIsImludm9rZXJGbnMiLCJfZW50ZXIiLCJzZXRTZWxlY3RlZCIsImJpbmRpbmciLCJpc011bHRpcGxlIiwib3B0aW9uIiwiZ2V0VmFsdWUiLCJzZWxlY3RlZEluZGV4IiwiaGFzTm9NYXRjaGluZ09wdGlvbiIsIm9uQ29tcG9zaXRpb25TdGFydCIsIm9uQ29tcG9zaXRpb25FbmQiLCJ0cmlnZ2VyIiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwibG9jYXRlTm9kZSIsImdldFJlYWxDaGlsZCIsImNvbXBPcHRpb25zIiwiZXh0cmFjdFRyYW5zaXRpb25EYXRhIiwiY29tcCIsImtleSQxIiwicGxhY2Vob2xkZXIiLCJyYXdDaGlsZCIsImhhc1BhcmVudFRyYW5zaXRpb24iLCJpc1NhbWVDaGlsZCIsIm9sZENoaWxkIiwiY2FsbFBlbmRpbmdDYnMiLCJfbW92ZUNiIiwicmVjb3JkUG9zaXRpb24iLCJuZXdQb3MiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJhcHBseVRyYW5zbGF0aW9uIiwib2xkUG9zIiwicG9zIiwiZHgiLCJsZWZ0IiwiZHkiLCJ0b3AiLCJtb3ZlZCIsInRyYW5zZm9ybSIsIldlYmtpdFRyYW5zZm9ybSIsInRyYW5zaXRpb25EdXJhdGlvbiIsImRlY29kZSIsImh0bWwiLCJkZWNvZGVyIiwiaW5uZXJIVE1MIiwiZGVjb2RlQXR0ciIsInNob3VsZERlY29kZU5ld2xpbmVzIiwicmUiLCJlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyIsImVuY29kZWRBdHRyIiwiZGVjb2RpbmdNYXAiLCJwYXJzZUhUTUwiLCJhZHZhbmNlIiwicGFyc2VFbmRUYWciLCJsb3dlckNhc2VkVGFnTmFtZSIsInN0YWNrIiwibG93ZXJDYXNlZFRhZyIsImxhc3RUYWciLCJleHBlY3RIVE1MIiwiaXNVbmFyeVRhZyQkMSIsImlzVW5hcnlUYWciLCJubyIsImNhbkJlTGVmdE9wZW5UYWckJDEiLCJjYW5CZUxlZnRPcGVuVGFnIiwiaXNQbGFpblRleHRFbGVtZW50Iiwic3RhY2tlZFRhZyIsInJlU3RhY2tlZFRhZyIsInJlQ2FjaGUiLCJlbmRUYWdMZW5ndGgiLCJyZXN0IiwiYWxsIiwiZW5kVGFnIiwiY2hhcnMiLCJ0ZXh0RW5kIiwiY29tbWVudCIsImNvbW1lbnRFbmQiLCJjb25kaXRpb25hbENvbW1lbnQiLCJjb25kaXRpb25hbEVuZCIsImRvY3R5cGVNYXRjaCIsImRvY3R5cGUiLCJlbmRUYWdNYXRjaCIsImN1ckluZGV4Iiwic3RhcnRUYWdNYXRjaCIsInN0YXJ0VGFnT3BlbiIsImF0dHIiLCJzdGFydFRhZ0Nsb3NlIiwiYXR0cmlidXRlIiwidW5hcnlTbGFzaCIsImlzTm9uUGhyYXNpbmdUYWciLCJ1bmFyeSIsIklTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4iLCJyZXN0JDEiLCJwYXJzZVRleHQiLCJkZWxpbWl0ZXJzIiwidGFnUkUiLCJidWlsZFJlZ2V4IiwiZGVmYXVsdFRhZ1JFIiwidG9rZW5zIiwibGFzdEluZGV4IiwiZXhlYyIsInBhcnNlIiwidGVtcGxhdGUiLCJlbmRQcmUiLCJlbGVtZW50IiwicHJlIiwicGxhdGZvcm1Jc1ByZVRhZyIsIndhcm4iLCJpc1ByZVRhZyIsInJvb3QiLCJjdXJyZW50UGFyZW50IiwicHJlc2VydmVXaGl0ZXNwYWNlIiwiaW5WUHJlIiwiaW5QcmUiLCJ3YXJuJDIiLCJwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSIsImd1YXJkSUVTVkdCdWciLCJtYWtlQXR0cnNNYXAiLCJpc0ZvcmJpZGRlblRhZyIsImZvcmJpZGRlbiIsInByZVRyYW5zZm9ybXMiLCJwbGFpbiIsImkkMSIsInRyYW5zZm9ybXMiLCJpZiIsImVsc2VpZiIsImVsc2UiLCJzbG90U2NvcGUiLCJzbG90VGFyZ2V0IiwiaSQyIiwicG9zdFRyYW5zZm9ybXMiLCJsYXN0Tm9kZSIsImRlY29kZUhUTUxDYWNoZWQiLCJwcm9jZXNzUHJlIiwicHJvY2Vzc1Jhd0F0dHJzIiwicHJvY2Vzc0tleSIsInByb2Nlc3NSZWYiLCJjaGVja0luRm9yIiwicHJvY2Vzc0ZvciIsImluTWF0Y2giLCJmb3JBbGlhc1JFIiwiZm9yIiwiYWxpYXMiLCJpdGVyYXRvck1hdGNoIiwiZm9ySXRlcmF0b3JSRSIsIml0ZXJhdG9yMSIsIml0ZXJhdG9yMiIsInByb2Nlc3NJZiIsInByb2Nlc3NJZkNvbmRpdGlvbnMiLCJmaW5kUHJldkVsZW1lbnQiLCJhZGRJZkNvbmRpdGlvbiIsImNvbmRpdGlvbiIsImlmQ29uZGl0aW9ucyIsInByb2Nlc3NPbmNlIiwicHJvY2Vzc1Nsb3QiLCJzbG90TmFtZSIsInByb2Nlc3NDb21wb25lbnQiLCJjb21wb25lbnQiLCJwcm9jZXNzQXR0cnMiLCJpc1Byb3AiLCJkaXJSRSIsImhhc0JpbmRpbmdzIiwicGFyc2VNb2RpZmllcnMiLCJtb2RpZmllclJFIiwiYmluZFJFIiwiY2FtZWwiLCJwbGF0Zm9ybU11c3RVc2VQcm9wIiwib25SRSIsImFyZ01hdGNoIiwiYXJnUkUiLCJpZU5TQnVnIiwiaWVOU1ByZWZpeCIsIm9wdGltaXplIiwiZ2VuU3RhdGljS2V5c0NhY2hlZCIsInN0YXRpY0tleXMiLCJnZW5TdGF0aWNLZXlzJDEiLCJtYXJrU3RhdGljJDEiLCJzdGF0aWMiLCJpc1BsYXRmb3JtUmVzZXJ2ZWRUYWciLCJtYXJrU3RhdGljUm9vdHMiLCJzdGF0aWNJbkZvciIsInN0YXRpY1Jvb3QiLCJ3YWxrVGhyb3VnaENvbmRpdGlvbnNCbG9ja3MiLCJjb25kaXRpb25CbG9ja3MiLCJibG9jayIsImlzQnVpbHRJblRhZyIsImlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIiwiaXNTdGF0aWNLZXkiLCJnZW5IYW5kbGVycyIsImdlbkhhbmRsZXIiLCJpc01ldGhvZFBhdGgiLCJzaW1wbGVQYXRoUkUiLCJpc0Z1bmN0aW9uRXhwcmVzc2lvbiIsImZuRXhwUkUiLCJnZW5Nb2RpZmllckNvZGUiLCJtb2RpZmllckNvZGUiLCJnZW5LZXlGaWx0ZXIiLCJnZW5GaWx0ZXJDb2RlIiwia2V5VmFsIiwicGFyc2VJbnQiLCJiaW5kJDEiLCJ3cmFwRGF0YSIsImdlbmVyYXRlIiwiYXN0IiwicHJldlN0YXRpY1JlbmRlckZucyIsImN1cnJlbnRTdGF0aWNSZW5kZXJGbnMiLCJwcmV2T25jZUNvdW50Iiwib25jZUNvdW50IiwiZ2VuRWxlbWVudCIsInN0YXRpY1Byb2Nlc3NlZCIsImdlblN0YXRpYyIsIm9uY2VQcm9jZXNzZWQiLCJnZW5PbmNlIiwiZm9yUHJvY2Vzc2VkIiwiZ2VuRm9yIiwiaWZQcm9jZXNzZWQiLCJnZW5JZiIsImdlblNsb3QiLCJnZW5Db21wb25lbnQiLCJnZW5EYXRhIiwiZ2VuQ2hpbGRyZW4iLCJ0cmFuc2Zvcm1zJDEiLCJnZW5JZkNvbmRpdGlvbnMiLCJjb25kaXRpb25zIiwiZ2VuVGVybmFyeUV4cCIsInNoaWZ0IiwiZ2VuRGlyZWN0aXZlcyIsImRhdGFHZW5GbnMiLCJnZW5Qcm9wcyIsImdlblNjb3BlZFNsb3RzIiwiZ2VuSW5saW5lVGVtcGxhdGUiLCJuZWVkUnVudGltZSIsImhhc1J1bnRpbWUiLCJnZW4iLCJwbGF0Zm9ybURpcmVjdGl2ZXMkMSIsImJhc2VEaXJlY3RpdmVzIiwid2FybiQzIiwiaW5saW5lUmVuZGVyRm5zIiwiY3VycmVudE9wdGlvbnMiLCJnZW5TY29wZWRTbG90Iiwic2NvcGUiLCJjaGVja1NraXAiLCJlbCQxIiwiZ2V0Tm9ybWFsaXphdGlvblR5cGUiLCJnZW5Ob2RlIiwibmVlZHNOb3JtYWxpemF0aW9uIiwic29tZSIsIm1heWJlQ29tcG9uZW50IiwiaXNQbGF0Zm9ybVJlc2VydmVkVGFnJDEiLCJnZW5UZXh0IiwidHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzIiwiYmluZCQkMSIsImNvbXBvbmVudE5hbWUiLCJiYXNlQ29tcGlsZSIsIm1ha2VGdW5jdGlvbiIsImVycm9ycyIsIkZ1bmN0aW9uIiwidHJhbnNmb3JtTm9kZSIsImNsYXNzQmluZGluZyIsImdlbkRhdGEkMSIsInRyYW5zZm9ybU5vZGUkMSIsInN0eWxlQmluZGluZyIsImdlbkRhdGEkMiIsImdldE91dGVySFRNTCIsIm91dGVySFRNTCIsImNvbnRhaW5lciIsImNsb25lTm9kZSIsIl9pc1NlcnZlciIsIl9TZXQiLCJ0b1VwcGVyQ2FzZSIsImZyZWV6ZSIsImhhc1Byb3RvIiwiVUEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0VkZ2UiLCJpc0FuZHJvaWQiLCJpc0lPUyIsImdsb2JhbCIsImVudiIsIlZVRV9FTlYiLCJfX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiU3ltYm9sIiwibmV4dFRpY2siLCJuZXh0VGlja0hhbmRsZXIiLCJjb3BpZXMiLCJjYWxsYmFja3MiLCJ0aW1lckZ1bmMiLCJwZW5kaW5nIiwiUHJvbWlzZSIsImxvZ0Vycm9yIiwiY2F0Y2giLCJNdXRhdGlvbk9ic2VydmVyIiwiY291bnRlciIsIm9ic2VydmVyIiwidGV4dE5vZGUiLCJfcmVzb2x2ZSIsIlNldCIsInVpZCQxIiwic3VicyIsImFkZFN1YiIsInN1YiIsInJlbW92ZVN1YiIsImFkZERlcCIsImFycmF5UHJvdG8iLCJhcnJheU1ldGhvZHMiLCJtZXRob2QiLCJvcmlnaW5hbCIsInJlc3VsdCIsIm9ic2VydmVBcnJheSIsImFycmF5S2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJ3YWxrIiwiaXRlbXMiLCJvcHRpb25NZXJnZVN0cmF0ZWdpZXMiLCJpbnN0YW5jZURhdGEiLCJkZWZhdWx0RGF0YSIsIl9saWZlY3ljbGVIb29rcyIsInJhdyIsInByb3RvdHlwZUFjY2Vzc29ycyIsImRlZmluZVByb3BlcnRpZXMiLCJ1aWQkMiIsImV4cE9yRm4iLCJkZWVwIiwidXNlciIsImFjdGl2ZSIsImRlcHMiLCJuZXdEZXBzIiwiZGVwSWRzIiwibmV3RGVwSWRzIiwiY2xlYW51cERlcHMiLCJ0aGlzJDEiLCJ0bXAiLCJ0ZWFyZG93biIsIiRtb3VudCIsImtlZXBBbGl2ZSIsIm1vdW50ZWROb2RlIiwicHJlcGF0Y2giLCJ1aWQiLCJfdWlkIiwiX2lzQ29tcG9uZW50IiwiX3NlbGYiLCJkYXRhRGVmIiwicHJvcHNEZWYiLCIkc2V0IiwiJGRlbGV0ZSIsImltbWVkaWF0ZSIsImhvb2tSRSIsInByZXZFbCIsInByZXZWbm9kZSIsInByZXZBY3RpdmVJbnN0YW5jZSIsIl9fcGF0Y2hfXyIsIl9fdnVlX18iLCIkbmV4dFRpY2siLCJfbyIsIl9uIiwiX3MiLCJfbCIsIl90IiwiX3EiLCJfaSIsIl9tIiwiX2YiLCJfayIsIl9iIiwiX3YiLCJfZSIsIl91IiwicGF0dGVyblR5cGVzIiwiS2VlcEFsaXZlIiwiaW5jbHVkZSIsImV4Y2x1ZGUiLCJidWlsdEluQ29tcG9uZW50cyIsImNvbmZpZ0RlZiIsInV0aWwiLCJkZWxldGUiLCJ2ZXJzaW9uIiwid2FybiQxIiwidGVzdEVsIiwiYWNjZXB0VmFsdWUiLCJpc0hUTUxUYWciLCJub2RlT3BzIiwiaG9va3MiLCJiYXNlTW9kdWxlcyIsImtsYXNzIiwiY3NzVGV4dCIsImNzc1ZhclJFIiwiaW1wb3J0YW50UkUiLCJzZXRQcm9wIiwic2V0UHJvcGVydHkiLCJub3JtYWxpemUiLCJwcmVmaXhlcyIsInVwcGVyIiwicHJlZml4ZWQiLCJoYXNUcmFuc2l0aW9uIiwib250cmFuc2l0aW9uZW5kIiwib253ZWJraXR0cmFuc2l0aW9uZW5kIiwib25hbmltYXRpb25lbmQiLCJvbndlYmtpdGFuaW1hdGlvbmVuZCIsInJhZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInNldFRpbWVvdXQiLCJwbGF0Zm9ybU1vZHVsZXMiLCJwYXRjaCIsImJhY2tlbmQiLCJlbXB0eU5vZGVBdCIsImNyZWF0ZVJtQ2IiLCJjaGlsZEVsbSIsInJlbW92ZU5vZGUiLCJjcmVhdGVFbG0iLCJpbnNlcnRlZFZub2RlUXVldWUiLCJuZXN0ZWQiLCJpc1JlYWN0aXZhdGVkIiwiaW5pdCIsImluaXRDb21wb25lbnQiLCJwZW5kaW5nSW5zZXJ0IiwiaXNQYXRjaGFibGUiLCJyZWFjdGl2YXRlQ29tcG9uZW50IiwiaW5uZXJOb2RlIiwiYWN0aXZhdGUiLCJpbnNlcnQiLCJjcmVhdGVDaGlsZHJlbiIsImludm9rZUNyZWF0ZUhvb2tzIiwic2V0U2NvcGUiLCJhbmNlc3RvciIsIl9zY29wZUlkIiwiYWRkVm5vZGVzIiwic3RhcnRJZHgiLCJpbnZva2VEZXN0cm95SG9vayIsImRlc3Ryb3kiLCJyZW1vdmVWbm9kZXMiLCJjaCIsInJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2siLCJ1cGRhdGVDaGlsZHJlbiIsIm9sZENoIiwibmV3Q2giLCJyZW1vdmVPbmx5Iiwib2xkS2V5VG9JZHgiLCJpZHhJbk9sZCIsImVsbVRvTW92ZSIsIm9sZFN0YXJ0SWR4IiwibmV3U3RhcnRJZHgiLCJvbGRFbmRJZHgiLCJvbGRTdGFydFZub2RlIiwib2xkRW5kVm5vZGUiLCJuZXdFbmRJZHgiLCJuZXdTdGFydFZub2RlIiwibmV3RW5kVm5vZGUiLCJjYW5Nb3ZlIiwicGF0Y2hWbm9kZSIsInBvc3RwYXRjaCIsImludm9rZUluc2VydEhvb2siLCJpbml0aWFsIiwiaHlkcmF0ZSIsImhhc0NoaWxkTm9kZXMiLCJjaGlsZHJlbk1hdGNoIiwiZmlyc3RDaGlsZCIsImlzUmVuZGVyZWRNb2R1bGUiLCJpc0luaXRpYWxQYXRjaCIsImlzUmVhbEVsZW1lbnQiLCJoYXNBdHRyaWJ1dGUiLCJvbGRFbG0iLCJwYXJlbnRFbG0kMSIsInZtb2RlbCIsIm1vZGVsJDEiLCJvcmlnaW5hbERpc3BsYXkiLCJfX3ZPcmlnaW5hbERpc3BsYXkiLCJkaXNwbGF5IiwicGxhdGZvcm1EaXJlY3RpdmVzIiwidHJhbnNpdGlvblByb3BzIiwiVHJhbnNpdGlvbiIsIm1vZGUiLCJfbGVhdmluZyIsIm9sZFJhd0NoaWxkIiwiZGVsYXllZExlYXZlIiwiVHJhbnNpdGlvbkdyb3VwIiwicHJldkNoaWxkcmVuIiwicmF3Q2hpbGRyZW4iLCJ0cmFuc2l0aW9uRGF0YSIsImtlcHQiLCJyZW1vdmVkIiwiYyQxIiwibW92ZUNsYXNzIiwiaGFzTW92ZSIsImJvZHkiLCJvZmZzZXRIZWlnaHQiLCJwcm9wZXJ0eU5hbWUiLCJfaGFzTW92ZSIsImNsb25lIiwiaGFzVHJhbnNmb3JtIiwicGxhdGZvcm1Db21wb25lbnRzIiwiY29udGVudCIsImVuY29kZWQiLCJkaXYiLCJzaW5nbGVBdHRyVmFsdWVzIiwibmNuYW1lIiwiZyIsIm9wZW4iLCJjbG9zZSIsImdlbkd1YXJkIiwia2xhc3MkMSIsInN0eWxlJDEiLCJtb2R1bGVzJDEiLCJkaXJlY3RpdmVzJDEiLCJiYXNlT3B0aW9ucyIsInJlZHVjZSIsInJlZiQxIiwiY29tcGlsZSIsImZpbmFsT3B0aW9ucyIsInRpcHMiLCJ0aXAkJDEiLCJjb21waWxlZCIsImNvbXBpbGVUb0Z1bmN0aW9ucyIsImZ1bmN0aW9uQ29tcGlsZUNhY2hlIiwiZm5HZW5FcnJvcnMiLCJpZFRvVGVtcGxhdGUiLCJtb3VudCIsImRvY3VtZW50RWxlbWVudCIsInByaWNlQ3VycmVuY2llcyIsInByaWNlTW9kZXMiLCJkZWNrUGFydHMiLCJhcHBEYXRhIiwiZGF0YURlY2tQYXJ0cyIsImRhdGFQcmljZU1vZGVzIiwiZGF0YVByaWNlQ3VycmVuY2llcyIsInVyaUxvY2F0aW9uTm9QYXJhbSIsImxvY2F0aW9uIiwib3JpZ2luIiwicGF0aG5hbWUiLCJlYWNoT2JqZWN0Iiwib2JqZWN0IiwiY3VycmVudEtleSIsImFwaUxvYWROYW1lcyIsImFqYXgiLCJjdXJyZW50bHlMb2FkaW5nIiwibmFtZXNMb2FkZWQiLCJyZXNwb25zZSIsImpzb24iLCJyZXN1bHREYXRhIiwicmVzdWx0UGFpcnMiLCJuYW1lU3RvcmFnZSIsImltYWdlQVBJIiwiZW5jb2RlVVJJIiwiY2FyZHMiLCJwYWlycyIsImxvY2FsZUNvbXBhcmUiLCJidWlsZGVyVXBkYXRlTmFtZXMiLCJhcGlMb2FkUHJpY2VzIiwiY2FyZElkcyIsImRlY2tDYXJkc1dpdGhvdXRQcmljZURhdGEiLCJjYXJkTmFtZXMiLCJjYXJkSWQiLCJwcmljZVF1ZXJ5IiwiYnRvYSIsInByaWNlc0xvYWRlZCIsInByaWNlRGF0YSIsImNhcmQiLCJwcmljZSIsImxvdyIsImF2ZXJhZ2UiLCJoaWdoIiwiY29udmVydEZpbGVUb0RlY2siLCJmaWxlQ29udGVudCIsImZpbGVDb250ZW50VHJpbW1lZCIsImFyclBhcnRzIiwicGFydCIsImxpbmUiLCJkZWNrcGFydCIsImRlY2tMb2FkIiwiZmlsZSIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJkZWNrTGlzdCIsImRlY2siLCJkZWNrVXBkYXRlIiwicmVhZEFzVGV4dCIsInVyaURlY2tEZWNvZGUiLCJkZWNrVXJpIiwiZGVja0FycmF5IiwiYXRvYiIsImRlY2tMb2FkVXJpIiwidXJpRGVjayIsInVyaURlY2tFbmNvZGUiLCJ2YWx1ZXMiLCJkZWNrTGluayIsImxpbmsiLCJwcmljZUNvbnZlcnQiLCJjdXJyZW5jeSIsImN1cnJlbmNpZXMiLCJmaW5kIiwiYWN0aXZlQ3VycmVuY3kiLCJ0b0ZpeGVkIiwibGFiZWwiLCJwcmljZUZvckNhcmQiLCJwcmljZUZvclNlY3Rpb24iLCJzZWN0aW9uIiwicHJpY2VTdW0iLCJjYXJkRGF0YSIsImJ1aWxkZXIiLCJwYWlyc0ZpbHRlcmVkIiwiYnVpbGRlckRlY2tBZGQiLCJkZWNrUGFydCIsImRlY2tQYXJ0TWF4IiwiZGVja3BhcnRzIiwic2l6ZSIsImJ1aWxkZXJEZWNrUmVtb3ZlIiwiZm91bmRDYXJkIiwic2F2ZUFzIiwidmlldyIsImRvYyIsImdldF9VUkwiLCJVUkwiLCJ3ZWJraXRVUkwiLCJzYXZlX2xpbmsiLCJjYW5fdXNlX3NhdmVfbGluayIsImNsaWNrIiwiTW91c2VFdmVudCIsImlzX3NhZmFyaSIsInNhZmFyaSIsImlzX2Nocm9tZV9pb3MiLCJ0aHJvd19vdXRzaWRlIiwiZXgiLCJzZXRJbW1lZGlhdGUiLCJyZXZva2UiLCJyZXZva2VyIiwicmV2b2tlT2JqZWN0VVJMIiwiZGlzcGF0Y2giLCJmaWxlc2F2ZXIiLCJldmVudF90eXBlcyIsImxpc3RlbmVyIiwiYXV0b19ib20iLCJibG9iIiwiQmxvYiIsImZyb21DaGFyQ29kZSIsIkZpbGVTYXZlciIsIm5vX2F1dG9fYm9tIiwib2JqZWN0X3VybCIsImZvcmNlIiwiZGlzcGF0Y2hfYWxsIiwicmVhZHlTdGF0ZSIsIklOSVQiLCJjcmVhdGVPYmplY3RVUkwiLCJocmVmIiwiZG93bmxvYWQiLCJET05FIiwib25sb2FkZW5kIiwidXJsIiwicmVhZEFzRGF0YVVSTCIsIkZTX3Byb3RvIiwibXNTYXZlT3JPcGVuQmxvYiIsImFib3J0IiwiV1JJVElORyIsIm9ud3JpdGVzdGFydCIsIm9ucHJvZ3Jlc3MiLCJvbndyaXRlIiwib25hYm9ydCIsIm9uZXJyb3IiLCJvbndyaXRlZW5kIiwic2VsZiIsIm1vZHVsZSIsImV4cG9ydHMiLCJjb252ZXJ0RGVja1RvRmlsZSIsImZpbGVJZCIsImZpbGVEb3dubG9hZERlY2siLCJmaWxlRGF0YSIsIkZpbGUiLCJhcHBNZXRob2RzIiwiZmlsZXMiLCJkYXRhVHJhbnNmZXIiLCJ1cmxRdWVyeSIsInNlYXJjaCIsInByaWNlQXBwIl0sIm1hcHBpbmdzIjoid0JBVUEsU0FBU0EsR0FBV0MsU0FDSixPQUFQQSxFQUNILEdBQ2UscUJBQVJBLGlC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"}