{"version":3,"file":"app.js","sources":["../../node_modules/Vue/dist/vue.esm.js","data/priceCurrencies.js","data/priceModes.js","data/deckParts.js","appData.js","methods/uriLocationNoParam.js","methods/utilEachObject.js","methods/apiLoadNames.js","data/apiURLs.js","methods/apiLoadPrices.js","methods/convertFileToDeck.js","methods/deckLoad.js","methods/uriDeckDecode.js","methods/deckLoadUri.js","methods/uriDeckEncode.js","methods/deckUpdate.js","methods/deckCardsWithoutPriceData.js","methods/priceConvert.js","methods/priceForCard.js","methods/priceForSection.js","methods/builderUpdateNames.js","methods/builderDeckAdd.js","methods/builderDeckRemove.js","../../node_modules/file-saver/FileSaver.js","methods/convertDeckToFile.js","methods/fileDownloadDeck.js","appMethods.js","app.js"],"sourcesContent":["/*!\n * Vue.js v2.2.6\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n/*  */\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction _toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Remove an item from an array\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return typeof value === 'string' || typeof value === 'number'\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nvar toString = Object.prototype.toString;\nvar OBJECT_STRING = '[object Object]';\nfunction isPlainObject (obj) {\n  return toString.call(obj) === OBJECT_STRING\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n */\nfunction noop () {}\n\n/**\n * Always return false.\n */\nvar no = function () { return false; };\n\n/**\n * Return same value\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      return JSON.stringify(a) === JSON.stringify(b)\n    } catch (e) {\n      // possible circular reference\n      return a === b\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn();\n    }\n  }\n}\n\n/*  */\n\nvar config = {\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * List of asset types that a component can own.\n   */\n  _assetTypes: [\n    'component',\n    'directive',\n    'filter'\n  ],\n\n  /**\n   * List of lifecycle hooks.\n   */\n  _lifecycleHooks: [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated'\n  ],\n\n  /**\n   * Max circular updates allowed in a scheduler flush cycle.\n   */\n  _maxUpdateCount: 100\n};\n\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    var logError = function (err) { console.error(err); };\n    timerFunc = function () {\n      p.then(nextTickHandler).catch(logError);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n  } else if (typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function () {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) { cb.call(ctx); }\n      if (_resolve) { _resolve(ctx); }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve) {\n        _resolve = resolve;\n      })\n    }\n  }\n})();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\nvar warn = noop;\nvar tip = noop;\nvar formatComponentName;\n\nif (process.env.NODE_ENV !== 'production') {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.error(\"[Vue warn]: \" + msg + \" \" + (\n        vm ? formatLocation(formatComponentName(vm)) : ''\n      ));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + \" \" + (\n        vm ? formatLocation(formatComponentName(vm)) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var name = typeof vm === 'string'\n      ? vm\n      : typeof vm === 'function' && vm.options\n        ? vm.options.name\n        : vm._isVue\n          ? vm.$options.name || vm.$options._componentTag\n          : vm.name;\n\n    var file = vm._isVue && vm.$options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var formatLocation = function (str) {\n    if (str === \"<Anonymous>\") {\n      str += \" - use the \\\"name\\\" option for better debugging messages.\";\n    }\n    return (\"\\n(found in \" + str + \")\")\n  };\n}\n\n/*  */\n\n\nvar uid$1 = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid$1++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var arguments$1 = arguments;\n\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n    while (i--) {\n      args[i] = arguments$1[i];\n    }\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n        inserted = args;\n        break\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true,\n  isSettingProps: false\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value)) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (Array.isArray(target) && typeof key === 'number') {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (hasOwn(target, key)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target ).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (Array.isArray(target) && typeof key === 'number') {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target ).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (process.env.NODE_ENV !== 'production') {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        childVal.call(this),\n        parentVal.call(this)\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nconfig._lifecycleHooks.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal\n    ? extend(res, childVal)\n    : res\n}\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.computed = function (parentVal, childVal) {\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  extend(ret, childVal);\n  return ret\n};\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + key\n      );\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkComponents(child);\n  }\n  normalizeProps(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = typeof extendsFrom === 'function'\n      ? mergeOptions(parent, extendsFrom.options, vm)\n      : mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      var mixin = child.mixins[i];\n      if (mixin.prototype instanceof Vue$3) {\n        mixin = mixin.options;\n      }\n      parent = mergeOptions(parent, mixin, vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (process.env.NODE_ENV !== 'production' && isObject(def)) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      'Invalid prop: type check failed for prop \"' + name + '\".' +\n      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\n/**\n * Assert the type of a value\n */\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (expectedType === 'String') {\n    valid = typeof value === (expectedType = 'string');\n  } else if (expectedType === 'Number') {\n    valid = typeof value === (expectedType = 'number');\n  } else if (expectedType === 'Boolean') {\n    valid = typeof value === (expectedType = 'boolean');\n  } else if (expectedType === 'Function') {\n    valid = typeof value === (expectedType = 'function');\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match && match[1]\n}\n\nfunction isType (type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type)\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true\n    }\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction handleError (err, vm, info) {\n  if (config.errorHandler) {\n    config.errorHandler.call(null, err, vm, info);\n  } else {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Error in \" + info + \":\"), vm);\n    }\n    /* istanbul ignore else */\n    if (inBrowser && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err\n    }\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (process.env.NODE_ENV !== 'production') {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      \"referenced during render. Make sure to declare reactive data \" +\n      \"properties in the data option.\",\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' &&\n    Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\nvar mark;\nvar measure;\n\nif (process.env.NODE_ENV !== 'production') {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      perf.clearMeasures(name);\n    };\n  }\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n};\n\nvar prototypeAccessors = { child: {} };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function () {\n  var node = new VNode();\n  node.text = '';\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isCloned = true;\n  return cloned\n}\n\nfunction cloneVNodes (vnodes) {\n  var len = vnodes.length;\n  var res = new Array(len);\n  for (var i = 0; i < len; i++) {\n    res[i] = cloneVNode(vnodes[i]);\n  }\n  return res\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture\n  }\n});\n\nfunction createFnInvoker (fns) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      for (var i = 0; i < fns.length; i++) {\n        fns[i].apply(null, arguments$1);\n      }\n    } else {\n      // return handler return value for single handlers\n      return fns.apply(null, arguments)\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, cur, old, event;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (!cur) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (!old) {\n      if (!cur.fns) {\n        cur = on[name] = createFnInvoker(cur);\n      }\n      add(event.name, cur, event.once, event.capture);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (!on[name]) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (!oldHook) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (oldHook.fns && oldHook.merged) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (c == null || typeof c === 'boolean') { continue }\n    last = res[res.length - 1];\n    //  nested\n    if (Array.isArray(c)) {\n      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\n    } else if (isPrimitive(c)) {\n      if (last && last.text) {\n        last.text += String(c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (c.text && last && last.text) {\n        res[res.length - 1] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (c.tag && c.key == null && nestedIndex != null) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  return children && children.filter(function (c) { return c && c.componentOptions; })[0]\n}\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn, once$$1) {\n  if (once$$1) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        this$1.$off(event[i$1], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (process.env.NODE_ENV !== 'production') {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        cbs[i].apply(vm, args);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  var slots = {};\n  if (!children) {\n    return slots\n  }\n  var defaultSlot = [];\n  var name, child;\n  for (var i = 0, l = children.length; i < l; i++) {\n    child = children[i];\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) &&\n        child.data && (name = child.data.slot)) {\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore whitespace\n  if (!defaultSlot.every(isWhitespace)) {\n    slots.default = defaultSlot;\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return node.isComment || node.text === ' '\n}\n\nfunction resolveScopedSlots (\n  fns\n) {\n  var res = {};\n  for (var i = 0; i < fns.length; i++) {\n    res[fns[i][0]] = fns[i][1];\n  }\n  return res\n}\n\n/*  */\n\nvar activeInstance = null;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // remove reference to DOM nodes (prevents leak)\n    vm.$options._parentElm = vm.$options._refElm = null;\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  vm._watcher = new Watcher(vm, updateComponent, noop);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren\n  var hasChildren = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    parentVnode.data.scopedSlots || // has new scoped slots\n    vm.$scopedSlots !== emptyObject // has old scoped slots\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    observerState.shouldConvert = false;\n    if (process.env.NODE_ENV !== 'production') {\n      observerState.isSettingProps = true;\n    }\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      props[key] = validateProp(key, vm.$options.props, propsData, vm);\n    }\n    observerState.shouldConvert = true;\n    if (process.env.NODE_ENV !== 'production') {\n      observerState.isSettingProps = false;\n    }\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n  // update listeners\n  if (listeners) {\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n  }\n  // resolve slots + force update if has children\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive == null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm);\n      } catch (e) {\n        handleError(e, vm, (hook + \" hook\"));\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\n\nvar queue = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  queue.length = 0;\n  has = {};\n  if (process.env.NODE_ENV !== 'production') {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n  var watcher, id, vm;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > config._maxUpdateCount) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // reset scheduler before updated hook called\n  var oldQueue = queue.slice();\n  resetSchedulerState();\n\n  // call updated hooks\n  index = oldQueue.length;\n  while (index--) {\n    watcher = oldQueue[index];\n    vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i >= 0 && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(Math.max(i, index) + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options\n) {\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression = process.env.NODE_ENV !== 'production'\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  if (this.user) {\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    }\n  } else {\n    value = this.getter.call(vm, vm);\n  }\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value);\n  }\n  popTarget();\n  this.cleanupDeps();\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse (val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch) { initWatch(vm, opts.watch); }\n}\n\nvar isReservedProp = { key: 1, ref: 1, slot: 1 };\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      if (isReservedProp[key]) {\n        warn(\n          (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (vm.$parent && !observerState.isSettingProps) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  observerState.shouldConvert = true;\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var i = keys.length;\n  while (i--) {\n    if (props && hasOwn(props, keys[i])) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"The data property \\\"\" + (keys[i]) + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(keys[i])) {\n      proxy(vm, \"_data\", keys[i]);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  try {\n    return data.call(vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  var watchers = vm._computedWatchers = Object.create(null);\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (process.env.NODE_ENV !== 'production') {\n      if (getter === undefined) {\n        warn(\n          (\"No getter function has been defined for computed property \\\"\" + key + \"\\\".\"),\n          vm\n        );\n        getter = noop;\n      }\n    }\n    // create internal watcher for the computed property.\n    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    }\n  }\n}\n\nfunction defineComputed (target, key, userDef) {\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = createComputedGetter(key);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? userDef.cache !== false\n        ? createComputedGetter(key)\n        : userDef.get\n      : noop;\n    sharedPropertyDefinition.set = userDef.set\n      ? userDef.set\n      : noop;\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction initMethods (vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods[key] == null) {\n        warn(\n          \"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n    }\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (vm, key, handler) {\n  var options;\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  vm.$watch(key, handler, options);\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (process.env.NODE_ENV !== 'production') {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\n// hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (\n    vnode,\n    hydrating,\n    parentElm,\n    refElm\n  ) {\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance,\n        parentElm,\n        refElm\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    } else if (vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    if (!vnode.componentInstance._isMounted) {\n      vnode.componentInstance._isMounted = true;\n      callHook(vnode.componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      activateChildComponent(vnode.componentInstance, true /* direct */);\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    if (!vnode.componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        vnode.componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(vnode.componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (!Ctor) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  if (typeof Ctor !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  if (!Ctor.cid) {\n    if (Ctor.resolved) {\n      Ctor = Ctor.resolved;\n    } else {\n      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {\n        // it's ok to queue this on every render because\n        // $forceUpdate is buffered by the scheduler.\n        context.$forceUpdate();\n      });\n      if (!Ctor) {\n        // return nothing if this is indeed an async component\n        // wait for the callback to trigger parent update.\n        return\n      }\n    }\n  }\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  data = data || {};\n\n  // transform component v-model data into props & events\n  if (data.model) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractProps(data, Ctor, tag);\n\n  // functional component\n  if (Ctor.options.functional) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  data.on = data.nativeOn;\n\n  if (Ctor.options.abstract) {\n    // abstract components do not keep anything\n    // other than props & listeners\n    data = {};\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }\n  );\n  return vnode\n}\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  context,\n  children\n) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (propOptions) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData);\n    }\n  }\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var _context = Object.create(context);\n  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\n  var vnode = Ctor.options.render.call(null, h, {\n    props: props,\n    data: data,\n    parent: context,\n    children: children,\n    slots: function () { return resolveSlots(children, context); }\n  });\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm,\n  refElm\n) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (inlineTemplate) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options)\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  cb\n) {\n  if (factory.requested) {\n    // pool callbacks\n    factory.pendingCallbacks.push(cb);\n  } else {\n    factory.requested = true;\n    var cbs = factory.pendingCallbacks = [cb];\n    var sync = true;\n\n    var resolve = function (res) {\n      if (isObject(res)) {\n        res = baseCtor.extend(res);\n      }\n      // cache resolved\n      factory.resolved = res;\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          cbs[i](res);\n        }\n      }\n    };\n\n    var reject = function (reason) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n    };\n\n    var res = factory(resolve, reject);\n\n    // handle promise\n    if (res && typeof res.then === 'function' && !factory.resolved) {\n      res.then(resolve, reject);\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.resolved\n  }\n}\n\nfunction extractProps (data, Ctor, tag) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (!propOptions) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  var domProps = data.domProps;\n  if (attrs || props || domProps) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (process.env.NODE_ENV !== 'production') {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && attrs.hasOwnProperty(keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey) ||\n      checkProp(res, domProps, key, altKey);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (hash) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\nfunction mergeHooks (data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = componentVNodeHooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1 (one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  }\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  if (on[event]) {\n    on[event] = [data.model.callback].concat(on[event]);\n  } else {\n    on[event] = data.model.callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (alwaysNormalize) { normalizationType = ALWAYS_NORMALIZE; }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (data && data.__ob__) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n      typeof children[0] === 'function') {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (vnode) {\n    if (ns) { applyNS(vnode, ns); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    return\n  }\n  if (vnode.children) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (child.tag && !child.ns) {\n        applyNS(child, ns);\n      }\n    }\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    ret = new Array(keys.length);\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      ret[i] = render(val[key], key, i);\n    }\n  }\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      extend(props, bindObject);\n    }\n    return scopedSlotFn(props) || fallback\n  } else {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes && process.env.NODE_ENV !== 'production') {\n      slotNodes._rendered && warn(\n        \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n        \"- this will likely cause render errors.\",\n        this\n      );\n      slotNodes._rendered = true;\n    }\n    return slotNodes || fallback\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\n/**\n * Runtime helper for checking keyCodes from config.\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInAlias\n) {\n  var keyCodes = config.keyCodes[key] || builtInAlias;\n  if (Array.isArray(keyCodes)) {\n    return keyCodes.indexOf(eventKeyCode) === -1\n  } else {\n    return keyCodes !== eventKeyCode\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp\n) {\n  if (value) {\n    if (!isObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      for (var key in value) {\n        if (key === 'class' || key === 'style') {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        if (!(key in hash)) {\n          hash[key] = value[key];\n        }\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var tree = this._staticTrees[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree by doing a shallow clone.\n  if (tree && !isInFor) {\n    return Array.isArray(tree)\n      ? cloneVNodes(tree)\n      : cloneVNode(tree)\n  }\n  // otherwise, render a fresh tree.\n  tree = this._staticTrees[index] =\n    this.$options.staticRenderFns[index].call(this._renderProxy);\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm.$vnode = null; // the placeholder node in parent tree\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  var parentVnode = vm.$options._parentVnode;\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n}\n\nfunction renderMixin (Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render function\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        vnode = vm.$options.renderError\n          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n          : vm._vnode;\n      } else {\n        vnode = vm._vnode;\n      }\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n\n  // internal render helpers.\n  // these are exposed on the instance prototype to reduce generated render\n  // code size.\n  Vue.prototype._o = markOnce;\n  Vue.prototype._n = toNumber;\n  Vue.prototype._s = _toString;\n  Vue.prototype._l = renderList;\n  Vue.prototype._t = renderSlot;\n  Vue.prototype._q = looseEqual;\n  Vue.prototype._i = looseIndexOf;\n  Vue.prototype._m = renderStatic;\n  Vue.prototype._f = resolveFilter;\n  Vue.prototype._k = checkKeyCodes;\n  Vue.prototype._b = bindObjectProps;\n  Vue.prototype._v = createTextVNode;\n  Vue.prototype._e = createEmptyVNode;\n  Vue.prototype._u = resolveScopedSlots;\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var inject = vm.$options.inject;\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    // isArray here\n    var isArray = Array.isArray(inject);\n    var keys = isArray\n      ? inject\n      : hasSymbol\n        ? Reflect.ownKeys(inject)\n        : Object.keys(inject);\n\n    var loop = function ( i ) {\n      var key = keys[i];\n      var provideKey = isArray ? key : inject[key];\n      var source = vm;\n      while (source) {\n        if (source._provided && provideKey in source._provided) {\n          /* istanbul ignore else */\n          if (process.env.NODE_ENV !== 'production') {\n            defineReactive$$1(vm, key, source._provided[provideKey], function () {\n              warn(\n                \"Avoid mutating an injected value directly since the changes will be \" +\n                \"overwritten whenever the provided component re-renders. \" +\n                \"injection being mutated: \\\"\" + key + \"\\\"\",\n                vm\n              );\n            });\n          } else {\n            defineReactive$$1(vm, key, source._provided[provideKey]);\n          }\n          break\n        }\n        source = source.$parent;\n      }\n    };\n\n    for (var i = 0; i < keys.length; i++) loop( i );\n  }\n}\n\n/*  */\n\nvar uid = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = \"vue-perf-init:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure(((vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = dedupe(latest[key], sealed[key]);\n    }\n  }\n  return modified\n}\n\nfunction dedupe (latest, sealed) {\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n  // between merges\n  if (Array.isArray(latest)) {\n    var res = [];\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\n    for (var i = 0; i < latest.length; i++) {\n      if (sealed.indexOf(latest[i]) < 0) {\n        res.push(latest[i]);\n      }\n    }\n    return res\n  } else {\n    return latest\n  }\n}\n\nfunction Vue$3 (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue$3)) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return\n    }\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    plugin.installed = true;\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn(\n          'Invalid component name: \"' + name + '\". Component names ' +\n          'can only contain alphanumeric characters and the hyphen, ' +\n          'and must start with a letter.'\n        );\n      }\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    config._assetTypes.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  config._assetTypes.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production') {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn(\n              'Do not use built-in or reserved HTML elements as component ' +\n              'id: ' + id\n            );\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\nvar patternTypes = [String, RegExp];\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (pattern instanceof RegExp) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (cache, filter) {\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        pruneCacheEntry(cachedNode);\n        cache[key] = null;\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (vnode) {\n  if (vnode) {\n    if (!vnode.componentInstance._inactive) {\n      callHook(vnode.componentInstance, 'deactivated');\n    }\n    vnode.componentInstance.$destroy();\n  }\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n  },\n\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this$1.cache) {\n      pruneCacheEntry(this$1.cache[key]);\n    }\n  },\n\n  watch: {\n    include: function include (val) {\n      pruneCache(this.cache, function (name) { return matches(val, name); });\n    },\n    exclude: function exclude (val) {\n      pruneCache(this.cache, function (name) { return !matches(val, name); });\n    }\n  },\n\n  render: function render () {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      if (name && (\n        (this.include && !matches(this.include, name)) ||\n        (this.exclude && matches(this.exclude, name))\n      )) {\n        return vnode\n      }\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (this.cache[key]) {\n        vnode.componentInstance = this.cache[key].componentInstance;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (process.env.NODE_ENV !== 'production') {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  config._assetTypes.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nVue$3.version = '2.2.6';\n\n/*  */\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (childNode.componentInstance) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return genClassFromData(data)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: child.class\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction genClassFromData (data) {\n  var dynamicClass = data.class;\n  var staticClass = data.staticClass;\n  if (staticClass || dynamicClass) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  var res = '';\n  if (!value) {\n    return res\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  if (Array.isArray(value)) {\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (value[i]) {\n        if ((stringified = stringifyClass(value[i]))) {\n          res += stringified + ' ';\n        }\n      }\n    }\n    return res.slice(0, -1)\n  }\n  if (isObject(value)) {\n    for (var key in value) {\n      if (value[key]) { res += key + ' '; }\n    }\n    return res.slice(0, -1)\n  }\n  /* istanbul ignore next */\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute (node, key, val) {\n  node.setAttribute(key, val);\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tsetAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\n        refs[key].push(ref);\n      } else {\n        refs[key] = [ref];\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n\n/*\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key &&\n    a.tag === b.tag &&\n    a.isComment === b.isComment &&\n    isDef(a.data) === isDef(b.data) &&\n    sameInputType(a, b)\n  )\n}\n\n// Some browsers do not support dynamically changing type for <input>\n// so they need to be treated as different nodes\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  var inPre = 0;\n  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (data && data.pre) {\n          inPre++;\n        }\n        if (\n          !inPre &&\n          !vnode.ns &&\n          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\n          config.isUnknownElement(tag)\n        ) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (process.env.NODE_ENV !== 'production' && data && data.pre) {\n        inPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref) {\n    if (isDef(parent)) {\n      if (isDef(ref)) {\n        nodeOps.insertBefore(parent, elm, ref);\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    var ancestor = vnode;\n    while (ancestor) {\n      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n        nodeOps.setAttribute(vnode.elm, i, '');\n      }\n      ancestor = ancestor.parent;\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n        i !== vnode.context &&\n        isDef(i = i.$options._scopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !elmToMove) {\n            warn(\n              'It seems there are duplicate keys that is causing an update error. ' +\n              'Make sure each v-for item has a unique key.'\n            );\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n        isTrue(oldVnode.isStatic) &&\n        vnode.key === oldVnode.key &&\n        (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\n      vnode.elm = oldVnode.elm;\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n    var elm = vnode.elm = oldVnode.elm;\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          var childrenMatch = true;\n          var childNode = elm.firstChild;\n          for (var i$1 = 0; i$1 < children.length; i$1++) {\n            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n              childrenMatch = false;\n              break\n            }\n            childNode = childNode.nextSibling;\n          }\n          // if childNode is not null, it means the actual childNodes list is\n          // longer than the virtual children list.\n          if (!childrenMatch || childNode) {\n            if (process.env.NODE_ENV !== 'production' &&\n                typeof console !== 'undefined' &&\n                !bailed) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n            }\n            return false\n          }\n        }\n      }\n      if (isDef(data)) {\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode) {\n    if (isDef(vnode.tag)) {\n      return (\n        vnode.tag.indexOf('vue-component') === 0 ||\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {\n            oldVnode.removeAttribute('server-rendered');\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (process.env.NODE_ENV !== 'production') {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        if (isDef(vnode.parent)) {\n          // component root element replaced.\n          // update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          while (ancestor) {\n            ancestor.elm = vnode.elm;\n            ancestor = ancestor.parent;\n          }\n          if (isPatchable(vnode)) {\n            for (var i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (isDef(parentElm$1)) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  if (!oldVnode.data.attrs && !vnode.data.attrs) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (attrs.__ob__) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  /* istanbul ignore if */\n  if (isIE9 && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (attrs[key] == null) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, key);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (!data.staticClass && !data.class &&\n      (!oldData || (!oldData.staticClass && !oldData.class))) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (transitionClass) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n  }\n}\n\n/*  */\n\nfunction baseWarn (msg) {\n  console.error((\"[Vue compiler]: \" + msg));\n}\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n}\n\nfunction addAttr (el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  modifiers\n) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important\n) {\n  // check capture modifier\n  if (modifiers && modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  if (modifiers && modifiers.once) {\n    delete modifiers.once;\n    name = '~' + name; // mark the event as once\n  }\n  var events;\n  if (modifiers && modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n  var newHandler = { value: value, modifiers: modifiers };\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\nfunction getAndRemoveAttr (el, name) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  return val\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel (\n  el,\n  value,\n  modifiers\n) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression =\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\n        \"? \" + baseValueExpression + \".trim()\" +\n        \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: (\"(\" + value + \")\"),\n    expression: (\"\\\"\" + value + \"\\\"\"),\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode (\n  value,\n  assignment\n) {\n  var modelRs = parseModel(value);\n  if (modelRs.idx === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return \"var $$exp = \" + (modelRs.exp) + \", $$idx = \" + (modelRs.idx) + \";\" +\n      \"if (!Array.isArray($$exp)){\" +\n        value + \"=\" + assignment + \"}\" +\n      \"else{$$exp.splice($$idx, 1, \" + assignment + \")}\"\n  }\n}\n\n/**\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n *\n * for loop possible cases:\n *\n * - test\n * - test[idx]\n * - test[test1[idx]]\n * - test[\"a\"][idx]\n * - xxx.test[a[a].test1[idx]]\n * - test.xxx.a[\"asa\"][test1[idx]]\n *\n */\n\nvar len;\nvar str;\nvar chr;\nvar index$1;\nvar expressionPos;\nvar expressionEndPos;\n\nfunction parseModel (val) {\n  str = val;\n  len = str.length;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    return {\n      exp: val,\n      idx: null\n    }\n  }\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.substring(0, expressionPos),\n    idx: val.substring(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model (\n  el,\n  dir,\n  _warn\n) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (process.env.NODE_ENV !== 'production') {\n    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (tag === 'input' && dynamicType) {\n      warn$1(\n        \"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" +\n        \"v-model does not support dynamic input types. Use v-if branches instead.\"\n      );\n    }\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n        \"File inputs are read only. Use a v-on:change listener instead.\"\n      );\n    }\n  }\n\n  if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$1(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n      \"v-model is not supported on this element type. \" +\n      'If you are working with contenteditable, it\\'s recommended to ' +\n      'wrap a library dedicated for that purpose inside a custom component.'\n    );\n  }\n\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n        trueValueBinding === 'true'\n          ? (\":(\" + value + \")\")\n          : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n      )\n  );\n  addHandler(el, CHECKBOX_RADIO_TOKEN,\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$c){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" +\n      \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" +\n    \"}else{\" + value + \"=$$c}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + (genAssignmentCode(value, assignment));\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  var type = el.attrsMap.type;\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number || type === 'number') {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  var event;\n  /* istanbul ignore if */\n  if (on[RANGE_TOKEN]) {\n    // IE input[type=range] only supports `change` event\n    event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  if (on[CHECKBOX_RADIO_TOKEN]) {\n    // Chrome fires microtasks in between click/change, leads to #4521\n    event = isChrome ? 'click' : 'change';\n    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction add$1 (\n  event,\n  handler,\n  once,\n  capture\n) {\n  if (once) {\n    var oldHandler = handler;\n    var _target = target$1; // save current target element in closure\n    handler = function (ev) {\n      var res = arguments.length === 1\n        ? oldHandler(ev)\n        : oldHandler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, handler, capture, _target);\n      }\n    };\n  }\n  target$1.addEventListener(event, handler, capture);\n}\n\nfunction remove$2 (\n  event,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(event, handler, capture);\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (!oldVnode.data.on && !vnode.data.on) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (!oldVnode.data.domProps && !vnode.data.domProps) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (props.__ob__) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (props[key] == null) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = cur == null ? '' : String(cur);\n      if (shouldUpdateValue(elm, vnode, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (\n  elm,\n  vnode,\n  checkVal\n) {\n  return (!elm.composing && (\n    vnode.tag === 'option' ||\n    isDirty(elm, checkVal) ||\n    isInputChanged(elm, checkVal)\n  ))\n}\n\nfunction isDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value\n  return document.activeElement !== elm && elm.value !== checkVal\n}\n\nfunction isInputChanged (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if ((modifiers && modifiers.number) || elm.type === 'number') {\n    return toNumber(value) !== toNumber(newVal)\n  }\n  if (modifiers && modifiers.trim) {\n    return value.trim() !== newVal.trim()\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    el.style[normalize(name)] = val;\n  }\n};\n\nvar prefixes = ['Webkit', 'Moz', 'ms'];\n\nvar testEl;\nvar normalize = cached(function (prop) {\n  testEl = testEl || document.createElement('div');\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in testEl.style)) {\n    return prop\n  }\n  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefixed = prefixes[i] + upper;\n    if (prefixed in testEl.style) {\n      return prefixed\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (!data.staticStyle && !data.style &&\n      !oldData.staticStyle && !oldData.style) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldVnode.data.staticStyle;\n  var oldStyleBinding = oldVnode.data.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  vnode.data.style = style.__ob__ ? extend({}, style) : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (newStyle[name] == null) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    el.setAttribute('class', cur.trim());\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser && window.requestAnimationFrame\n  ? window.requestAnimationFrame.bind(window)\n  : setTimeout;\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n  addClass(el, cls);\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (el._leaveCb) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (el._enterCb || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n          pendingNode.tag === vnode.tag &&\n          pendingNode.elm._leaveCb) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        if (isValidDuration(explicitEnterDuration)) {\n          setTimeout(cb, explicitEnterDuration);\n        } else {\n          whenTransitionEnds(el, type, cb);\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (el._enterCb) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (el._leaveCb || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && explicitLeaveDuration != null) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          if (isValidDuration(explicitLeaveDuration)) {\n            setTimeout(cb, explicitLeaveDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (!fn) { return false }\n  var invokerFns = fn.fns;\n  if (invokerFns) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (!vnode.data.show) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (!vnode.data.show) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model$1 = {\n  inserted: function inserted (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      var cb = function () {\n        setSelected(el, binding, vnode.context);\n      };\n      cb();\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(cb, 0);\n      }\n    } else if (vnode.tag === 'textarea' || el.type === 'text' || el.type === 'password') {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var needReset = el.multiple\n        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })\n        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n      if (needReset) {\n        trigger(el, 'change');\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  for (var i = 0, l = options.length; i < l; i++) {\n    if (looseEqual(getValue(options[i]), value)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition && !isIE9) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    if (transition && !isIE9) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model$1,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  return /\\d-keep-alive$/.test(rawChild.tag)\n    ? h('keep-alive')\n    : null\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag; });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (process.env.NODE_ENV !== 'production' && children.length > 1) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (process.env.NODE_ENV !== 'production' &&\n        mode && mode !== 'in-out' && mode !== 'out-in') {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final desired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (process.env.NODE_ENV !== 'production') {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var body = document.body;\n    var f = body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      if (this._hasMove != null) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.mustUseProp = mustUseProp;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (process.env.NODE_ENV !== 'production' && isChrome) {\n      console[console.info ? 'info' : 'log'](\n        'Download the Vue Devtools extension for a better development experience:\\n' +\n        'https://github.com/vuejs/vue-devtools'\n      );\n    }\n  }\n  if (process.env.NODE_ENV !== 'production' &&\n      config.productionTip !== false &&\n      inBrowser && typeof console !== 'undefined') {\n    console[console.info ? 'info' : 'log'](\n      \"You are running Vue in development mode.\\n\" +\n      \"Make sure to turn on production mode when deploying for production.\\n\" +\n      \"See more tips at https://vuejs.org/guide/deployment.html\"\n    );\n  }\n}, 0);\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nfunction shouldDecode (content, encoded) {\n  var div = document.createElement('div');\n  div.innerHTML = \"<div a=\\\"\" + content + \"\\\">\";\n  return div.innerHTML.indexOf(encoded) > 0\n}\n\n// #3663\n// IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr'\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track'\n);\n\n/*  */\n\nvar decoder;\n\nfunction decode (html) {\n  decoder = decoder || document.createElement('div');\n  decoder.innerHTML = html;\n  return decoder.textContent\n}\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\nvar singleAttrAssign = /(?:=)/;\nvar singleAttrValues = [\n  // attr value double quotes\n  /\"([^\"]*)\"+/.source,\n  // attr value, single quotes\n  /'([^']*)'+/.source,\n  // attr value, no quotes\n  /([^\\s\"'=<>`]+)/.source\n];\nvar attribute = new RegExp(\n  '^\\\\s*' + singleAttrIdentifier.source +\n  '(?:\\\\s*(' + singleAttrAssign.source + ')' +\n  '\\\\s*(?:' + singleAttrValues.join('|') + '))?'\n);\n\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\nvar startTagOpen = new RegExp('^<' + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^<!--/;\nvar conditionalComment = /^<!\\[/;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n'\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) { return decodingMap[match]; })\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          continue\n        }\n      }\n\n      var text = (void 0), rest$1 = (void 0), next = (void 0);\n      if (textEnd >= 0) {\n        rest$1 = html.slice(textEnd);\n        while (\n          !endTag.test(rest$1) &&\n          !startTagOpen.test(rest$1) &&\n          !comment.test(rest$1) &&\n          !conditionalComment.test(rest$1)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest$1.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest$1 = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var endTagLength = 0;\n      var rest = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!--([\\s\\S]*?)-->/g, '$1')\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest.length;\n      html = rest;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"));\n      }\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') { delete args[3]; }\n        if (args[4] === '') { delete args[4]; }\n        if (args[5] === '') { delete args[5]; }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(\n          value,\n          options.shouldDecodeNewlines\n        )\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (process.env.NODE_ENV !== 'production' &&\n            (i > pos || !tagName) &&\n            options.warn) {\n          options.warn(\n            (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\")\n          );\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push(JSON.stringify(text.slice(lastIndex)));\n  }\n  return tokens.join('+')\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\nvar forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^v-bind:/;\nvar modifierRE = /\\.[^.]+/g;\n\nvar decodeHTMLCached = cached(decode);\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$2 = options.warn || baseWarn;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformIsPreTag = options.isPreTag || no;\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce (msg) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg);\n    }\n  }\n\n  function endPre (element) {\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    start: function start (tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = {\n        type: 1,\n        tag: tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        parent: currentParent,\n        children: []\n      };\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        process.env.NODE_ENV !== 'production' && warn$2(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.'\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        preTransforms[i](element, options);\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else {\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        processKey(element);\n\n        // determine whether this is a plain element after\n        // removing structural attributes\n        element.plain = !element.key && !attrs.length;\n\n        processRef(element);\n        processSlot(element);\n        processComponent(element);\n        for (var i$1 = 0; i$1 < transforms.length; i$1++) {\n          transforms[i$1](element, options);\n        }\n        processAttrs(element);\n      }\n\n      function checkRootConstraints (el) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (el.tag === 'slot' || el.tag === 'template') {\n            warnOnce(\n              \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n              'contain multiple nodes.'\n            );\n          }\n          if (el.attrsMap.hasOwnProperty('v-for')) {\n            warnOnce(\n              'Cannot use v-for on stateful component root element because ' +\n              'it renders multiple elements.'\n            );\n          }\n        }\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (!stack.length) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          checkRootConstraints(element);\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else if (process.env.NODE_ENV !== 'production') {\n          warnOnce(\n            \"Component template should contain exactly one root element. \" +\n            \"If you are using v-if on multiple elements, \" +\n            \"use v-else-if to chain them instead.\"\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else if (element.slotScope) { // scoped slot\n          currentParent.plain = false;\n          var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        endPre(element);\n      }\n      // apply post-transforms\n      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n        postTransforms[i$2](element, options);\n      }\n    },\n\n    end: function end () {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      endPre(element);\n    },\n\n    chars: function chars (text) {\n      if (!currentParent) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (text === template) {\n            warnOnce(\n              'Component template requires a root element, rather than just text.'\n            );\n          } else if ((text = text.trim())) {\n            warnOnce(\n              (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\")\n            );\n          }\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n          currentParent.tag === 'textarea' &&\n          currentParent.attrsMap.placeholder === text) {\n        return\n      }\n      var children = currentParent.children;\n      text = inPre || text.trim()\n        ? decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && children.length ? ' ' : '';\n      if (text) {\n        var expression;\n        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n          children.push({\n            type: 2,\n            expression: expression,\n            text: text\n          });\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {\n      warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) {\n      process.env.NODE_ENV !== 'production' && warn$2(\n        (\"Invalid v-for expression: \" + exp)\n      );\n      return\n    }\n    el.for = inMatch[2].trim();\n    var alias = inMatch[1].trim();\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      el.alias = iteratorMatch[1].trim();\n      el.iterator1 = iteratorMatch[2].trim();\n      if (iteratorMatch[3]) {\n        el.iterator2 = iteratorMatch[3].trim();\n      }\n    } else {\n      el.alias = alias;\n    }\n  }\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$2(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\"\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {\n        warn$2(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\"\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (process.env.NODE_ENV !== 'production' && el.key) {\n      warn$2(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\"\n      );\n    }\n  } else {\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    }\n    if (el.tag === 'template') {\n      el.slotScope = getAndRemoveAttr(el, 'scope');\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isProp = false;\n        if (modifiers) {\n          if (modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel) {\n            name = camelize(name);\n          }\n        }\n        if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (process.env.NODE_ENV !== 'production' && name === 'model') {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (process.env.NODE_ENV !== 'production') {\n        var expression = parseText(value, delimiters);\n        if (expression) {\n          warn$2(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.'\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value));\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (process.env.NODE_ENV !== 'production' && map[attrs[i].name] && !isIE) {\n      warn$2('duplicate attribute: ' + attrs[i].name);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\"\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic$1 (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      walkThroughConditionsBlocks(node.ifConditions, isInFor);\n    }\n  }\n}\n\nfunction walkThroughConditionsBlocks (conditionBlocks, isInFor) {\n  for (var i = 1, len = conditionBlocks.length; i < len; i++) {\n    markStaticRoots(conditionBlocks[i].block, isInFor);\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers (events, native) {\n  var res = native ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    res += \"\\\"\" + name + \"\\\":\" + (genHandler(name, events[name])) + \",\";\n  }\n  return res.slice(0, -1) + '}'\n}\n\nfunction genHandler (\n  name,\n  handler\n) {\n  if (!handler) {\n    return 'function(){}'\n  }\n\n  if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + \"]\")\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n\n  if (!handler.modifiers) {\n    return isMethodPath || isFunctionExpression\n      ? handler.value\n      : (\"function($event){\" + (handler.value) + \"}\") // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? handler.value + '($event)'\n      : isFunctionExpression\n        ? (\"(\" + (handler.value) + \")($event)\")\n        : handler.value;\n    return (\"function($event){\" + code + handlerCode + \"}\")\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\"if(!('button' in $event)&&\" + (keys.map(genFilterCode).join('&&')) + \")return null;\")\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var alias = keyCodes[key];\n  return (\"_k($event.keyCode,\" + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + \")\")\n}\n\n/*  */\n\nfunction bind$1 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\n// configurable state\nvar warn$3;\nvar transforms$1;\nvar dataGenFns;\nvar platformDirectives$1;\nvar isPlatformReservedTag$1;\nvar staticRenderFns;\nvar onceCount;\nvar currentOptions;\n\nfunction generate (\n  ast,\n  options\n) {\n  // save previous staticRenderFns so generate calls can be nested\n  var prevStaticRenderFns = staticRenderFns;\n  var currentStaticRenderFns = staticRenderFns = [];\n  var prevOnceCount = onceCount;\n  onceCount = 0;\n  currentOptions = options;\n  warn$3 = options.warn || baseWarn;\n  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');\n  dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  platformDirectives$1 = options.directives || {};\n  isPlatformReservedTag$1 = options.isReservedTag || no;\n  var code = ast ? genElement(ast) : '_c(\"div\")';\n  staticRenderFns = prevStaticRenderFns;\n  onceCount = prevOnceCount;\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: currentStaticRenderFns\n  }\n}\n\nfunction genElement (el) {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el);\n    } else {\n      var data = el.plain ? undefined : genData(el);\n\n      var children = el.inlineTemplate ? null : genChildren(el, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < transforms$1.length; i++) {\n      code = transforms$1[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el) {\n  el.staticProcessed = true;\n  staticRenderFns.push((\"with(this){return \" + (genElement(el)) + \"}\"));\n  return (\"_m(\" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      process.env.NODE_ENV !== 'production' && warn$3(\n        \"v-once can only be used inside v-for that is keyed. \"\n      );\n      return genElement(el)\n    }\n    return (\"_o(\" + (genElement(el)) + \",\" + (onceCount++) + (key ? (\",\" + key) : \"\") + \")\")\n  } else {\n    return genStatic(el)\n  }\n}\n\nfunction genIf (el) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice())\n}\n\nfunction genIfConditions (conditions) {\n  if (!conditions.length) {\n    return '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return el.once ? genOnce(el) : genElement(el)\n  }\n}\n\nfunction genFor (el) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key\n  ) {\n    warn$3(\n      \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n      \"v-for should have explicit keys. \" +\n      \"See https://vuejs.org/guide/list.html#key for more info.\",\n      true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genElement(el)) +\n    '})'\n}\n\nfunction genData (el) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < dataGenFns.length; i++) {\n    data += dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true)) + \",\";\n  }\n  // slot target\n  if (el.slotTarget) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el.scopedSlots)) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  return data\n}\n\nfunction genDirectives (el) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, warn$3);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el) {\n  var ast = el.children[0];\n  if (process.env.NODE_ENV !== 'production' && (\n    el.children.length > 1 || ast.type !== 1\n  )) {\n    warn$3('Inline-template components must have exactly one child element.');\n  }\n  if (ast.type === 1) {\n    var inlineRenderFns = generate(ast, currentOptions);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (slots) {\n  return (\"scopedSlots:_u([\" + (Object.keys(slots).map(function (key) { return genScopedSlot(key, slots[key]); }).join(',')) + \"])\")\n}\n\nfunction genScopedSlot (key, el) {\n  return \"[\" + key + \",function(\" + (String(el.attrsMap.scope)) + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? genChildren(el) || 'void 0'\n      : genElement(el)) + \"}]\"\n}\n\nfunction genChildren (el, checkSkip) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n        el$1.for &&\n        el$1.tag !== 'template' &&\n        el$1.tag !== 'slot') {\n      return genElement(el$1)\n    }\n    var normalizationType = checkSkip ? getNormalizationType(children) : 0;\n    return (\"[\" + (children.map(genNode).join(',')) + \"]\" + (normalizationType ? (\",\" + normalizationType) : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (children) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction maybeComponent (el) {\n  return !isPlatformReservedTag$1(el.tag)\n}\n\nfunction genNode (node) {\n  if (node.type === 1) {\n    return genElement(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genSlot (el) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs && (\"{\" + (el.attrs.map(function (a) { return ((camelize(a.name)) + \":\" + (a.value)); }).join(',')) + \"}\");\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (componentName, el) {\n  var children = el.inlineTemplate ? null : genChildren(el, true);\n  return (\"_c(\" + componentName + \",\" + (genData(el)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    res += \"\\\"\" + (prop.name) + \"\\\":\" + (transformSpecialNewlines(prop.value)) + \",\";\n  }\n  return res.slice(0, -1)\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\n  'delete,typeof,void'\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// check valid identifier for v-for\nvar identRE = /[A-Za-z_$][\\w$]*/;\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors\n}\n\nfunction checkNode (node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\n          } else if (onRE.test(name)) {\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkEvent (exp, text, errors) {\n  var keywordMatch = exp.replace(stripStringRE, '').match(unaryOperatorsRE);\n  if (keywordMatch) {\n    errors.push(\n      \"avoid using JavaScript unary operator as property name: \" +\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n    );\n  }\n  checkExpression(exp, text, errors);\n}\n\nfunction checkFor (node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier (ident, type, text, errors) {\n  if (typeof ident === 'string' && !identRE.test(ident)) {\n    errors.push((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())));\n  }\n}\n\nfunction checkExpression (exp, text, errors) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\n        \"avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n      );\n    } else {\n      errors.push((\"invalid expression: \" + (text.trim())));\n    }\n  }\n}\n\n/*  */\n\nfunction baseCompile (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  optimize(ast, options);\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n}\n\nfunction makeFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop\n  }\n}\n\nfunction createCompiler (baseOptions) {\n  var functionCompileCache = Object.create(null);\n\n  function compile (\n    template,\n    options\n  ) {\n    var finalOptions = Object.create(baseOptions);\n    var errors = [];\n    var tips = [];\n    finalOptions.warn = function (msg, tip$$1) {\n      (tip$$1 ? tips : errors).push(msg);\n    };\n\n    if (options) {\n      // merge custom modules\n      if (options.modules) {\n        finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n      }\n      // merge custom directives\n      if (options.directives) {\n        finalOptions.directives = extend(\n          Object.create(baseOptions.directives),\n          options.directives\n        );\n      }\n      // copy other options\n      for (var key in options) {\n        if (key !== 'modules' && key !== 'directives') {\n          finalOptions[key] = options[key];\n        }\n      }\n    }\n\n    var compiled = baseCompile(template, finalOptions);\n    if (process.env.NODE_ENV !== 'production') {\n      errors.push.apply(errors, detectErrors(compiled.ast));\n    }\n    compiled.errors = errors;\n    compiled.tips = tips;\n    return compiled\n  }\n\n  function compileToFunctions (\n    template,\n    options,\n    vm\n  ) {\n    options = options || {};\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn(\n            'It seems you are using the standalone build of Vue.js in an ' +\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\n            'The template compiler cannot work in this environment. Consider ' +\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n            'templates into render functions.'\n          );\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters\n      ? String(options.delimiters) + template\n      : template;\n    if (functionCompileCache[key]) {\n      return functionCompileCache[key]\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (process.env.NODE_ENV !== 'production') {\n      if (compiled.errors && compiled.errors.length) {\n        warn(\n          \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n          compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n          vm\n        );\n      }\n      if (compiled.tips && compiled.tips.length) {\n        compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = makeFunction(compiled.render, fnGenErrors);\n    var l = compiled.staticRenderFns.length;\n    res.staticRenderFns = new Array(l);\n    for (var i = 0; i < l; i++) {\n      res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i], fnGenErrors);\n    }\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn(\n          \"Failed to generate render function:\\n\\n\" +\n          fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n        }).join('\\n'),\n          vm\n        );\n      }\n    }\n\n    return (functionCompileCache[key] = res)\n  }\n\n  return {\n    compile: compile,\n    compileToFunctions: compileToFunctions\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (process.env.NODE_ENV !== 'production' && staticClass) {\n    var expression = parseText(staticClass, options.delimiters);\n    if (expression) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.'\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData$1\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      var expression = parseText(staticStyle, options.delimiters);\n      if (expression) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.'\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$2 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$2\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1\n];\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\nvar ref$1 = createCompiler(baseOptions);\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue$3.prototype.$mount;\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        delimiters: options.delimiters\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile end');\n        measure(((this._name) + \" compile\"), 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue$3.compile = compileToFunctions;\n\nexport default Vue$3;\n","\"use strict\";\n\nconst priceCurrencies = [{\n    id: \"dollar_us\",\n    name: \"US Dollar\",\n    label: \"$\",\n    val: 1\n}, {\n    id: \"euro\",\n    name: \"Euro\",\n    label: \"\",\n    val: 0.918603\n}, {\n    id: \"pound\",\n    name: \"Pound\",\n    label: \"\",\n    val: 0.793752\n}, {\n    id: \"dollar_ca\",\n    name: \"Canadian Dollar\",\n    label: \"$\",\n    val: 1.33448\n}, {\n    id: \"dollar_au\",\n    name: \"Australian Dollar\",\n    label: \"$\",\n    val: 1.30931\n}];\n\nexport default priceCurrencies;\n","\"use strict\";\n\nconst priceModes = [{\n    id: \"low\",\n    name: \"Low\",\n}, {\n    id: \"average\",\n    name: \"Average\",\n}, {\n    id: \"high\",\n    name: \"High\",\n}];\n\nexport default priceModes;\n","\"use strict\";\n\nconst deckParts = [{\n    id: \"main\",\n    name: \"Main\",\n    fileId: \"#main\",\n    size: [40, 60]\n}, {\n    id: \"extra\",\n    name: \"Extra\",\n    fileId: \"#extra\",\n    size: [0, 15]\n}, {\n    id: \"side\",\n    name: \"Side\",\n    fileId: \"!side\",\n    size: [0, 15]\n}];\n\nexport default deckParts;\n","\"use strict\";\n\nimport dataPriceCurrencies from \"./data/priceCurrencies\";\nimport dataPriceModes from \"./data/priceModes\";\nimport dataDeckParts from \"./data/deckParts\";\n\nconst appData = {\n    deckparts: dataDeckParts,\n    deck: {\n        name: \"Unnamed\",\n        link: \"\",\n        list: {\n            main: [],\n            extra: [],\n            side: []\n        }\n    },\n    cards: {\n        pairs: [],\n        data: {}\n    },\n    builder: {\n        filter: \"\",\n        pairsFiltered: [],\n    },\n    price: {\n        activeCurrency: \"dollar_us\",\n        modes: dataPriceModes,\n        currencies: dataPriceCurrencies\n    },\n    ajax: {\n        currentlyLoading: false,\n        namesLoaded: false,\n        pricesLoaded: false\n    }\n};\n\nexport default appData;\n","\"use strict\";\n\nconst uriLocationNoParam = function () {\n    return location.origin + location.pathname;\n};\n\nexport default uriLocationNoParam;\n","\"use strict\";\n\nconst eachObject = function (object, fn) {\n    const keys = Object.keys(object);\n    const l = keys.length;\n    let i = 0;\n\n    while (i < l) {\n        const currentKey = keys[i];\n\n        fn(object[currentKey], currentKey, i);\n        i++;\n    }\n};\n\nexport default eachObject;\n","\"use strict\";\n\nimport {\n    nameAPI,\n    imageAPI,\n    buyAPI\n} from \"../data/apiURLs\";\nimport utilEachObject from \"./utilEachObject\";\n\nconst apiLoadNames = function () {\n    const vm = this;\n\n    vm.ajax.currentlyLoading = true;\n    vm.ajax.namesLoaded = false;\n\n    fetch(nameAPI)\n        .then(response => {\n            return response.json();\n        })\n        .then(json => {\n            const resultData = {};\n            const resultPairs = [];\n            const nameStorage = [];\n\n            utilEachObject(json, (name, id) => {\n                resultData[id] = {\n                    name,\n                    img: `${imageAPI}/${id}.jpg`,\n                    link: `${buyAPI}${encodeURI(name)}`,\n                    price: false\n                };\n\n                //Only add each card once to pars, skip alternate arts\n                if (nameStorage.indexOf(name) === -1) {\n                    resultPairs.push([id, name]);\n                }\n\n                nameStorage.push(name);\n            });\n\n            vm.cards.data = resultData;\n            vm.cards.pairs = resultPairs.sort((a, b) => a[1].localeCompare(b[1]));\n            vm.builderUpdateNames();\n\n            vm.ajax.currentlyLoading = false;\n            vm.ajax.namesLoaded = true;\n        });\n};\n\nexport default apiLoadNames;\n","\"use strict\";\n\nexport const nameAPI = \"./api/names/names.min.json\";\nexport const priceAPI = \"./api/prices/prices.php?n=\";\nexport const imageAPI = \"https://ygoprodeck.com/pics\";\nexport const buyAPI = \"http://yugiohprices.com/card_price?name=\";\n","\"use strict\";\n\nimport {\n    priceAPI\n} from \"../data/apiURLs\";\n//import utilEachObject from \"./utilEachObject\";\n\nconst apiLoadPrices = function () {\n    const vm = this;\n    //Array of unique ids, minus the ones where prices were already loaded\n    const cardIds = vm.deckCardsWithoutPriceData();\n\n    if (cardIds.length > 0) {\n        const cardNames = cardIds.map(cardId => vm.cards.data[cardId].name);\n        const priceQuery = btoa(JSON.stringify(cardNames));\n\n        vm.ajax.currentlyLoading = true;\n        vm.ajax.pricesLoaded = false;\n\n        fetch(priceAPI + priceQuery)\n            .then(response => {\n                return response.json();\n            })\n            .then(json => {\n                cardIds.forEach((id, index) => {\n                    const priceData = json[index];\n                    const card = vm.cards.data[id];\n\n                    if (card) {\n                        card.price = {\n                            low: priceData.low,\n                            average: priceData.average,\n                            high: priceData.high\n                        };\n                    }\n                });\n\n                vm.ajax.currentlyLoading = false;\n                vm.ajax.pricesLoaded = true;\n            });\n    } else {\n        vm.ajax.pricesLoaded = true;\n    }\n};\n\nexport default apiLoadPrices;\n","\"use strict\";\n\nimport deckParts from \"../data/deckParts\";\n\nconst convertFileToDeck = function (fileContent) {\n    const fileContentTrimmed = fileContent.replace(/#created.+/, \"\").trim();\n    const arr = fileContentTrimmed.split(/[#!].+/g).splice(1);\n    const arrParts = arr.map(part => part.split(\"\\n\").filter(line => line.length > 1).map(Number));\n    const result = {};\n\n    deckParts.forEach((deckpart, index) => {\n        result[deckpart.id] = arrParts[index];\n    });\n\n    return result;\n};\n\nexport default convertFileToDeck;\n","\"use strict\";\n\nimport convertFileToDeck from \"./convertFileToDeck\";\n\nconst deckLoad = function (file) {\n    const reader = new FileReader();\n    const vm = this;\n\n    reader.onload = function (e) {\n        const fileContent = e.target.result;\n        const deckList = convertFileToDeck(fileContent);\n\n        vm.deck.name = file.name.replace(\".ydk\", \"\");\n        vm.deck.list = deckList;\n        vm.deckUpdate();\n    };\n\n    reader.readAsText(file);\n};\n\nexport default deckLoad;\n","\"use strict\";\n\nimport deckParts from \"../data/deckParts\";\n\nconst uriDeckDecode = function (deckUri) {\n    const deckArray = JSON.parse(atob(deckUri.replace(\"?d=\", \"\")));\n    const deckList = {};\n\n    deckParts.forEach((deckpart, index) => {\n        deckList[deckpart.id] = deckArray[1][index];\n    });\n\n    return [deckArray[0], deckList];\n};\n\nexport default uriDeckDecode;\n","\"use strict\";\n\nimport uriDeckDecode from \"./uriDeckDecode\";\n\nconst deckLoadUri = function (uriDeck) {\n    const vm = this;\n    const deckArray = uriDeckDecode(uriDeck);\n\n    vm.deck.name = deckArray[0];\n    vm.deck.list = deckArray[1];\n    vm.deckUpdate(uriDeck);\n};\n\nexport default deckLoadUri;\n","\"use strict\";\n\n\nconst uriDeckEncode = function (deck) {\n    const deckArray = [deck.name, Object.values(deck.list)];\n    const deckUri = btoa(JSON.stringify(deckArray));\n\n    return \"?d=\" + deckUri;\n};\n\nexport default uriDeckEncode;\n","\"use strict\";\n\nimport uriDeckEncode from \"./uriDeckEncode\";\n\nconst deckUpdate = function (deckLink) {\n    const vm = this;\n\n    vm.deck.link = deckLink || uriDeckEncode(vm.deck);\n    vm.ajax.pricesLoaded = false;\n};\n\nexport default deckUpdate;\n","\"use strict\";\n\nimport utilEachObject from \"./utilEachObject\";\n\nconst deckCardsWithoutPriceData = function () {\n    const vm = this;\n    const data = vm.cards.data;\n    const result = [];\n\n    utilEachObject(vm.deck.list, deckpart => {\n        deckpart.forEach(cardId => {\n            if (result.indexOf(cardId) === -1 && !data[cardId].price) {\n                result.push(cardId);\n            }\n        });\n    });\n\n    return result;\n};\n\nexport default deckCardsWithoutPriceData;\n","\"use strict\";\n\nconst priceConvert = function (price) {\n    const vm = this;\n    const currency = vm.price.currencies.find(item => item.id === vm.price.activeCurrency);\n    const val = (price * currency.val).toFixed(2);\n\n    return val + currency.label;\n};\n\nexport default priceConvert;\n","\"use strict\";\n\nconst priceForCard = function (id, mode) {\n    const vm = this;\n    const price = vm.cards.data[id].price[mode];\n\n    if (price) {\n        return vm.priceConvert(price);\n    } else {\n        return \"Not found\";\n    }\n};\n\nexport default priceForCard;\n","\"use strict\";\n\nimport utilEachObject from \"./utilEachObject\";\n\nconst priceForSection = function (section, mode) {\n    const priceSum = function (arr) {\n        let result = 0;\n\n        if (arr && arr.length) {\n            arr.forEach(id => {\n                const cardData = vm.cards.data[id];\n                if (cardData && cardData.price && cardData.price[mode]) {\n                    result += cardData.price[mode];\n                }\n            });\n        }\n\n        return result;\n    };\n    const vm = this;\n    let price = 0;\n\n    if (section === \"*\") {\n        utilEachObject(vm.deck.list, deckpart => {\n            price += priceSum(deckpart);\n        });\n    } else {\n        price = priceSum(vm.deck.list[section]);\n    }\n\n    return vm.priceConvert(price);\n};\n\nexport default priceForSection;\n","\"use strict\";\n\nconst builderUpdateNames = function () {\n    const vm = this;\n    const filter = vm.builder.filter.toLowerCase();\n    let result = vm.cards.pairs.filter(card => {\n        return card[1].toLowerCase().indexOf(filter) !== -1;\n    });\n\n    if (result.length > 500) {\n        result = result.splice(0, 500);\n    }\n\n    vm.builder.pairsFiltered = result;\n};\n\nexport default builderUpdateNames;\n","\"use strict\";\n\nconst builderDeckAdd = function (id, part) {\n    const vm = this;\n    const cardId = Number(id);\n    const deckPart = vm.deck.list[part];\n    const deckPartMax = vm.deckparts.find(deckpart => deckpart.id === part).size[1];\n\n    if (deckPart.length < deckPartMax && deckPart.filter(id => id === cardId).length < 3) {\n        deckPart.push(cardId);\n        vm.deckUpdate();\n    }\n};\n\nexport default builderDeckAdd;\n","\"use strict\";\n\nconst builderDeckRemove = function (id, part) {\n    const vm = this;\n    let foundCard = false;\n\n    vm.deck.list[part] = vm.deck.list[part].filter(cardId => {\n        if (!foundCard) {\n            if (id === cardId) {\n                foundCard = true;\n                return false;\n            }\n        }\n        return true;\n    });\n    vm.deckUpdate();\n};\n\nexport default builderDeckRemove;\n","/* FileSaver.js\n * A saveAs() FileSaver implementation.\n * 1.3.2\n * 2016-06-16 18:25:19\n *\n * By Eli Grey, http://eligrey.com\n * License: MIT\n *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md\n */\n\n/*global self */\n/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */\n\n/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */\n\nvar saveAs = saveAs || (function(view) {\n\t\"use strict\";\n\t// IE <10 is explicitly unsupported\n\tif (typeof view === \"undefined\" || typeof navigator !== \"undefined\" && /MSIE [1-9]\\./.test(navigator.userAgent)) {\n\t\treturn;\n\t}\n\tvar\n\t\t  doc = view.document\n\t\t  // only get URL when necessary in case Blob.js hasn't overridden it yet\n\t\t, get_URL = function() {\n\t\t\treturn view.URL || view.webkitURL || view;\n\t\t}\n\t\t, save_link = doc.createElementNS(\"http://www.w3.org/1999/xhtml\", \"a\")\n\t\t, can_use_save_link = \"download\" in save_link\n\t\t, click = function(node) {\n\t\t\tvar event = new MouseEvent(\"click\");\n\t\t\tnode.dispatchEvent(event);\n\t\t}\n\t\t, is_safari = /constructor/i.test(view.HTMLElement) || view.safari\n\t\t, is_chrome_ios =/CriOS\\/[\\d]+/.test(navigator.userAgent)\n\t\t, throw_outside = function(ex) {\n\t\t\t(view.setImmediate || view.setTimeout)(function() {\n\t\t\t\tthrow ex;\n\t\t\t}, 0);\n\t\t}\n\t\t, force_saveable_type = \"application/octet-stream\"\n\t\t// the Blob API is fundamentally broken as there is no \"downloadfinished\" event to subscribe to\n\t\t, arbitrary_revoke_timeout = 1000 * 40 // in ms\n\t\t, revoke = function(file) {\n\t\t\tvar revoker = function() {\n\t\t\t\tif (typeof file === \"string\") { // file is an object URL\n\t\t\t\t\tget_URL().revokeObjectURL(file);\n\t\t\t\t} else { // file is a File\n\t\t\t\t\tfile.remove();\n\t\t\t\t}\n\t\t\t};\n\t\t\tsetTimeout(revoker, arbitrary_revoke_timeout);\n\t\t}\n\t\t, dispatch = function(filesaver, event_types, event) {\n\t\t\tevent_types = [].concat(event_types);\n\t\t\tvar i = event_types.length;\n\t\t\twhile (i--) {\n\t\t\t\tvar listener = filesaver[\"on\" + event_types[i]];\n\t\t\t\tif (typeof listener === \"function\") {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlistener.call(filesaver, event || filesaver);\n\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\tthrow_outside(ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t, auto_bom = function(blob) {\n\t\t\t// prepend BOM for UTF-8 XML and text/* types (including HTML)\n\t\t\t// note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF\n\t\t\tif (/^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(blob.type)) {\n\t\t\t\treturn new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});\n\t\t\t}\n\t\t\treturn blob;\n\t\t}\n\t\t, FileSaver = function(blob, name, no_auto_bom) {\n\t\t\tif (!no_auto_bom) {\n\t\t\t\tblob = auto_bom(blob);\n\t\t\t}\n\t\t\t// First try a.download, then web filesystem, then object URLs\n\t\t\tvar\n\t\t\t\t  filesaver = this\n\t\t\t\t, type = blob.type\n\t\t\t\t, force = type === force_saveable_type\n\t\t\t\t, object_url\n\t\t\t\t, dispatch_all = function() {\n\t\t\t\t\tdispatch(filesaver, \"writestart progress write writeend\".split(\" \"));\n\t\t\t\t}\n\t\t\t\t// on any filesys errors revert to saving with object URLs\n\t\t\t\t, fs_error = function() {\n\t\t\t\t\tif ((is_chrome_ios || (force && is_safari)) && view.FileReader) {\n\t\t\t\t\t\t// Safari doesn't allow downloading of blob urls\n\t\t\t\t\t\tvar reader = new FileReader();\n\t\t\t\t\t\treader.onloadend = function() {\n\t\t\t\t\t\t\tvar url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');\n\t\t\t\t\t\t\tvar popup = view.open(url, '_blank');\n\t\t\t\t\t\t\tif(!popup) view.location.href = url;\n\t\t\t\t\t\t\turl=undefined; // release reference before dispatching\n\t\t\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t\t\t\tdispatch_all();\n\t\t\t\t\t\t};\n\t\t\t\t\t\treader.readAsDataURL(blob);\n\t\t\t\t\t\tfilesaver.readyState = filesaver.INIT;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// don't create more object URLs than needed\n\t\t\t\t\tif (!object_url) {\n\t\t\t\t\t\tobject_url = get_URL().createObjectURL(blob);\n\t\t\t\t\t}\n\t\t\t\t\tif (force) {\n\t\t\t\t\t\tview.location.href = object_url;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar opened = view.open(object_url, \"_blank\");\n\t\t\t\t\t\tif (!opened) {\n\t\t\t\t\t\t\t// Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html\n\t\t\t\t\t\t\tview.location.href = object_url;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t\tdispatch_all();\n\t\t\t\t\trevoke(object_url);\n\t\t\t\t}\n\t\t\t;\n\t\t\tfilesaver.readyState = filesaver.INIT;\n\n\t\t\tif (can_use_save_link) {\n\t\t\t\tobject_url = get_URL().createObjectURL(blob);\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tsave_link.href = object_url;\n\t\t\t\t\tsave_link.download = name;\n\t\t\t\t\tclick(save_link);\n\t\t\t\t\tdispatch_all();\n\t\t\t\t\trevoke(object_url);\n\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfs_error();\n\t\t}\n\t\t, FS_proto = FileSaver.prototype\n\t\t, saveAs = function(blob, name, no_auto_bom) {\n\t\t\treturn new FileSaver(blob, name || blob.name || \"download\", no_auto_bom);\n\t\t}\n\t;\n\t// IE 10+ (native saveAs)\n\tif (typeof navigator !== \"undefined\" && navigator.msSaveOrOpenBlob) {\n\t\treturn function(blob, name, no_auto_bom) {\n\t\t\tname = name || blob.name || \"download\";\n\n\t\t\tif (!no_auto_bom) {\n\t\t\t\tblob = auto_bom(blob);\n\t\t\t}\n\t\t\treturn navigator.msSaveOrOpenBlob(blob, name);\n\t\t};\n\t}\n\n\tFS_proto.abort = function(){};\n\tFS_proto.readyState = FS_proto.INIT = 0;\n\tFS_proto.WRITING = 1;\n\tFS_proto.DONE = 2;\n\n\tFS_proto.error =\n\tFS_proto.onwritestart =\n\tFS_proto.onprogress =\n\tFS_proto.onwrite =\n\tFS_proto.onabort =\n\tFS_proto.onerror =\n\tFS_proto.onwriteend =\n\t\tnull;\n\n\treturn saveAs;\n}(\n\t   typeof self !== \"undefined\" && self\n\t|| typeof window !== \"undefined\" && window\n\t|| this.content\n));\n// `self` is undefined in Firefox for Android content script context\n// while `this` is nsIContentFrameMessageManager\n// with an attribute `content` that corresponds to the window\n\nif (typeof module !== \"undefined\" && module.exports) {\n  module.exports.saveAs = saveAs;\n} else if ((typeof define !== \"undefined\" && define !== null) && (define.amd !== null)) {\n  define(\"FileSaver.js\", function() {\n    return saveAs;\n  });\n}\n","\"use strict\";\n\nimport deckParts from \"../data/deckParts\";\n\nconst convertDeckToFile = function (deckList) {\n    let result = [];\n\n    deckParts.forEach(deckpart => {\n        result.push(deckpart.fileId);\n        result = result.concat(deckList[deckpart.id]);\n    });\n\n    return result.join(\"\\n\");\n};\n\nexport default convertDeckToFile;\n","\"use strict\";\n\nimport FileSaver from \"file-saver/FileSaver.js\";\n\nimport convertDeckToFile from \"./convertDeckToFile.js\";\n\nconst fileDownloadDeck = function () {\n    const vm = this;\n    const fileData = convertDeckToFile(vm.deck.list);\n    const file = new File([fileData], vm.deck.name + \".ydk\", {\n        type: \"text/ydk\"\n    });\n\n    return FileSaver.saveAs(file);\n};\n\nexport default fileDownloadDeck;\n","\"use strict\";\n\nimport uriLocationNoParam from \"./methods/uriLocationNoParam\";\n\nimport apiLoadNames from \"./methods/apiLoadNames\";\nimport apiLoadPrices from \"./methods/apiLoadPrices\";\n\nimport deckLoad from \"./methods/deckLoad\";\nimport deckLoadUri from \"./methods/deckLoadUri\";\nimport deckUpdate from \"./methods/deckUpdate\";\nimport deckCardsWithoutPriceData from \"./methods/deckCardsWithoutPriceData\";\n\nimport priceConvert from \"./methods/priceConvert\";\nimport priceForCard from \"./methods/priceForCard\";\nimport priceForSection from \"./methods/priceForSection\";\n\nimport builderUpdateNames from \"./methods/builderUpdateNames\";\nimport builderDeckAdd from \"./methods/builderDeckAdd\";\nimport builderDeckRemove from \"./methods/builderDeckRemove\";\n\nimport fileDownloadDeck from \"./methods/fileDownloadDeck\";\n\nconst appMethods = {\n    uriLocationNoParam,\n\n    apiLoadNames,\n    apiLoadPrices,\n\n    deckLoad,\n    deckLoadUri,\n    deckUpdate,\n    deckCardsWithoutPriceData,\n\n    priceConvert,\n    priceForCard,\n    priceForSection,\n\n    builderUpdateNames,\n    builderDeckAdd,\n    builderDeckRemove,\n\n    fileDownloadDeck,\n\n    onFileChange(e) {\n        const vm = this;\n        const files = e.target.files || e.dataTransfer.files;\n\n        vm.deckLoad(files[0]);\n    }\n};\n\nexport default appMethods;\n","\"use strict\";\n\nimport Vue from \"Vue/dist/vue.esm.js\";\nimport appData from \"./appData\";\nimport appMethods from \"./appMethods\";\n\n//ready-event required because ygoprodeck.com loads scripts in head\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n    const urlQuery = location.search;\n    const priceApp = new Vue({\n        el: \"#app\",\n        data: appData,\n        methods: appMethods\n    });\n\n    priceApp.apiLoadNames();\n\n    if (urlQuery.indexOf(\"?d\") !== -1) {\n        priceApp.deckLoadUri(urlQuery);\n    }\n});\n"],"names":["_toString","val","JSON","stringify","String","toNumber","n","parseFloat","isNaN","makeMap","str","expectsLowerCase","map","Object","create","list","split","i","length","toLowerCase","remove","arr","item","index","indexOf","splice","hasOwn","obj","key","hasOwnProperty","call","isPrimitive","value","cached","fn","cache","bind","ctx","boundFn","a","l","arguments","apply","_length","toArray","start","ret","Array","extend","to","_from","isObject","isPlainObject","toString","OBJECT_STRING","toObject","res","noop","looseEqual","b","isObjectA","isObjectB","e","looseIndexOf","once","called","isReserved","c","charCodeAt","def","enumerable","defineProperty","parsePath","path","bailRE","test","segments","isNative","Ctor","pushTarget","_target","Dep","target","push","popTarget","targetStack","pop","protoAugment","src","__proto__","copyAugment","keys","observe","asRootData","ob","__ob__","Observer","observerState","shouldConvert","isServerRendering","isArray","isExtensible","_isVue","vmCount","defineReactive$$1","customSetter","dep","property","getOwnPropertyDescriptor","configurable","getter","get","setter","set","childOb","depend","newVal","notify","Math","max","del","dependArray","mergeData","from","toVal","fromVal","mergeHook","parentVal","childVal","concat","mergeAssets","normalizeProps","options","props","name","camelize","type","normalizeDirectives","dirs","directives","update","mergeOptions","parent","child","vm","mergeField","strat","strats","defaultStrat","extendsFrom","extends","mixins","mixin","prototype","Vue$3","resolveAsset","id","warnMissing","assets","camelizedId","PascalCaseId","capitalize","validateProp","propOptions","propsData","prop","absent","isType","Boolean","hyphenate","undefined","getPropDefaultValue","prevShouldConvert","default","$options","_props","getType","match","len","handleError","err","info","config","errorHandler","inBrowser","console","error","createTextVNode","VNode","cloneVNode","vnode","cloned","tag","data","children","text","elm","context","componentOptions","ns","isStatic","isCloned","cloneVNodes","vnodes","createFnInvoker","fns","invoker","arguments$1","updateListeners","on","oldOn","add","remove$$1","cur","old","event","normalizeEvent","capture","mergeVNodeHook","hookKey","hook","wrappedHook","this","oldHook","merged","simpleNormalizeChildren","normalizeChildren","normalizeArrayChildren","nestedIndex","last","getFirstComponentChild","filter","initEvents","_events","_hasHookEvent","listeners","_parentListeners","once$$1","$once","$on","remove$1","$off","updateComponentListeners","oldListeners","resolveSlots","slots","defaultSlot","functionalContext","slot","every","isWhitespace","node","isComment","resolveScopedSlots","initLifecycle","abstract","$parent","$children","$root","$refs","_watcher","_inactive","_directInactive","_isMounted","_isDestroyed","_isBeingDestroyed","mountComponent","el","hydrating","$el","render","createEmptyVNode","updateComponent","_update","_render","Watcher","$vnode","updateChildComponent","parentVnode","renderChildren","hasChildren","_renderChildren","scopedSlots","$scopedSlots","emptyObject","_parentVnode","_vnode","propKeys","_propKeys","$slots","$forceUpdate","isInInactiveTree","activateChildComponent","direct","deactivateChildComponent","callHook","handlers","j","$emit","resetSchedulerState","flushing","flushSchedulerQueue","watcher","sort","queue","run","oldQueue","slice","devtools","emit","queueWatcher","has","waiting","traverse","clear","seenObjects","_traverse","seen","isA","depId","proxy","sourceKey","sharedPropertyDefinition","initState","_watchers","opts","methods","_data","computed","watch","initProps","propsOptions","isRoot","initData","getData","initComputed","watchers","_computedWatchers","userDef","computedWatcherOptions","defineComputed","createComputedGetter","dirty","evaluate","initMethods","initWatch","handler","createWatcher","$watch","createComponent","baseCtor","_base","cid","resolved","resolveAsyncComponent","model","extractProps","functional","createFunctionalComponent","nativeOn","_context","h","d","createElement","createComponentInstanceForVnode","parentElm","refElm","vnodeComponentOptions","inlineTemplate","staticRenderFns","factory","cb","requested","cbs","pendingCallbacks","sync","resolve","reject","reason","then","attrs","domProps","altKey","checkProp","hash","preserve","mergeHooks","hooksToMerge","fromParent","ours","componentVNodeHooks","mergeHook$1","one","two","transformModel","callback","normalizationType","alwaysNormalize","ALWAYS_NORMALIZE","_createElement","SIMPLE_NORMALIZE","getTagNamespace","isReservedTag","parsePlatformTagName","applyNS","renderList","renderSlot","fallback","bindObject","scopedSlotFn","slotNodes","resolveFilter","identity","checkKeyCodes","eventKeyCode","builtInAlias","keyCodes","bindObjectProps","asProp","mustUseProp","renderStatic","isInFor","tree","_staticTrees","_renderProxy","markOnce","markStatic","isOnce","markStaticNode","initRender","renderContext","_c","$createElement","initProvide","provide","_provided","initInjections","inject","hasSymbol","Reflect","ownKeys","provideKey","source","initInternalComponent","constructor","_componentTag","_parentElm","_refElm","resolveConstructorOptions","super","superOptions","modifiedOptions","resolveModifiedOptions","extendOptions","components","modified","latest","sealed","sealedOptions","dedupe","_init","initUse","Vue","use","plugin","installed","args","unshift","install","initMixin$1","initExtend","Super","SuperId","cachedCtors","_Ctor","Sub","_assetTypes","forEach","initProps$1","Comp","initComputed$1","initAssetRegisters","definition","getComponentName","matches","pattern","RegExp","pruneCache","cachedNode","pruneCacheEntry","componentInstance","$destroy","genClassForVnode","parentNode","childNode","mergeClassData","genClassFromData","staticClass","class","dynamicClass","stringifyClass","stringified","isSVG","isUnknownElement","unknownElementCache","document","window","HTMLUnknownElement","HTMLElement","query","selected","querySelector","createElement$1","tagName","multiple","setAttribute","createElementNS","namespace","namespaceMap","createTextNode","createComment","insertBefore","newNode","referenceNode","removeChild","appendChild","nextSibling","setTextContent","textContent","registerRef","isRemoval","ref","refs","refInFor","isUndef","v","isDef","isTrue","sameVnode","sameInputType","createKeyToOldIdx","beginIdx","endIdx","updateDirectives","oldVnode","oldDir","dir","isCreate","emptyNode","isDestroy","oldDirs","normalizeDirectives$1","newDirs","dirsWithInsert","dirsWithPostpatch","oldValue","componentUpdated","inserted","callInsert","modifiers","emptyModifiers","getRawDirName","rawName","join","callHook$1","updateAttrs","oldAttrs","isIE9","isXlink","removeAttributeNS","xlinkNS","getXlinkProp","isEnumeratedAttr","removeAttribute","setAttr","isBooleanAttr","isFalsyAttrValue","setAttributeNS","updateClass","oldData","cls","transitionClass","_transitionClasses","_prevClass","parseFilters","exp","pushFilter","filters","lastFilterIndex","trim","prev","expression","inSingle","inDouble","inTemplateString","inRegex","curly","square","paren","p","charAt","validDivisionCharRE","wrapFilter","baseWarn","msg","pluckModuleFunction","modules","m","_","addProp","addAttr","addDirective","arg","addHandler","important","events","native","nativeEvents","newHandler","getBindingAttr","getStatic","dynamicValue","getAndRemoveAttr","staticValue","attrsMap","attrsList","genComponentModel","number","valueExpression","assignment","genAssignmentCode","modelRs","parseModel","idx","expressionPos","expressionEndPos","lastIndexOf","eof","next","isStringStart","chr","substring","index$1","parseBracket","inBracket","parseString","stringQuote","_warn","genCheckboxModel","valueBinding","trueValueBinding","falseValueBinding","CHECKBOX_RADIO_TOKEN","genRadioModel","genSelect","selectedVal","code","genDefaultModel","lazy","needCompositionGuard","RANGE_TOKEN","normalizeEvents","isIE","isChrome","add$1","oldHandler","target$1","ev","addEventListener","remove$2","removeEventListener","updateDOMListeners","updateDOMProps","oldProps","_value","strCur","shouldUpdateValue","checkVal","composing","isDirty","isInputChanged","activeElement","_vModifiers","normalizeStyleData","style","normalizeStyleBinding","staticStyle","bindingStyle","parseStyleText","getStyle","checkChild","styleData","updateStyle","oldStaticStyle","oldStyleBinding","oldStyle","newStyle","addClass","classList","getAttribute","removeClass","tar","replace","resolveTransition","def$$1","css","autoCssTransition","nextFrame","addTransitionClass","removeTransitionClass","whenTransitionEnds","expectedType","getTransitionInfo","timeout","propCount","TRANSITION","transitionEndEvent","animationEndEvent","ended","end","onEnd","styles","getComputedStyle","transitionDelays","transitionProp","transitionDurations","transitionTimeout","getTimeout","animationDelays","animationProp","animationDurations","animationTimeout","ANIMATION","transformRE","delays","durations","toMs","s","Number","enter","toggleDisplay","_leaveCb","cancelled","transition","_enterCb","nodeType","enterClass","enterToClass","enterActiveClass","appearClass","appearToClass","appearActiveClass","beforeEnter","afterEnter","enterCancelled","beforeAppear","appear","afterAppear","appearCancelled","duration","activeInstance","transitionNode","isAppear","isRootInsert","startClass","activeClass","toClass","beforeEnterHook","enterHook","afterEnterHook","enterCancelledHook","explicitEnterDuration","expectsCSS","userWantsControl","getHookArgumentsLength","show","pendingNode","_pending","isValidDuration","leave","rm","performLeave","beforeLeave","leaveClass","leaveActiveClass","leaveToClass","explicitLeaveDuration","afterLeave","leaveCancelled","delayLeave","invokerFns","_enter","setSelected","binding","isMultiple","option","getValue","selectedIndex","hasNoMatchingOption","onCompositionStart","onCompositionEnd","trigger","createEvent","initEvent","dispatchEvent","locateNode","getRealChild","compOptions","extractTransitionData","comp","key$1","placeholder","rawChild","hasParentTransition","isSameChild","oldChild","callPendingCbs","_moveCb","recordPosition","newPos","getBoundingClientRect","applyTranslation","oldPos","pos","dx","left","dy","top","moved","transform","WebkitTransform","transitionDuration","decode","html","decoder","innerHTML","decodeAttr","shouldDecodeNewlines","re","encodedAttrWithNewLines","encodedAttr","decodingMap","parseHTML","advance","parseEndTag","lowerCasedTagName","stack","lowerCasedTag","lastTag","expectHTML","isUnaryTag$$1","isUnaryTag","no","canBeLeftOpenTag$$1","canBeLeftOpenTag","isPlainTextElement","stackedTag","reStackedTag","reCache","endTagLength","rest","all","endTag","chars","textEnd","comment","commentEnd","conditionalComment","conditionalEnd","doctypeMatch","doctype","endTagMatch","curIndex","startTagMatch","startTagOpen","attr","startTagClose","attribute","unarySlash","isNonPhrasingTag","unary","IS_REGEX_CAPTURING_BROKEN","rest$1","parseText","delimiters","tagRE","buildRegex","defaultTagRE","tokens","lastIndex","exec","parse","template","endPre","element","pre","platformIsPreTag","warn","isPreTag","root","currentParent","preserveWhitespace","inVPre","inPre","warn$2","platformGetTagNamespace","guardIESVGBug","makeAttrsMap","isForbiddenTag","forbidden","preTransforms","plain","i$1","transforms","if","elseif","else","slotScope","slotTarget","i$2","postTransforms","lastNode","decodeHTMLCached","processPre","processRawAttrs","processKey","processRef","checkInFor","processFor","inMatch","forAliasRE","for","alias","iteratorMatch","forIteratorRE","iterator1","iterator2","processIf","processIfConditions","findPrevElement","addIfCondition","condition","ifConditions","processOnce","processSlot","slotName","processComponent","component","processAttrs","isProp","dirRE","hasBindings","parseModifiers","modifierRE","bindRE","camel","platformMustUseProp","onRE","argMatch","argRE","ieNSBug","ieNSPrefix","optimize","genStaticKeysCached","staticKeys","genStaticKeys$1","markStatic$1","static","isPlatformReservedTag","markStaticRoots","staticInFor","staticRoot","walkThroughConditionsBlocks","conditionBlocks","block","isBuiltInTag","isDirectChildOfTemplateFor","isStaticKey","genHandlers","genHandler","isMethodPath","simplePathRE","isFunctionExpression","fnExpRE","genModifierCode","modifierCode","genKeyFilter","genFilterCode","keyVal","parseInt","bind$1","wrapData","generate","ast","prevStaticRenderFns","currentStaticRenderFns","prevOnceCount","onceCount","genElement","staticProcessed","genStatic","onceProcessed","genOnce","forProcessed","genFor","ifProcessed","genIf","genSlot","genComponent","genData","genChildren","transforms$1","genIfConditions","conditions","genTernaryExp","shift","genDirectives","dataGenFns","genProps","genScopedSlots","genInlineTemplate","needRuntime","hasRuntime","gen","platformDirectives$1","baseDirectives","warn$3","inlineRenderFns","currentOptions","genScopedSlot","scope","checkSkip","el$1","getNormalizationType","genNode","needsNormalization","some","maybeComponent","isPlatformReservedTag$1","genText","transformSpecialNewlines","bind$$1","componentName","baseCompile","makeFunction","errors","Function","transformNode","classBinding","genData$1","transformNode$1","styleBinding","genData$2","getOuterHTML","outerHTML","container","cloneNode","_isServer","_Set","toUpperCase","freeze","hasProto","UA","navigator","userAgent","isEdge","isAndroid","isIOS","global","env","VUE_ENV","__VUE_DEVTOOLS_GLOBAL_HOOK__","Symbol","nextTick","nextTickHandler","copies","callbacks","timerFunc","pending","Promise","logError","catch","MutationObserver","counter","observer","textNode","_resolve","Set","uid$1","subs","addSub","sub","removeSub","addDep","arrayProto","arrayMethods","method","original","result","observeArray","arrayKeys","getOwnPropertyNames","walk","items","optionMergeStrategies","instanceData","defaultData","_lifecycleHooks","raw","prototypeAccessors","defineProperties","uid$2","expOrFn","deep","user","active","deps","newDeps","depIds","newDepIds","cleanupDeps","this$1","tmp","teardown","$mount","keepAlive","mountedNode","prepatch","uid","_uid","_isComponent","_self","dataDef","propsDef","$set","$delete","immediate","hookRE","prevEl","prevVnode","prevActiveInstance","__patch__","__vue__","$nextTick","_o","_n","_s","_l","_t","_q","_i","_m","_f","_k","_b","_v","_e","_u","patternTypes","KeepAlive","include","exclude","builtInComponents","configDef","util","delete","version","warn$1","testEl","acceptValue","isHTMLTag","nodeOps","hooks","baseModules","klass","cssText","cssVarRE","importantRE","setProp","setProperty","normalize","prefixes","upper","prefixed","hasTransition","ontransitionend","onwebkittransitionend","onanimationend","onwebkitanimationend","raf","requestAnimationFrame","setTimeout","platformModules","patch","backend","emptyNodeAt","createRmCb","childElm","removeNode","createElm","insertedVnodeQueue","nested","isReactivated","init","initComponent","pendingInsert","isPatchable","reactivateComponent","innerNode","activate","insert","createChildren","invokeCreateHooks","setScope","ancestor","_scopeId","addVnodes","startIdx","invokeDestroyHook","destroy","removeVnodes","ch","removeAndInvokeRemoveHook","updateChildren","oldCh","newCh","removeOnly","oldKeyToIdx","idxInOld","elmToMove","oldStartIdx","newStartIdx","oldEndIdx","oldStartVnode","oldEndVnode","newEndIdx","newStartVnode","newEndVnode","canMove","patchVnode","postpatch","invokeInsertHook","initial","hydrate","hasChildNodes","childrenMatch","firstChild","isRenderedModule","isInitialPatch","isRealElement","hasAttribute","oldElm","parentElm$1","vmodel","model$1","originalDisplay","__vOriginalDisplay","display","platformDirectives","transitionProps","Transition","mode","_leaving","oldRawChild","delayedLeave","TransitionGroup","prevChildren","rawChildren","transitionData","kept","removed","c$1","moveClass","hasMove","body","offsetHeight","propertyName","_hasMove","clone","hasTransform","platformComponents","content","encoded","div","singleAttrValues","ncname","g","open","close","genGuard","klass$1","style$1","modules$1","directives$1","baseOptions","reduce","ref$1","compile","finalOptions","tips","tip$$1","compiled","compileToFunctions","functionCompileCache","fnGenErrors","idToTemplate","mount","documentElement","priceCurrencies","priceModes","deckParts","appData","dataDeckParts","dataPriceModes","dataPriceCurrencies","uriLocationNoParam","location","origin","pathname","eachObject","object","currentKey","apiLoadNames","ajax","currentlyLoading","namesLoaded","response","json","resultData","resultPairs","nameStorage","imageAPI","encodeURI","cards","pairs","localeCompare","builderUpdateNames","apiLoadPrices","cardIds","deckCardsWithoutPriceData","cardNames","cardId","priceQuery","btoa","pricesLoaded","priceData","card","price","low","average","high","convertFileToDeck","fileContent","fileContentTrimmed","arrParts","part","line","deckpart","deckLoad","file","reader","FileReader","onload","deckList","deck","deckUpdate","readAsText","uriDeckDecode","deckUri","deckArray","atob","deckLoadUri","uriDeck","uriDeckEncode","values","deckLink","link","priceConvert","currency","currencies","find","activeCurrency","toFixed","label","priceForCard","priceForSection","section","priceSum","cardData","builder","pairsFiltered","builderDeckAdd","deckPart","deckPartMax","deckparts","size","builderDeckRemove","foundCard","saveAs","view","doc","get_URL","URL","webkitURL","save_link","can_use_save_link","click","MouseEvent","is_safari","safari","is_chrome_ios","throw_outside","ex","setImmediate","revoke","revoker","revokeObjectURL","dispatch","filesaver","event_types","listener","auto_bom","blob","Blob","fromCharCode","FileSaver","no_auto_bom","object_url","force","dispatch_all","readyState","INIT","createObjectURL","href","download","DONE","onloadend","url","readAsDataURL","FS_proto","msSaveOrOpenBlob","abort","WRITING","onwritestart","onprogress","onwrite","onabort","onerror","onwriteend","self","module","exports","convertDeckToFile","fileId","fileDownloadDeck","fileData","File","appMethods","files","dataTransfer","urlQuery","search","priceApp"],"mappings":"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","preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjpudWxsLCJzb3VyY2VzIjpbIkM6L3hhbXBwL2h0ZG9jcy93b3Jrc3BhY2UveWdvZGVja3ByaWNlL25vZGVfbW9kdWxlcy9WdWUvZGlzdC92dWUuZXNtLmpzIiwiQzoveGFtcHAvaHRkb2NzL3dvcmtzcGFjZS95Z29kZWNrcHJpY2Uvc3JjL2pzL2RhdGEvcHJpY2VDdXJyZW5jaWVzLmpzIiwiQzoveGFtcHAvaHRkb2NzL3dvcmtzcGFjZS95Z29kZWNrcHJpY2Uvc3JjL2pzL2RhdGEvcHJpY2VNb2Rlcy5qcyIsIkM6L3hhbXBwL2h0ZG9jcy93b3Jrc3BhY2UveWdvZGVja3ByaWNlL3NyYy9qcy9kYXRhL2RlY2tQYXJ0cy5qcyIsIkM6L3hhbXBwL2h0ZG9jcy93b3Jrc3BhY2UveWdvZGVja3ByaWNlL3NyYy9qcy9hcHBEYXRhLmpzIiwiQzoveGFtcHAvaHRkb2NzL3dvcmtzcGFjZS95Z29kZWNrcHJpY2Uvc3JjL2pzL21ldGhvZHMvdXJpTG9jYXRpb25Ob1BhcmFtLmpzIiwiQzoveGFtcHAvaHRkb2NzL3dvcmtzcGFjZS95Z29kZWNrcHJpY2Uvc3JjL2pzL21ldGhvZHMvdXRpbEVhY2hPYmplY3QuanMiLCJDOi94YW1wcC9odGRvY3Mvd29ya3NwYWNlL3lnb2RlY2twcmljZS9zcmMvanMvbWV0aG9kcy9hcGlMb2FkTmFtZXMuanMiLCJDOi94YW1wcC9odGRvY3Mvd29ya3NwYWNlL3lnb2RlY2twcmljZS9zcmMvanMvZGF0YS9hcGlVUkxzLmpzIiwiQzoveGFtcHAvaHRkb2NzL3dvcmtzcGFjZS95Z29kZWNrcHJpY2Uvc3JjL2pzL21ldGhvZHMvYXBpTG9hZFByaWNlcy5qcyIsIkM6L3hhbXBwL2h0ZG9jcy93b3Jrc3BhY2UveWdvZGVja3ByaWNlL3NyYy9qcy9tZXRob2RzL2NvbnZlcnRGaWxlVG9EZWNrLmpzIiwiQzoveGFtcHAvaHRkb2NzL3dvcmtzcGFjZS95Z29kZWNrcHJpY2Uvc3JjL2pzL21ldGhvZHMvZGVja0xvYWQuanMiLCJDOi94YW1wcC9odGRvY3Mvd29ya3NwYWNlL3lnb2RlY2twcmljZS9zcmMvanMvbWV0aG9kcy91cmlEZWNrRGVjb2RlLmpzIiwiQzoveGFtcHAvaHRkb2NzL3dvcmtzcGFjZS95Z29kZWNrcHJpY2Uvc3JjL2pzL21ldGhvZHMvZGVja0xvYWRVcmkuanMiLCJDOi94YW1wcC9odGRvY3Mvd29ya3NwYWNlL3lnb2RlY2twcmljZS9zcmMvanMvbWV0aG9kcy91cmlEZWNrRW5jb2RlLmpzIiwiQzoveGFtcHAvaHRkb2NzL3dvcmtzcGFjZS95Z29kZWNrcHJpY2Uvc3JjL2pzL21ldGhvZHMvZGVja1VwZGF0ZS5qcyIsIkM6L3hhbXBwL2h0ZG9jcy93b3Jrc3BhY2UveWdvZGVja3ByaWNlL3NyYy9qcy9tZXRob2RzL2RlY2tDYXJkc1dpdGhvdXRQcmljZURhdGEuanMiLCJDOi94YW1wcC9odGRvY3Mvd29ya3NwYWNlL3lnb2RlY2twcmljZS9zcmMvanMvbWV0aG9kcy9wcmljZUNvbnZlcnQuanMiLCJDOi94YW1wcC9odGRvY3Mvd29ya3NwYWNlL3lnb2RlY2twcmljZS9zcmMvanMvbWV0aG9kcy9wcmljZUZvckNhcmQuanMiLCJDOi94YW1wcC9odGRvY3Mvd29ya3NwYWNlL3lnb2RlY2twcmljZS9zcmMvanMvbWV0aG9kcy9wcmljZUZvclNlY3Rpb24uanMiLCJDOi94YW1wcC9odGRvY3Mvd29ya3NwYWNlL3lnb2RlY2twcmljZS9zcmMvanMvbWV0aG9kcy9idWlsZGVyVXBkYXRlTmFtZXMuanMiLCJDOi94YW1wcC9odGRvY3Mvd29ya3NwYWNlL3lnb2RlY2twcmljZS9zcmMvanMvbWV0aG9kcy9idWlsZGVyRGVja0FkZC5qcyIsIkM6L3hhbXBwL2h0ZG9jcy93b3Jrc3BhY2UveWdvZGVja3ByaWNlL3NyYy9qcy9tZXRob2RzL2J1aWxkZXJEZWNrUmVtb3ZlLmpzIiwiQzoveGFtcHAvaHRkb2NzL3dvcmtzcGFjZS95Z29kZWNrcHJpY2Uvbm9kZV9tb2R1bGVzL2ZpbGUtc2F2ZXIvRmlsZVNhdmVyLmpzIiwiQzoveGFtcHAvaHRkb2NzL3dvcmtzcGFjZS95Z29kZWNrcHJpY2Uvc3JjL2pzL21ldGhvZHMvY29udmVydERlY2tUb0ZpbGUuanMiLCJDOi94YW1wcC9odGRvY3Mvd29ya3NwYWNlL3lnb2RlY2twcmljZS9zcmMvanMvbWV0aG9kcy9maWxlRG93bmxvYWREZWNrLmpzIiwiQzoveGFtcHAvaHRkb2NzL3dvcmtzcGFjZS95Z29kZWNrcHJpY2Uvc3JjL2pzL2FwcE1ldGhvZHMuanMiLCJDOi94YW1wcC9odGRvY3Mvd29ya3NwYWNlL3lnb2RlY2twcmljZS9zcmMvanMvYXBwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVnVlLmpzIHYyLjIuNlxuICogKGMpIDIwMTQtMjAxNyBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4vKiAgKi9cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gX3RvU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgPyAnJ1xuICAgIDogdHlwZW9mIHZhbCA9PT0gJ29iamVjdCdcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgICAgOiBTdHJpbmcodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxufVxuXG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAgKFxuICBzdHIsXG4gIGV4cGVjdHNMb3dlckNhc2Vcbikge1xuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuICAgID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxuICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xudmFyIGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheVxuICovXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsdWUgaXMgcHJpbWl0aXZlXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbnZhciBoeXBoZW5hdGVSRSA9IC8oW14tXSkoW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC50b0xvd2VyQ2FzZSgpXG59KTtcblxuLyoqXG4gKiBTaW1wbGUgYmluZCwgZmFzdGVyIHRoYW4gbmF0aXZlXG4gKi9cbmZ1bmN0aW9uIGJpbmQgKGZuLCBjdHgpIHtcbiAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgZm4gbGVuZ3RoXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgcmV0dXJuIGJvdW5kRm5cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG4vKipcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKi9cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgT0JKRUNUX1NUUklORyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09IE9CSkVDVF9TVFJJTkdcbn1cblxuLyoqXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICovXG5mdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldKSB7XG4gICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuLyoqXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICovXG52YXIgbm8gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcblxuLyoqXG4gKiBSZXR1cm4gc2FtZSB2YWx1ZVxuICovXG52YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHN0YXRpYyBrZXlzIHN0cmluZyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gKi9cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMgKG1vZHVsZXMpIHtcbiAgcmV0dXJuIG1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uIChrZXlzLCBtKSB7XG4gICAgcmV0dXJuIGtleXMuY29uY2F0KG0uc3RhdGljS2V5cyB8fCBbXSlcbiAgfSwgW10pLmpvaW4oJywnKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICovXG5mdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XG4gIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcbiAgdmFyIGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYSkgPT09IEpTT04uc3RyaW5naWZ5KGIpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gcG9zc2libGUgY2lyY3VsYXIgcmVmZXJlbmNlXG4gICAgICByZXR1cm4gYSA9PT0gYlxuICAgIH1cbiAgfSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBsb29zZUluZGV4T2YgKGFyciwgdmFsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7IHJldHVybiBpIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyoqXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuICovXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBmbigpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGNvbmZpZyA9IHtcbiAgLyoqXG4gICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuICAgKi9cbiAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogU2hvdyBwcm9kdWN0aW9uIG1vZGUgdGlwIG1lc3NhZ2Ugb24gYm9vdD9cbiAgICovXG4gIHByb2R1Y3Rpb25UaXA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAqL1xuICBkZXZ0b29sczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgKi9cbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgKi9cbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICovXG4gIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAqL1xuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAqL1xuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAqL1xuICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIG11c3RVc2VQcm9wOiBubyxcblxuICAvKipcbiAgICogTGlzdCBvZiBhc3NldCB0eXBlcyB0aGF0IGEgY29tcG9uZW50IGNhbiBvd24uXG4gICAqL1xuICBfYXNzZXRUeXBlczogW1xuICAgICdjb21wb25lbnQnLFxuICAgICdkaXJlY3RpdmUnLFxuICAgICdmaWx0ZXInXG4gIF0sXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgbGlmZWN5Y2xlIGhvb2tzLlxuICAgKi9cbiAgX2xpZmVjeWNsZUhvb2tzOiBbXG4gICAgJ2JlZm9yZUNyZWF0ZScsXG4gICAgJ2NyZWF0ZWQnLFxuICAgICdiZWZvcmVNb3VudCcsXG4gICAgJ21vdW50ZWQnLFxuICAgICdiZWZvcmVVcGRhdGUnLFxuICAgICd1cGRhdGVkJyxcbiAgICAnYmVmb3JlRGVzdHJveScsXG4gICAgJ2Rlc3Ryb3llZCcsXG4gICAgJ2FjdGl2YXRlZCcsXG4gICAgJ2RlYWN0aXZhdGVkJ1xuICBdLFxuXG4gIC8qKlxuICAgKiBNYXggY2lyY3VsYXIgdXBkYXRlcyBhbGxvd2VkIGluIGEgc2NoZWR1bGVyIGZsdXNoIGN5Y2xlLlxuICAgKi9cbiAgX21heFVwZGF0ZUNvdW50OiAxMDBcbn07XG5cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZCAoc3RyKSB7XG4gIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsLFxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogUGFyc2Ugc2ltcGxlIHBhdGguXG4gKi9cbnZhciBiYWlsUkUgPSAvW15cXHcuJF0vO1xuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIW9iaikgeyByZXR1cm4gfVxuICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9XG59XG5cbi8qICAqL1xuLyogZ2xvYmFscyBNdXRhdGlvbk9ic2VydmVyICovXG5cbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xudmFyIGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge307XG5cbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDA7XG52YXIgaXNJT1MgPSBVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpO1xudmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG5cbi8vIHRoaXMgbmVlZHMgdG8gYmUgbGF6eS1ldmFsZWQgYmVjYXVzZSB2dWUgbWF5IGJlIHJlcXVpcmVkIGJlZm9yZVxuLy8gdnVlLXNlcnZlci1yZW5kZXJlciBjYW4gc2V0IFZVRV9FTlZcbnZhciBfaXNTZXJ2ZXI7XG52YXIgaXNTZXJ2ZXJSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaW5Ccm93c2VyICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcbiAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcbiAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgX2lzU2VydmVyID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfaXNTZXJ2ZXJcbn07XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xudmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaXNOYXRpdmUgKEN0b3IpIHtcbiAgcmV0dXJuIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpXG59XG5cbnZhciBoYXNTeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTeW1ib2wpICYmXG4gIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShSZWZsZWN0Lm93bktleXMpO1xuXG4vKipcbiAqIERlZmVyIGEgdGFzayB0byBleGVjdXRlIGl0IGFzeW5jaHJvbm91c2x5LlxuICovXG52YXIgbmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgY2FsbGJhY2tzID0gW107XG4gIHZhciBwZW5kaW5nID0gZmFsc2U7XG4gIHZhciB0aW1lckZ1bmM7XG5cbiAgZnVuY3Rpb24gbmV4dFRpY2tIYW5kbGVyICgpIHtcbiAgICBwZW5kaW5nID0gZmFsc2U7XG4gICAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29waWVzW2ldKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gdGhlIG5leHRUaWNrIGJlaGF2aW9yIGxldmVyYWdlcyB0aGUgbWljcm90YXNrIHF1ZXVlLCB3aGljaCBjYW4gYmUgYWNjZXNzZWRcbiAgLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXG4gIC8vIE11dGF0aW9uT2JzZXJ2ZXIgaGFzIHdpZGVyIHN1cHBvcnQsIGhvd2V2ZXIgaXQgaXMgc2VyaW91c2x5IGJ1Z2dlZCBpblxuICAvLyBVSVdlYlZpZXcgaW4gaU9TID49IDkuMy4zIHdoZW4gdHJpZ2dlcmVkIGluIHRvdWNoIGV2ZW50IGhhbmRsZXJzLiBJdFxuICAvLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXG4gIC8vIFByb21pc2UgaXMgYXZhaWxhYmxlLCB3ZSB3aWxsIHVzZSBpdDpcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcbiAgICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHZhciBsb2dFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHsgY29uc29sZS5lcnJvcihlcnIpOyB9O1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHAudGhlbihuZXh0VGlja0hhbmRsZXIpLmNhdGNoKGxvZ0Vycm9yKTtcbiAgICAgIC8vIGluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgICAvLyBtaWNyb3Rhc2sgcXVldWUgYnV0IHRoZSBxdWV1ZSBpc24ndCBiZWluZyBmbHVzaGVkLCB1bnRpbCB0aGUgYnJvd3NlclxuICAgICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICAgIGlmIChpc0lPUykgeyBzZXRUaW1lb3V0KG5vb3ApOyB9XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgIGlzTmF0aXZlKE11dGF0aW9uT2JzZXJ2ZXIpIHx8XG4gICAgLy8gUGhhbnRvbUpTIGFuZCBpT1MgNy54XG4gICAgTXV0YXRpb25PYnNlcnZlci50b1N0cmluZygpID09PSAnW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdJ1xuICApKSB7XG4gICAgLy8gdXNlIE11dGF0aW9uT2JzZXJ2ZXIgd2hlcmUgbmF0aXZlIFByb21pc2UgaXMgbm90IGF2YWlsYWJsZSxcbiAgICAvLyBlLmcuIFBoYW50b21KUyBJRTExLCBpT1M3LCBBbmRyb2lkIDQuNFxuICAgIHZhciBjb3VudGVyID0gMTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihuZXh0VGlja0hhbmRsZXIpO1xuICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhjb3VudGVyKSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pO1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICAgIHRleHROb2RlLmRhdGEgPSBTdHJpbmcoY291bnRlcik7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBmYWxsYmFjayB0byBzZXRUaW1lb3V0XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRUaW1lb3V0KG5leHRUaWNrSGFuZGxlciwgMCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBxdWV1ZU5leHRUaWNrIChjYiwgY3R4KSB7XG4gICAgdmFyIF9yZXNvbHZlO1xuICAgIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjYikgeyBjYi5jYWxsKGN0eCk7IH1cbiAgICAgIGlmIChfcmVzb2x2ZSkgeyBfcmVzb2x2ZShjdHgpOyB9XG4gICAgfSk7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICAgIHRpbWVyRnVuYygpO1xuICAgIH1cbiAgICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIH0pXG4gICAgfVxuICB9XG59KSgpO1xuXG52YXIgX1NldDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNldCAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XG4gICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXQ7XG4gIH0oKSk7XG59XG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGZvcm1hdENvbXBvbmVudE5hbWU7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbiAgdmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoY2xhc3NpZnlSRSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSlcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7IH07XG5cbiAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIltWdWUgd2Fybl06IFwiICsgbXNnICsgXCIgXCIgKyAoXG4gICAgICAgIHZtID8gZm9ybWF0TG9jYXRpb24oZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltWdWUgdGlwXTogXCIgKyBtc2cgKyBcIiBcIiArIChcbiAgICAgICAgdm0gPyBmb3JtYXRMb2NhdGlvbihmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0sIGluY2x1ZGVGaWxlKSB7XG4gICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xuICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgfVxuICAgIHZhciBuYW1lID0gdHlwZW9mIHZtID09PSAnc3RyaW5nJ1xuICAgICAgPyB2bVxuICAgICAgOiB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0ub3B0aW9uc1xuICAgICAgICA/IHZtLm9wdGlvbnMubmFtZVxuICAgICAgICA6IHZtLl9pc1Z1ZVxuICAgICAgICAgID8gdm0uJG9wdGlvbnMubmFtZSB8fCB2bS4kb3B0aW9ucy5fY29tcG9uZW50VGFnXG4gICAgICAgICAgOiB2bS5uYW1lO1xuXG4gICAgdmFyIGZpbGUgPSB2bS5faXNWdWUgJiYgdm0uJG9wdGlvbnMuX19maWxlO1xuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgKG5hbWUgPyAoXCI8XCIgKyAoY2xhc3NpZnkobmFtZSkpICsgXCI+XCIpIDogXCI8QW5vbnltb3VzPlwiKSArXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXCIgYXQgXCIgKyBmaWxlKSA6ICcnKVxuICAgIClcbiAgfTtcblxuICB2YXIgZm9ybWF0TG9jYXRpb24gPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gXCI8QW5vbnltb3VzPlwiKSB7XG4gICAgICBzdHIgKz0gXCIgLSB1c2UgdGhlIFxcXCJuYW1lXFxcIiBvcHRpb24gZm9yIGJldHRlciBkZWJ1Z2dpbmcgbWVzc2FnZXMuXCI7XG4gICAgfVxuICAgIHJldHVybiAoXCJcXG4oZm91bmQgaW4gXCIgKyBzdHIgKyBcIilcIilcbiAgfTtcbn1cblxuLyogICovXG5cblxudmFyIHVpZCQxID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKi9cbnZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICB0aGlzLmlkID0gdWlkJDErKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xuICBpZiAoRGVwLnRhcmdldCkgeyB0YXJnZXRTdGFjay5wdXNoKERlcC50YXJnZXQpOyB9XG4gIERlcC50YXJnZXQgPSBfdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2sucG9wKCk7XG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7W1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXVxuLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIC8vIGF2b2lkIGxlYWtpbmcgYXJndW1lbnRzOlxuICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2Nsb3N1cmUtd2l0aC1hcmd1bWVudHNcbiAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50cyQxW2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSk7XG59KTtcblxuLyogICovXG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gYSByZWFjdGl2ZSBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBuZXcgdmFsdWUgaXNcbiAqIGFsc28gY29udmVydGVkIHRvIGJlY29tZSByZWFjdGl2ZS4gSG93ZXZlciB3aGVuIHBhc3NpbmcgZG93biBwcm9wcyxcbiAqIHdlIGRvbid0IHdhbnQgdG8gZm9yY2UgY29udmVyc2lvbiBiZWNhdXNlIHRoZSB2YWx1ZSBtYXkgYmUgYSBuZXN0ZWQgdmFsdWVcbiAqIHVuZGVyIGEgZnJvemVuIGRhdGEgc3RydWN0dXJlLiBDb252ZXJ0aW5nIGl0IHdvdWxkIGRlZmVhdCB0aGUgb3B0aW1pemF0aW9uLlxuICovXG52YXIgb2JzZXJ2ZXJTdGF0ZSA9IHtcbiAgc2hvdWxkQ29udmVydDogdHJ1ZSxcbiAgaXNTZXR0aW5nUHJvcHM6IGZhbHNlXG59O1xuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaGVzIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICB0aGlzLnZtQ291bnQgPSAwO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90b1xuICAgICAgPyBwcm90b0F1Z21lbnRcbiAgICAgIDogY29weUF1Z21lbnQ7XG4gICAgYXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMShvYmosIGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ICYmXG4gICAgIWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgIG9iLnZtQ291bnQrKztcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlJCQxIChcbiAgb2JqLFxuICBrZXksXG4gIHZhbCxcbiAgY3VzdG9tU2V0dGVyXG4pIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuXG4gIHZhciBjaGlsZE9iID0gb2JzZXJ2ZSh2YWwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiB0eXBlb2Yga2V5ID09PSAnbnVtYmVyJykge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0ICkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmICghb2IpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgZGVmaW5lUmVhY3RpdmUkJDEob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIHR5cGVvZiBrZXkgPT09ICdudW1iZXInKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQgKS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHRvVmFsKSAmJiBpc1BsYWluT2JqZWN0KGZyb21WYWwpKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICBjaGlsZFZhbC5jYWxsKHRoaXMpLFxuICAgICAgICBwYXJlbnRWYWwuY2FsbCh0aGlzKVxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIGlmIChwYXJlbnRWYWwgfHwgY2hpbGRWYWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtKVxuICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWxcbn1cblxuY29uZmlnLl9saWZlY3ljbGVIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXG4gICAgOiByZXNcbn1cblxuY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XG59KTtcblxuLyoqXG4gKiBXYXRjaGVycy5cbiAqXG4gKiBXYXRjaGVycyBoYXNoZXMgc2hvdWxkIG5vdCBvdmVyd3JpdGUgb25lXG4gKiBhbm90aGVyLCBzbyB3ZSBtZXJnZSB0aGVtIGFzIGFycmF5cy5cbiAqL1xuc3RyYXRzLndhdGNoID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2hpbGRWYWwpIHsgcmV0dXJuIE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IHt9O1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBmb3IgKHZhciBrZXkgaW4gY2hpbGRWYWwpIHtcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleV07XG4gICAgdmFyIGNoaWxkID0gY2hpbGRWYWxba2V5XTtcbiAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgIH1cbiAgICByZXRba2V5XSA9IHBhcmVudFxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIGlmICghY2hpbGRWYWwpIHsgcmV0dXJuIE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGV4dGVuZChyZXQsIGNoaWxkVmFsKTtcbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFyIGxvd2VyID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGlzQnVpbHRJblRhZyhsb3dlcikgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobG93ZXIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2lkOiAnICsga2V5XG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMpIHtcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKCFwcm9wcykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBpLCB2YWwsIG5hbWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFsID0gcHJvcHNbaV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZSA9IGNhbWVsaXplKHZhbCk7XG4gICAgICAgIHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgfVxuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyAob3B0aW9ucykge1xuICB2YXIgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcbiAgaWYgKGRpcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGlycykge1xuICAgICAgdmFyIGRlZiA9IGRpcnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmLCB1cGRhdGU6IGRlZiB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gIHBhcmVudCxcbiAgY2hpbGQsXG4gIHZtXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICB9XG4gIG5vcm1hbGl6ZVByb3BzKGNoaWxkKTtcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG4gIHZhciBleHRlbmRzRnJvbSA9IGNoaWxkLmV4dGVuZHM7XG4gIGlmIChleHRlbmRzRnJvbSkge1xuICAgIHBhcmVudCA9IHR5cGVvZiBleHRlbmRzRnJvbSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBtZXJnZU9wdGlvbnMocGFyZW50LCBleHRlbmRzRnJvbS5vcHRpb25zLCB2bSlcbiAgICAgIDogbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20sIHZtKTtcbiAgfVxuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgbWl4aW4gPSBjaGlsZC5taXhpbnNbaV07XG4gICAgICBpZiAobWl4aW4ucHJvdG90eXBlIGluc3RhbmNlb2YgVnVlJDMpIHtcbiAgICAgICAgbWl4aW4gPSBtaXhpbi5vcHRpb25zO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgbWl4aW4sIHZtKTtcbiAgICB9XG4gIH1cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAga2V5LFxuICBwcm9wT3B0aW9ucyxcbiAgcHJvcHNEYXRhLFxuICB2bVxuKSB7XG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgLy8gaGFuZGxlIGJvb2xlYW4gcHJvcHNcbiAgaWYgKGlzVHlwZShCb29sZWFuLCBwcm9wLnR5cGUpKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICghaXNUeXBlKFN0cmluZywgcHJvcC50eXBlKSAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkpIHtcbiAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgdmFyIHByZXZTaG91bGRDb252ZXJ0ID0gb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0O1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gcHJldlNob3VsZENvbnZlcnQ7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNPYmplY3QoZGVmKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG4gICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgdm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicgK1xuICAgICAgJyBFeHBlY3RlZCAnICsgZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSArXG4gICAgICAnLCBnb3QgJyArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpICsgJy4nLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhlIHR5cGUgb2YgYSB2YWx1ZVxuICovXG5mdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xuICB2YXIgdmFsaWQ7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSAnU3RyaW5nJykge1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAoZXhwZWN0ZWRUeXBlID0gJ3N0cmluZycpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ051bWJlcicpIHtcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gKGV4cGVjdGVkVHlwZSA9ICdudW1iZXInKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdCb29sZWFuJykge1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAoZXhwZWN0ZWRUeXBlID0gJ2Jvb2xlYW4nKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdGdW5jdGlvbicpIHtcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gKGV4cGVjdGVkVHlwZSA9ICdmdW5jdGlvbicpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgfVxufVxuXG4vKipcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV1cbn1cblxuZnVuY3Rpb24gaXNUeXBlICh0eXBlLCBmbikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZm4pKSB7XG4gICAgcmV0dXJuIGdldFR5cGUoZm4pID09PSBnZXRUeXBlKHR5cGUpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGdldFR5cGUoZm5baV0pID09PSBnZXRUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZXJyLCB2bSwgaW5mbyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oKFwiRXJyb3IgaW4gXCIgKyBpbmZvICsgXCI6XCIpLCB2bSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG59XG5cbi8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xuXG52YXIgaW5pdFByb3h5O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxuICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xuICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICk7XG5cbiAgdmFyIHdhcm5Ob25QcmVzZW50ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgd2FybihcbiAgICAgIFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiICtcbiAgICAgIFwicmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdG8gZGVjbGFyZSByZWFjdGl2ZSBkYXRhIFwiICtcbiAgICAgIFwicHJvcGVydGllcyBpbiB0aGUgZGF0YSBvcHRpb24uXCIsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIFByb3h5LnRvU3RyaW5nKCkubWF0Y2goL25hdGl2ZSBjb2RlLyk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YScpO1xuICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHwga2V5LmNoYXJBdCgwKSA9PT0gJ18nO1xuICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV1cbiAgICB9XG4gIH07XG5cbiAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5ICh2bSkge1xuICAgIGlmIChoYXNQcm94eSkge1xuICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXG4gICAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgICAgdmFyIGhhbmRsZXJzID0gb3B0aW9ucy5yZW5kZXIgJiYgb3B0aW9ucy5yZW5kZXIuX3dpdGhTdHJpcHBlZFxuICAgICAgICA/IGdldEhhbmRsZXJcbiAgICAgICAgOiBoYXNIYW5kbGVyO1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHBlcmYgJiZcbiAgICBwZXJmLm1hcmsgJiZcbiAgICBwZXJmLm1lYXN1cmUgJiZcbiAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgKSB7XG4gICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpO1xuICAgIH07XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgdGV4dCxcbiAgZWxtLFxuICBjb250ZXh0LFxuICBjb21wb25lbnRPcHRpb25zXG4pIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5lbG0gPSBlbG07XG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZnVuY3Rpb25hbENvbnRleHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDoge30gfTtcblxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9ICcnO1xuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gIHJldHVybiBub2RlXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxufVxuXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICB2bm9kZS5jaGlsZHJlbixcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnNcbiAgKTtcbiAgY2xvbmVkLm5zID0gdm5vZGUubnM7XG4gIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xuICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xuICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xuICByZXR1cm4gY2xvbmVkXG59XG5cbmZ1bmN0aW9uIGNsb25lVk5vZGVzICh2bm9kZXMpIHtcbiAgdmFyIGxlbiA9IHZub2Rlcy5sZW5ndGg7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc1tpXSA9IGNsb25lVk5vZGUodm5vZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZTogY2FwdHVyZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMpIHtcbiAgZnVuY3Rpb24gaW52b2tlciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZuc1tpXS5hcHBseShudWxsLCBhcmd1bWVudHMkMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gZm5zLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cbiAgaW52b2tlci5mbnMgPSBmbnM7XG4gIHJldHVybiBpbnZva2VyXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXG4gIG9uLFxuICBvbGRPbixcbiAgYWRkLFxuICByZW1vdmUkJDEsXG4gIHZtXG4pIHtcbiAgdmFyIG5hbWUsIGN1ciwgb2xkLCBldmVudDtcbiAgZm9yIChuYW1lIGluIG9uKSB7XG4gICAgY3VyID0gb25bbmFtZV07XG4gICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICBpZiAoIWN1cikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghb2xkKSB7XG4gICAgICBpZiAoIWN1ci5mbnMpIHtcbiAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVGbkludm9rZXIoY3VyKTtcbiAgICAgIH1cbiAgICAgIGFkZChldmVudC5uYW1lLCBjdXIsIGV2ZW50Lm9uY2UsIGV2ZW50LmNhcHR1cmUpO1xuICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgIG9sZC5mbnMgPSBjdXI7XG4gICAgICBvbltuYW1lXSA9IG9sZDtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG9sZE9uKSB7XG4gICAgaWYgKCFvbltuYW1lXSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIHZhciBpbnZva2VyO1xuICB2YXIgb2xkSG9vayA9IGRlZltob29rS2V5XTtcblxuICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIC8vIGltcG9ydGFudDogcmVtb3ZlIG1lcmdlZCBob29rIHRvIGVuc3VyZSBpdCdzIGNhbGxlZCBvbmx5IG9uY2VcbiAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuICB9XG5cbiAgaWYgKCFvbGRIb29rKSB7XG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKG9sZEhvb2suZm5zICYmIG9sZEhvb2subWVyZ2VkKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgfVxuICB9XG5cbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG4vKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIGksIGMsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoYyA9PSBudWxsIHx8IHR5cGVvZiBjID09PSAnYm9vbGVhbicpIHsgY29udGludWUgfVxuICAgIGxhc3QgPSByZXNbcmVzLmxlbmd0aCAtIDFdO1xuICAgIC8vICBuZXN0ZWRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSkge1xuICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSkpO1xuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUoYykpIHtcbiAgICAgIGlmIChsYXN0ICYmIGxhc3QudGV4dCkge1xuICAgICAgICBsYXN0LnRleHQgKz0gU3RyaW5nKGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYy50ZXh0ICYmIGxhc3QgJiYgbGFzdC50ZXh0KSB7XG4gICAgICAgIHJlc1tyZXMubGVuZ3RoIC0gMV0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChjLnRhZyAmJiBjLmtleSA9PSBudWxsICYmIG5lc3RlZEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gIHJldHVybiBjaGlsZHJlbiAmJiBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgJiYgYy5jb21wb25lbnRPcHRpb25zOyB9KVswXVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbnZhciB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuLCBvbmNlJCQxKSB7XG4gIGlmIChvbmNlJCQxKSB7XG4gICAgdGFyZ2V0LiRvbmNlKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgdm0sXG4gIGxpc3RlbmVycyxcbiAgb2xkTGlzdGVuZXJzXG4pIHtcbiAgdGFyZ2V0ID0gdm07XG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgdm0pO1xufVxuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIHZhciBob29rUkUgPSAvXmhvb2s6LztcbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvbihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpJDEgPCBsOyBpJDErKykge1xuICAgICAgICB0aGlzJDEuJG9mZihldmVudFtpJDFdLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKCFjYnMpIHtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICB2YXIgY2I7XG4gICAgdmFyIGkgPSBjYnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY2JzW2ldLmFwcGx5KHZtLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgdmFyIHNsb3RzID0ge307XG4gIGlmICghY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gc2xvdHNcbiAgfVxuICB2YXIgZGVmYXVsdFNsb3QgPSBbXTtcbiAgdmFyIG5hbWUsIGNoaWxkO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mdW5jdGlvbmFsQ29udGV4dCA9PT0gY29udGV4dCkgJiZcbiAgICAgICAgY2hpbGQuZGF0YSAmJiAobmFtZSA9IGNoaWxkLmRhdGEuc2xvdCkpIHtcbiAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWZhdWx0U2xvdC5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLy8gaWdub3JlIHdoaXRlc3BhY2VcbiAgaWYgKCFkZWZhdWx0U2xvdC5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgc2xvdHMuZGVmYXVsdCA9IGRlZmF1bHRTbG90O1xuICB9XG4gIHJldHVybiBzbG90c1xufVxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50IHx8IG5vZGUudGV4dCA9PT0gJyAnXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTY29wZWRTbG90cyAoXG4gIGZuc1xuKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICByZXNbZm5zW2ldWzBdXSA9IGZuc1tpXVsxXTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xuXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICB9XG4gICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcbiAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKFxuICAgICAgICB2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8sXG4gICAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0sXG4gICAgICAgIHZtLiRvcHRpb25zLl9yZWZFbG1cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIERPTSBub2RlcyAocHJldmVudHMgbGVhaylcbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtID0gdm0uJG9wdGlvbnMuX3JlZkVsbSA9IG51bGw7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcbiAgdm0sXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICB2bS4kZWwgPSBlbDtcbiAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICB2YXIgdXBkYXRlQ29tcG9uZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmFtZSA9IHZtLl9uYW1lO1xuICAgICAgdmFyIGlkID0gdm0uX3VpZDtcbiAgICAgIHZhciBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyBpZDtcbiAgICAgIHZhciBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArIGlkO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZhciB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfVxuXG4gIHZtLl93YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCk7XG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuXG4gIHZhciBoYXNDaGlsZHJlbiA9ICEhKFxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyB8fCAvLyBoYXMgbmV3IHNjb3BlZCBzbG90c1xuICAgIHZtLiRzY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgLy8gaGFzIG9sZCBzY29wZWQgc2xvdHNcbiAgKTtcblxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcbiAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgfVxuICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAvLyB1cGRhdGUgcHJvcHNcbiAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGZhbHNlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BzID0gdm0uX3Byb3BzO1xuICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgdm0uJG9wdGlvbnMucHJvcHMsIHByb3BzRGF0YSwgdm0pO1xuICAgIH1cbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gIH1cbiAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdmFyIG9sZExpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gICAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcbiAgfVxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICBpZiAoaGFzQ2hpbGRyZW4pIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PSBudWxsKSB7XG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgaWYgKCF2bS5faW5hY3RpdmUpIHtcbiAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgaWYgKGhhbmRsZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodm0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbn1cblxuLyogICovXG5cblxudmFyIHF1ZXVlID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgcXVldWUubGVuZ3RoID0gMDtcbiAgaGFzID0ge307XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2lyY3VsYXIgPSB7fTtcbiAgfVxuICB3YWl0aW5nID0gZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgdmFyIHdhdGNoZXIsIGlkLCB2bTtcblxuICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XG4gIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcbiAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXG4gIC8vICAgIHVzZXIgd2F0Y2hlcnMgYXJlIGNyZWF0ZWQgYmVmb3JlIHRoZSByZW5kZXIgd2F0Y2hlcilcbiAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxuICBxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG5cbiAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBxdWV1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgIGlkID0gd2F0Y2hlci5pZDtcbiAgICBoYXNbaWRdID0gbnVsbDtcbiAgICB3YXRjaGVyLnJ1bigpO1xuICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBoYXNbaWRdICE9IG51bGwpIHtcbiAgICAgIGNpcmN1bGFyW2lkXSA9IChjaXJjdWxhcltpZF0gfHwgMCkgKyAxO1xuICAgICAgaWYgKGNpcmN1bGFyW2lkXSA+IGNvbmZpZy5fbWF4VXBkYXRlQ291bnQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IG1heSBoYXZlIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wICcgKyAoXG4gICAgICAgICAgICB3YXRjaGVyLnVzZXJcbiAgICAgICAgICAgICAgPyAoXCJpbiB3YXRjaGVyIHdpdGggZXhwcmVzc2lvbiBcXFwiXCIgKyAod2F0Y2hlci5leHByZXNzaW9uKSArIFwiXFxcIlwiKVxuICAgICAgICAgICAgICA6IFwiaW4gYSBjb21wb25lbnQgcmVuZGVyIGZ1bmN0aW9uLlwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICB3YXRjaGVyLnZtXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcmVzZXQgc2NoZWR1bGVyIGJlZm9yZSB1cGRhdGVkIGhvb2sgY2FsbGVkXG4gIHZhciBvbGRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIHVwZGF0ZWQgaG9va3NcbiAgaW5kZXggPSBvbGRRdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgd2F0Y2hlciA9IG9sZFF1ZXVlW2luZGV4XTtcbiAgICB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGRldnRvb2wgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICBoYXNbaWRdID0gdHJ1ZTtcbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXG4gICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkgPj0gMCAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKE1hdGgubWF4KGksIGluZGV4KSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnNcbikge1xuICB0aGlzLnZtID0gdm07XG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAvLyBvcHRpb25zXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG4gICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdO1xuICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICA/IGV4cE9yRm4udG9TdHJpbmcoKVxuICAgIDogJyc7XG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXFxcIlwiICsgZXhwT3JGbiArIFwiXFxcIiBcIiArXG4gICAgICAgICdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArXG4gICAgICAgICdGb3IgZnVsbCBjb250cm9sLCB1c2UgYSBmdW5jdGlvbiBpbnN0ZWFkLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxuICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHRoaXMuZ2V0KCk7XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHtcbiAgcHVzaFRhcmdldCh0aGlzKTtcbiAgdmFyIHZhbHVlO1xuICB2YXIgdm0gPSB0aGlzLnZtO1xuICBpZiAodGhpcy51c2VyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJnZXR0ZXIgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgfVxuICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gIGlmICh0aGlzLmRlZXApIHtcbiAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gIH1cbiAgcG9wVGFyZ2V0KCk7XG4gIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgcmV0dXJuIHZhbHVlXG59O1xuXG4vKipcbiAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIGFkZERlcCAoZGVwKSB7XG4gIHZhciBpZCA9IGRlcC5pZDtcbiAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgdGhpcy5uZXdEZXBJZHMuYWRkKGlkKTtcbiAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xuICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuY2xlYW51cERlcHMgPSBmdW5jdGlvbiBjbGVhbnVwRGVwcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGRlcCA9IHRoaXMkMS5kZXBzW2ldO1xuICAgIGlmICghdGhpcyQxLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgfVxuICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG4gIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICB0bXAgPSB0aGlzLmRlcHM7XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy5sYXp5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zeW5jKSB7XG4gICAgdGhpcy5ydW4oKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVdhdGNoZXIodGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIGlmIChcbiAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgdGhpcy5kZWVwXG4gICAgKSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdGhpcy52bSwgKFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlICgpIHtcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gIHRoaXMuZGlydHkgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdGhpcyQxLmRlcHNbaV0uZGVwZW5kKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gdGVhcmRvd24gKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIGRlc3Ryb3llZC5cbiAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzJDEuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG4gIF90cmF2ZXJzZSh2YWwsIHNlZW5PYmplY3RzKTtcbn1cblxuZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcbiAgdmFyIGksIGtleXM7XG4gIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsKSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBub29wLFxuICBzZXQ6IG5vb3Bcbn07XG5cbmZ1bmN0aW9uIHByb3h5ICh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBmdW5jdGlvbiBwcm94eUdldHRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldXG4gIH07XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgdGhpc1tzb3VyY2VLZXldW2tleV0gPSB2YWw7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xuICB2bS5fd2F0Y2hlcnMgPSBbXTtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucztcbiAgaWYgKG9wdHMucHJvcHMpIHsgaW5pdFByb3BzKHZtLCBvcHRzLnByb3BzKTsgfVxuICBpZiAob3B0cy5tZXRob2RzKSB7IGluaXRNZXRob2RzKHZtLCBvcHRzLm1ldGhvZHMpOyB9XG4gIGlmIChvcHRzLmRhdGEpIHtcbiAgICBpbml0RGF0YSh2bSk7XG4gIH0gZWxzZSB7XG4gICAgb2JzZXJ2ZSh2bS5fZGF0YSA9IHt9LCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xuICB9XG4gIGlmIChvcHRzLmNvbXB1dGVkKSB7IGluaXRDb21wdXRlZCh2bSwgb3B0cy5jb21wdXRlZCk7IH1cbiAgaWYgKG9wdHMud2F0Y2gpIHsgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTsgfVxufVxuXG52YXIgaXNSZXNlcnZlZFByb3AgPSB7IGtleTogMSwgcmVmOiAxLCBzbG90OiAxIH07XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xuICB2YXIgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bS5fcHJvcHMgPSB7fTtcbiAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcbiAgLy8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXG4gIHZhciBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW107XG4gIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcbiAgLy8gcm9vdCBpbnN0YW5jZSBwcm9wcyBzaG91bGQgYmUgY29udmVydGVkXG4gIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGlzUm9vdDtcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpc1Jlc2VydmVkUHJvcFtrZXldKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh2bS4kcGFyZW50ICYmICFvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleXNbaV0pKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsgKGtleXNbaV0pICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleXNbaV0pKSB7XG4gICAgICBwcm94eSh2bSwgXCJfZGF0YVwiLCBrZXlzW2ldKTtcbiAgICB9XG4gIH1cbiAgLy8gb2JzZXJ2ZSBkYXRhXG4gIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSAoZGF0YSwgdm0pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGF0YS5jYWxsKHZtKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xuICAgIHJldHVybiB7fVxuICB9XG59XG5cbnZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJObyBnZXR0ZXIgZnVuY3Rpb24gaGFzIGJlZW4gZGVmaW5lZCBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgICBnZXR0ZXIgPSBub29wO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcih2bSwgZ2V0dGVyLCBub29wLCBjb21wdXRlZFdhdGNoZXJPcHRpb25zKTtcblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKHRhcmdldCwga2V5LCB1c2VyRGVmKSB7XG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICB9IGVsc2Uge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgPyB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiB1c2VyRGVmLmdldFxuICAgICAgOiBub29wO1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldFxuICAgICAgPyB1c2VyRGVmLnNldFxuICAgICAgOiBub29wO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgdm1ba2V5XSA9IG1ldGhvZHNba2V5XSA9PSBudWxsID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwibWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYW4gdW5kZWZpbmVkIHZhbHVlIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIm1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAodm0sIGtleSwgaGFuZGxlcikge1xuICB2YXIgb3B0aW9ucztcbiAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICBvcHRpb25zID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XG4gIH1cbiAgdm0uJHdhdGNoKGtleSwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XG4gIHZhciBwcm9wc0RlZiA9IHt9O1xuICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuLy8gaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKFxuICAgIHZub2RlLFxuICAgIGh5ZHJhdGluZyxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtXG4gICkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZSxcbiAgICAgICAgcGFyZW50RWxtLFxuICAgICAgICByZWZFbG1cbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcbiAgICAgIGNoaWxkLFxuICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgKTtcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCAodm5vZGUpIHtcbiAgICBpZiAoIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2sodm5vZGUuY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgIH1cbiAgfSxcblxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm5vZGUuY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmICghQ3Rvcikge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcbiAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBhc3luYyBjb21wb25lbnRcbiAgaWYgKCFDdG9yLmNpZCkge1xuICAgIGlmIChDdG9yLnJlc29sdmVkKSB7XG4gICAgICBDdG9yID0gQ3Rvci5yZXNvbHZlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChDdG9yLCBiYXNlQ3RvciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBpdCdzIG9rIHRvIHF1ZXVlIHRoaXMgb24gZXZlcnkgcmVuZGVyIGJlY2F1c2VcbiAgICAgICAgLy8gJGZvcmNlVXBkYXRlIGlzIGJ1ZmZlcmVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gICAgICAgIGNvbnRleHQuJGZvcmNlVXBkYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIGlmICghQ3Rvcikge1xuICAgICAgICAvLyByZXR1cm4gbm90aGluZyBpZiB0aGlzIGlzIGluZGVlZCBhbiBhc3luYyBjb21wb25lbnRcbiAgICAgICAgLy8gd2FpdCBmb3IgdGhlIGNhbGxiYWNrIHRvIHRyaWdnZXIgcGFyZW50IHVwZGF0ZS5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXG4gIGlmIChkYXRhLm1vZGVsKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wcyhkYXRhLCBDdG9yLCB0YWcpO1xuXG4gIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gIGlmIChDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XG5cbiAgaWYgKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzXG4gICAgZGF0YSA9IHt9O1xuICB9XG5cbiAgLy8gbWVyZ2UgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBtZXJnZUhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH1cbiAgKTtcbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQgKFxuICBDdG9yLFxuICBwcm9wc0RhdGEsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuXG4pIHtcbiAgdmFyIHByb3BzID0ge307XG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKHByb3BPcHRpb25zKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSk7XG4gICAgfVxuICB9XG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgX2NvbnRleHQgPSBPYmplY3QuY3JlYXRlKGNvbnRleHQpO1xuICB2YXIgaCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KF9jb250ZXh0LCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcbiAgdmFyIHZub2RlID0gQ3Rvci5vcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIGgsIHtcbiAgICBwcm9wczogcHJvcHMsXG4gICAgZGF0YTogZGF0YSxcbiAgICBwYXJlbnQ6IGNvbnRleHQsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIHNsb3RzOiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIGNvbnRleHQpOyB9XG4gIH0pO1xuICBpZiAodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHZub2RlLmZ1bmN0aW9uYWxDb250ZXh0ID0gY29udGV4dDtcbiAgICBpZiAoZGF0YS5zbG90KSB7XG4gICAgICAodm5vZGUuZGF0YSB8fCAodm5vZGUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gIHBhcmVudCwgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4gIHBhcmVudEVsbSxcbiAgcmVmRWxtXG4pIHtcbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBwcm9wc0RhdGE6IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGEsXG4gICAgX2NvbXBvbmVudFRhZzogdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZyxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIF9wYXJlbnRMaXN0ZW5lcnM6IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnMsXG4gICAgX3JlbmRlckNoaWxkcmVuOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4sXG4gICAgX3BhcmVudEVsbTogcGFyZW50RWxtIHx8IG51bGwsXG4gICAgX3JlZkVsbTogcmVmRWxtIHx8IG51bGxcbiAgfTtcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgdmFyIGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcbiAgaWYgKGlubGluZVRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbiAgcmV0dXJuIG5ldyB2bm9kZUNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICBmYWN0b3J5LFxuICBiYXNlQ3RvcixcbiAgY2Jcbikge1xuICBpZiAoZmFjdG9yeS5yZXF1ZXN0ZWQpIHtcbiAgICAvLyBwb29sIGNhbGxiYWNrc1xuICAgIGZhY3RvcnkucGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNiKTtcbiAgfSBlbHNlIHtcbiAgICBmYWN0b3J5LnJlcXVlc3RlZCA9IHRydWU7XG4gICAgdmFyIGNicyA9IGZhY3RvcnkucGVuZGluZ0NhbGxiYWNrcyA9IFtjYl07XG4gICAgdmFyIHN5bmMgPSB0cnVlO1xuXG4gICAgdmFyIHJlc29sdmUgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgICByZXMgPSBiYXNlQ3Rvci5leHRlbmQocmVzKTtcbiAgICAgIH1cbiAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gcmVzO1xuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgY2JzW2ldKHJlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAocmVhc29uID8gKFwiXFxuUmVhc29uOiBcIiArIHJlYXNvbikgOiAnJylcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAvLyBoYW5kbGUgcHJvbWlzZVxuICAgIGlmIChyZXMgJiYgdHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nICYmICFmYWN0b3J5LnJlc29sdmVkKSB7XG4gICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcbiAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0UHJvcHMgKGRhdGEsIEN0b3IsIHRhZykge1xuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKCFwcm9wT3B0aW9ucykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGF0dHJzID0gZGF0YS5hdHRycztcbiAgdmFyIHByb3BzID0gZGF0YS5wcm9wcztcbiAgdmFyIGRvbVByb3BzID0gZGF0YS5kb21Qcm9wcztcbiAgaWYgKGF0dHJzIHx8IHByb3BzIHx8IGRvbVByb3BzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBhdHRycy5oYXNPd25Qcm9wZXJ0eShrZXlJbkxvd2VyQ2FzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGlwKFxuICAgICAgICAgICAgXCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgXCIgK1xuICAgICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodGFnIHx8IEN0b3IpKSArIFwiLCBidXQgdGhlIGRlY2xhcmVkIHByb3AgbmFtZSBpc1wiICtcbiAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICtcbiAgICAgICAgICAgIFwicHJvcHMgbmVlZCB0byB1c2UgdGhlaXIga2ViYWItY2FzZSBlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSBcIiArXG4gICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5KSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgZG9tUHJvcHMsIGtleSwgYWx0S2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChoYXNoKSB7XG4gICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rcyAoZGF0YSkge1xuICBpZiAoIWRhdGEuaG9vaykge1xuICAgIGRhdGEuaG9vayA9IHt9O1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICB2YXIgZnJvbVBhcmVudCA9IGRhdGEuaG9va1trZXldO1xuICAgIHZhciBvdXJzID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgIGRhdGEuaG9va1trZXldID0gZnJvbVBhcmVudCA/IG1lcmdlSG9vayQxKG91cnMsIGZyb21QYXJlbnQpIDogb3VycztcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgb25lKGEsIGIsIGMsIGQpO1xuICAgIHR3byhhLCBiLCBjLCBkKTtcbiAgfVxufVxuXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICB2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnOyhkYXRhLnByb3BzIHx8IChkYXRhLnByb3BzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gIGlmIChvbltldmVudF0pIHtcbiAgICBvbltldmVudF0gPSBbZGF0YS5tb2RlbC5jYWxsYmFja10uY29uY2F0KG9uW2V2ZW50XSk7XG4gIH0gZWxzZSB7XG4gICAgb25bZXZlbnRdID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xudmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoYWx3YXlzTm9ybWFsaXplKSB7IG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTsgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoZGF0YSAmJiBkYXRhLl9fb2JfXykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXCJcXG5cIiArXG4gICAgICAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJyxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgfVxuICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfSBlbHNlIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gU0lNUExFX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9XG4gIHZhciB2bm9kZSwgbnM7XG4gIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgIHZhciBDdG9yO1xuICAgIG5zID0gY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xuICAgIGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICgoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmICh2bm9kZSkge1xuICAgIGlmIChucykgeyBhcHBseU5TKHZub2RlLCBucyk7IH1cbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlOUyAodm5vZGUsIG5zKSB7XG4gIHZub2RlLm5zID0gbnM7XG4gIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxuICAgIHJldHVyblxuICB9XG4gIGlmICh2bm9kZS5jaGlsZHJlbikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChjaGlsZC50YWcgJiYgIWNoaWxkLm5zKSB7XG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTGlzdCAoXG4gIHZhbCxcbiAgcmVuZGVyXG4pIHtcbiAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxuICovXG5mdW5jdGlvbiByZW5kZXJTbG90IChcbiAgbmFtZSxcbiAgZmFsbGJhY2ssXG4gIHByb3BzLFxuICBiaW5kT2JqZWN0XG4pIHtcbiAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgZXh0ZW5kKHByb3BzLCBiaW5kT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2tcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdE5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV07XG4gICAgLy8gd2FybiBkdXBsaWNhdGUgc2xvdCB1c2FnZVxuICAgIGlmIChzbG90Tm9kZXMgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCAmJiB3YXJuKFxuICAgICAgICBcIkR1cGxpY2F0ZSBwcmVzZW5jZSBvZiBzbG90IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZm91bmQgaW4gdGhlIHNhbWUgcmVuZGVyIHRyZWUgXCIgK1xuICAgICAgICBcIi0gdGhpcyB3aWxsIGxpa2VseSBjYXVzZSByZW5kZXIgZXJyb3JzLlwiLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzbG90Tm9kZXMgfHwgZmFsbGJhY2tcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMgKFxuICBldmVudEtleUNvZGUsXG4gIGtleSxcbiAgYnVpbHRJbkFsaWFzXG4pIHtcbiAgdmFyIGtleUNvZGVzID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbkFsaWFzO1xuICBpZiAoQXJyYXkuaXNBcnJheShrZXlDb2RlcykpIHtcbiAgICByZXR1cm4ga2V5Q29kZXMuaW5kZXhPZihldmVudEtleUNvZGUpID09PSAtMVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBrZXlDb2RlcyAhPT0gZXZlbnRLZXlDb2RlXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wXG4pIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3YtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IG9yIEFycmF5IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xuICAgICAgfVxuICAgICAgdmFyIGhhc2g7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJyB8fCBrZXkgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoa2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICB2YXIgdHJlZSA9IHRoaXMuX3N0YXRpY1RyZWVzW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlIGJ5IGRvaW5nIGEgc2hhbGxvdyBjbG9uZS5cbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0cmVlKVxuICAgICAgPyBjbG9uZVZOb2Rlcyh0cmVlKVxuICAgICAgOiBjbG9uZVZOb2RlKHRyZWUpXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdID1cbiAgICB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbCh0aGlzLl9yZW5kZXJQcm94eSk7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgdm0uJHZub2RlID0gbnVsbDsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDtcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICB2YXIgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyh2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpOyB9O1xuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xufVxuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICAvLyBjbG9uZSBzbG90IG5vZGVzIG9uIHJlLXJlbmRlcnNcbiAgICAgIGZvciAodmFyIGtleSBpbiB2bS4kc2xvdHMpIHtcbiAgICAgICAgdm0uJHNsb3RzW2tleV0gPSBjbG9uZVZOb2Rlcyh2bS4kc2xvdHNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdm0uJHNjb3BlZFNsb3RzID0gKF9wYXJlbnRWbm9kZSAmJiBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cykgfHwgZW1wdHlPYmplY3Q7XG5cbiAgICBpZiAoc3RhdGljUmVuZGVyRm5zICYmICF2bS5fc3RhdGljVHJlZXMpIHtcbiAgICAgIHZtLl9zdGF0aWNUcmVlcyA9IFtdO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgIC8vIHJlbmRlciBzZWxmXG4gICAgdmFyIHZub2RlO1xuICAgIHRyeSB7XG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlciBmdW5jdGlvblwiKTtcbiAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yXG4gICAgICAgICAgPyB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpXG4gICAgICAgICAgOiB2bS5fdm5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xuXG4gIC8vIGludGVybmFsIHJlbmRlciBoZWxwZXJzLlxuICAvLyB0aGVzZSBhcmUgZXhwb3NlZCBvbiB0aGUgaW5zdGFuY2UgcHJvdG90eXBlIHRvIHJlZHVjZSBnZW5lcmF0ZWQgcmVuZGVyXG4gIC8vIGNvZGUgc2l6ZS5cbiAgVnVlLnByb3RvdHlwZS5fbyA9IG1hcmtPbmNlO1xuICBWdWUucHJvdG90eXBlLl9uID0gdG9OdW1iZXI7XG4gIFZ1ZS5wcm90b3R5cGUuX3MgPSBfdG9TdHJpbmc7XG4gIFZ1ZS5wcm90b3R5cGUuX2wgPSByZW5kZXJMaXN0O1xuICBWdWUucHJvdG90eXBlLl90ID0gcmVuZGVyU2xvdDtcbiAgVnVlLnByb3RvdHlwZS5fcSA9IGxvb3NlRXF1YWw7XG4gIFZ1ZS5wcm90b3R5cGUuX2kgPSBsb29zZUluZGV4T2Y7XG4gIFZ1ZS5wcm90b3R5cGUuX20gPSByZW5kZXJTdGF0aWM7XG4gIFZ1ZS5wcm90b3R5cGUuX2YgPSByZXNvbHZlRmlsdGVyO1xuICBWdWUucHJvdG90eXBlLl9rID0gY2hlY2tLZXlDb2RlcztcbiAgVnVlLnByb3RvdHlwZS5fYiA9IGJpbmRPYmplY3RQcm9wcztcbiAgVnVlLnByb3RvdHlwZS5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcbiAgVnVlLnByb3RvdHlwZS5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gIFZ1ZS5wcm90b3R5cGUuX3UgPSByZXNvbHZlU2NvcGVkU2xvdHM7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcbiAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICBpZiAocHJvdmlkZSkge1xuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgIDogcHJvdmlkZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgdmFyIGluamVjdCA9IHZtLiRvcHRpb25zLmluamVjdDtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgLy8gaXNBcnJheSBoZXJlXG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGluamVjdCk7XG4gICAgdmFyIGtleXMgPSBpc0FycmF5XG4gICAgICA/IGluamVjdFxuICAgICAgOiBoYXNTeW1ib2xcbiAgICAgICAgPyBSZWZsZWN0Lm93bktleXMoaW5qZWN0KVxuICAgICAgICA6IE9iamVjdC5rZXlzKGluamVjdCk7XG5cbiAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggaSApIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHByb3ZpZGVLZXkgPSBpc0FycmF5ID8ga2V5IDogaW5qZWN0W2tleV07XG4gICAgICB2YXIgc291cmNlID0gdm07XG4gICAgICB3aGlsZSAoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIHByb3ZpZGVLZXkgaW4gc291cmNlLl9wcm92aWRlZCkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICAgICAgXCJpbmplY3Rpb24gYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG4gICAgICAgICAgICAgICAgdm1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UuJHBhcmVudDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSBsb29wKCBpICk7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB1aWQgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCsrO1xuXG4gICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1pbml0OlwiICsgKHZtLl91aWQpO1xuICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICB9XG5cbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgIHZtLl9pc1Z1ZSA9IHRydWU7XG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXG4gICAgICAgIG9wdGlvbnMgfHwge30sXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoKHZtLl9uYW1lKSArIFwiIGluaXRcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH1cblxuICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIG9wdHMucHJvcHNEYXRhID0gb3B0aW9ucy5wcm9wc0RhdGE7XG4gIG9wdHMuX3BhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSBvcHRpb25zLl9yZW5kZXJDaGlsZHJlbjtcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICBvcHRzLl9wYXJlbnRFbG0gPSBvcHRpb25zLl9wYXJlbnRFbG07XG4gIG9wdHMuX3JlZkVsbSA9IG9wdGlvbnMuX3JlZkVsbTtcbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG1vZGlmaWVkO1xuICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgeyBtb2RpZmllZCA9IHt9OyB9XG4gICAgICBtb2RpZmllZFtrZXldID0gZGVkdXBlKGxhdGVzdFtrZXldLCBzZWFsZWRba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RpZmllZFxufVxuXG5mdW5jdGlvbiBkZWR1cGUgKGxhdGVzdCwgc2VhbGVkKSB7XG4gIC8vIGNvbXBhcmUgbGF0ZXN0IGFuZCBzZWFsZWQgdG8gZW5zdXJlIGxpZmVjeWNsZSBob29rcyB3b24ndCBiZSBkdXBsaWNhdGVkXG4gIC8vIGJldHdlZW4gbWVyZ2VzXG4gIGlmIChBcnJheS5pc0FycmF5KGxhdGVzdCkpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgc2VhbGVkID0gQXJyYXkuaXNBcnJheShzZWFsZWQpID8gc2VhbGVkIDogW3NlYWxlZF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRlc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzZWFsZWQuaW5kZXhPZihsYXRlc3RbaV0pIDwgMCkge1xuICAgICAgICByZXMucHVzaChsYXRlc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxhdGVzdFxuICB9XG59XG5cbmZ1bmN0aW9uIFZ1ZSQzIChvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlJDMpKSB7XG4gICAgd2FybignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICB9XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbmluaXRNaXhpbihWdWUkMyk7XG5zdGF0ZU1peGluKFZ1ZSQzKTtcbmV2ZW50c01peGluKFZ1ZSQzKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSQzKTtcbnJlbmRlck1peGluKFZ1ZSQzKTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRVc2UgKFZ1ZSkge1xuICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwbHVnaW4uaW5zdGFsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIHBsdWdpbi5pbnN0YWxsZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAvKipcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAqL1xuICBWdWUuY2lkID0gMDtcbiAgdmFyIGNpZCA9IDE7XG5cbiAgLyoqXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAqL1xuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgU3VwZXIgPSB0aGlzO1xuICAgIHZhciBTdXBlcklkID0gU3VwZXIuY2lkO1xuICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG4gICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF1cbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICAgICAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgdGhlIGh5cGhlbiwgJyArXG4gICAgICAgICAgJ2FuZCBtdXN0IHN0YXJ0IHdpdGggYSBsZXR0ZXIuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgU3VwZXIub3B0aW9ucyxcbiAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICApO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgIGluaXRQcm9wcyQxKFN1Yik7XG4gICAgfVxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xuICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICB2YXIgcHJvcHMgPSBDb21wLm9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCQxIChDb21wKSB7XG4gIHZhciBjb21wdXRlZCA9IENvbXAub3B0aW9ucy5jb21wdXRlZDtcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyAoVnVlKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAqL1xuICBjb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgY29uZmlnLmlzUmVzZXJ2ZWRUYWcoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgICAgICAgJ2lkOiAnICsgaWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cF07XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoY2FjaGUsIGZpbHRlcikge1xuICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZE5vZGUpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGVkTm9kZSk7XG4gICAgICAgIGNhY2hlW2tleV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKHZub2RlKSB7XG4gIGlmICh2bm9kZSkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2luYWN0aXZlKSB7XG4gICAgICBjYWxsSG9vayh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSwgJ2RlYWN0aXZhdGVkJyk7XG4gICAgfVxuICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gIH1cbn1cblxudmFyIEtlZXBBbGl2ZSA9IHtcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXNcbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSxcblxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcyQxLmNhY2hlKSB7XG4gICAgICBwcnVuZUNhY2hlRW50cnkodGhpcyQxLmNhY2hlW2tleV0pO1xuICAgIH1cbiAgfSxcblxuICB3YXRjaDoge1xuICAgIGluY2x1ZGU6IGZ1bmN0aW9uIGluY2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9LFxuICAgIGV4Y2x1ZGU6IGZ1bmN0aW9uIGV4Y2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgKFxuICAgICAgICAodGhpcy5pbmNsdWRlICYmICFtYXRjaGVzKHRoaXMuaW5jbHVkZSwgbmFtZSkpIHx8XG4gICAgICAgICh0aGlzLmV4Y2x1ZGUgJiYgbWF0Y2hlcyh0aGlzLmV4Y2x1ZGUsIG5hbWUpKVxuICAgICAgKSkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmICh0aGlzLmNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLmNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgIH1cbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn07XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgS2VlcEFsaXZlOiBLZWVwQWxpdmVcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJIChWdWUpIHtcbiAgLy8gY29uZmlnXG4gIHZhciBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuXG4gIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgVnVlLnV0aWwgPSB7XG4gICAgd2Fybjogd2FybixcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUkJDFcbiAgfTtcblxuICBWdWUuc2V0ID0gc2V0O1xuICBWdWUuZGVsZXRlID0gZGVsO1xuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUkMyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5WdWUkMy52ZXJzaW9uID0gJzIuMi42JztcblxuLyogICovXG5cbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbnZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QnKTtcbnZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG52YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG52YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcbn07XG5cbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbnZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUgKHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICBpZiAoY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZ2VuQ2xhc3NGcm9tRGF0YShkYXRhKVxufVxuXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xuICByZXR1cm4ge1xuICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXG4gICAgY2xhc3M6IGNoaWxkLmNsYXNzXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5DbGFzc0Zyb21EYXRhIChkYXRhKSB7XG4gIHZhciBkeW5hbWljQ2xhc3MgPSBkYXRhLmNsYXNzO1xuICB2YXIgc3RhdGljQ2xhc3MgPSBkYXRhLnN0YXRpY0NsYXNzO1xuICBpZiAoc3RhdGljQ2xhc3MgfHwgZHluYW1pY0NsYXNzKSB7XG4gICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XG4gIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgc3RyaW5naWZpZWQ7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZVtpXSkge1xuICAgICAgICBpZiAoKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSkge1xuICAgICAgICAgIHJlcyArPSBzdHJpbmdpZmllZCArICcgJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZVtrZXldKSB7IHJlcyArPSBrZXkgKyAnICc7IH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcbiAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgK1xuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG4gICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZSdcbik7XG5cbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbnZhciBpc1NWRyA9IG1ha2VNYXAoXG4gICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICB0cnVlXG4pO1xuXG52YXIgaXNQcmVUYWcgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0YWcgPT09ICdwcmUnOyB9O1xuXG52YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcbn07XG5cbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XG4gIGlmIChpc1NWRyh0YWcpKSB7XG4gICAgcmV0dXJuICdzdmcnXG4gIH1cbiAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXG4gIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgcmV0dXJuICdtYXRoJ1xuICB9XG59XG5cbnZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgfVxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuICAgICkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcbiAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG1cbiAgfVxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gIH1cbiAgcmV0dXJuIGVsbVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbn1cblxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUgKG5vZGUsIGtleSwgdmFsKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcbn1cblxuXG52YXIgbm9kZU9wcyA9IE9iamVjdC5mcmVlemUoe1xuXHRjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG5cdGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuXHRjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG5cdGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG5cdGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuXHRyZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG5cdGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcblx0cGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcblx0bmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuXHR0YWdOYW1lOiB0YWdOYW1lLFxuXHRzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG5cdHNldEF0dHJpYnV0ZTogc2V0QXR0cmlidXRlXG59KTtcblxuLyogICovXG5cbnZhciByZWYgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xuICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICgha2V5KSB7IHJldHVybiB9XG5cbiAgdmFyIHZtID0gdm5vZGUuY29udGV4dDtcbiAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgdmFyIHJlZnMgPSB2bS4kcmVmcztcbiAgaWYgKGlzUmVtb3ZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSAmJiByZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVmc1trZXldID0gW3JlZl07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuXG4vKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHRydWVcbn1cblxuZnVuY3Rpb24gc2FtZVZub2RlIChhLCBiKSB7XG4gIHJldHVybiAoXG4gICAgYS5rZXkgPT09IGIua2V5ICYmXG4gICAgYS50YWcgPT09IGIudGFnICYmXG4gICAgYS5pc0NvbW1lbnQgPT09IGIuaXNDb21tZW50ICYmXG4gICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcbiAgKVxufVxuXG4vLyBTb21lIGJyb3dzZXJzIGRvIG5vdCBzdXBwb3J0IGR5bmFtaWNhbGx5IGNoYW5naW5nIHR5cGUgZm9yIDxpbnB1dD5cbi8vIHNvIHRoZXkgbmVlZCB0byBiZSB0cmVhdGVkIGFzIGRpZmZlcmVudCBub2Rlc1xuZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xuICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaTtcbiAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgdmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgcmV0dXJuIHR5cGVBID09PSB0eXBlQlxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgdmFyIGksIGtleTtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICBpZiAoaXNEZWYoa2V5KSkgeyBtYXBba2V5XSA9IGk7IH1cbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgdmFyIGksIGo7XG4gIHZhciBjYnMgPSB7fTtcblxuICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcbiAgdmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUkJDEgKCkge1xuICAgICAgaWYgKC0tcmVtb3ZlJCQxLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlJCQxLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICByZXR1cm4gcmVtb3ZlJCQxXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xuICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpblByZSA9IDA7XG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIG5lc3RlZCkge1xuICAgIHZub2RlLmlzUm9vdEluc2VydCA9ICFuZXN0ZWQ7IC8vIGZvciB0cmFuc2l0aW9uIGVudGVyIGNoZWNrXG4gICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICAgIGluUHJlKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgICFpblByZSAmJlxuICAgICAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgICAgICEoY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiYgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5pbmRleE9mKHRhZykgPiAtMSkgJiZcbiAgICAgICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh0YWcpXG4gICAgICAgICkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArXG4gICAgICAgICAgICAncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArXG4gICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZub2RlLmVsbSA9IHZub2RlLm5zXG4gICAgICAgID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZylcbiAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICBpblByZS0tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgdmFyIGlzUmVhY3RpdmF0ZWQgPSBpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaS5rZWVwQWxpdmU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICB9XG4gICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxuICAgICAgLy8gaXQgc2hvdWxkJ3ZlIGNyZWF0ZWQgYSBjaGlsZCBpbnN0YW5jZSBhbmQgbW91bnRlZCBpdC4gdGhlIGNoaWxkXG4gICAgICAvLyBjb21wb25lbnQgYWxzbyBoYXMgc2V0IHRoZSBwbGFjZWhvbGRlciB2bm9kZSdzIGVsbS5cbiAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXG4gICAgICBpZiAoaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcbiAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSkge1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xuICAgIH1cbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpO1xuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmKSB7XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIGlmIChpc0RlZihyZWYpKSB7XG4gICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIHsgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpLmluc2VydCkpIHsgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcbiAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZTtcbiAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgICAgfVxuICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgfVxuICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxuICAgICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuICAgICAgbm9kZU9wcy5zZXRBdHRyaWJ1dGUodm5vZGUuZWxtLCBpLCAnJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sgKHZub2RlKSB7XG4gICAgdmFyIGksIGo7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSB7IGkodm5vZGUpOyB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHsgY2JzLmRlc3Ryb3lbaV0odm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVZub2RlcyAocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xuICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVGV4dCBub2RlXG4gICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayAodm5vZGUsIHJtKSB7XG4gICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgIGlmIChpc0RlZihybSkpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHJlY3Vyc2l2ZWx5IHBhc3NlZCBkb3duIHJtIGNhbGxiYWNrXG4gICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgcm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgIHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XG4gICAgICB9XG4gICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XG4gICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soaSwgcm0pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2JzLnJlbW92ZVtpXSh2bm9kZSwgcm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgaSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuIChwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcbiAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xuICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgZWxtVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSB7IG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpOyB9XG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldIDogbnVsbDtcbiAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7IC8vIE5ldyBlbGVtZW50XG4gICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsbVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhZWxtVG9Nb3ZlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAnSXQgc2VlbXMgdGhlcmUgYXJlIGR1cGxpY2F0ZSBrZXlzIHRoYXQgaXMgY2F1c2luZyBhbiB1cGRhdGUgZXJyb3IuICcgK1xuICAgICAgICAgICAgICAnTWFrZSBzdXJlIGVhY2ggdi1mb3IgaXRlbSBoYXMgYSB1bmlxdWUga2V5LidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzYW1lVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZShlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgbmV3U3RhcnRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgICAgaXNUcnVlKG9sZFZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIGk7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICB2YXIgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgeyBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS51cGRhdGUpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgeyB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTsgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7IG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7IH1cbiAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZENoKSkge1xuICAgICAgICByZW1vdmVWbm9kZXMoZWxtLCBvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgdm5vZGUudGV4dCk7XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnBvc3RwYXRjaCkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayAodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XG4gICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG4gICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcbiAgICBpZiAoaXNUcnVlKGluaXRpYWwpICYmIGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgYmFpbGVkID0gZmFsc2U7XG4gIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XG4gIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG4gIHZhciBpc1JlbmRlcmVkTW9kdWxlID0gbWFrZU1hcCgnYXR0cnMsc3R5bGUsY2xhc3Msc3RhdGljQ2xhc3Msc3RhdGljU3R5bGUsa2V5Jyk7XG5cbiAgLy8gTm90ZTogdGhpcyBpcyBhIGJyb3dzZXItb25seSBmdW5jdGlvbiBzbyB3ZSBjYW4gYXNzdW1lIGVsbXMgYXJlIERPTSBub2Rlcy5cbiAgZnVuY3Rpb24gaHlkcmF0ZSAoZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICB2bm9kZS5lbG0gPSBlbG07XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcbiAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG4gICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgIGlmICghY2hpbGRyZW5NYXRjaCB8fCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWJhaWxlZCkge1xuICAgICAgICAgICAgICBiYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8XG4gICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHksIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgaWYgKGlzVW5kZWYodm5vZGUpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XG4gICAgdmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUpKSB7XG4gICAgICAvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XG4gICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XG4gICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoJ3NlcnZlci1yZW5kZXJlZCcpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3NlcnZlci1yZW5kZXJlZCcpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICB2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICB2YXIgcGFyZW50RWxtJDEgPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcbiAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSQxLFxuICAgICAgICAgIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKVxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgLy8gY29tcG9uZW50IHJvb3QgZWxlbWVudCByZXBsYWNlZC5cbiAgICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNicy5jcmVhdGVbaV0oZW1wdHlOb2RlLCB2bm9kZS5wYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihwYXJlbnRFbG0kMSkpIHtcbiAgICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtJDEsIFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRhZykpIHtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGlzSW5pdGlhbFBhdGNoKTtcbiAgICByZXR1cm4gdm5vZGUuZWxtXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBkaXJlY3RpdmVzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIHVwZGF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgZGVzdHJveTogZnVuY3Rpb24gdW5iaW5kRGlyZWN0aXZlcyAodm5vZGUpIHtcbiAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcbiAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3VwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgb2xkRGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMShvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xuICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gIHZhciBkaXJzV2l0aEluc2VydCA9IFtdO1xuICB2YXIgZGlyc1dpdGhQb3N0cGF0Y2ggPSBbXTtcblxuICB2YXIga2V5LCBvbGREaXIsIGRpcjtcbiAgZm9yIChrZXkgaW4gbmV3RGlycykge1xuICAgIG9sZERpciA9IG9sZERpcnNba2V5XTtcbiAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgaWYgKCFvbGREaXIpIHtcbiAgICAgIC8vIG5ldyBkaXJlY3RpdmUsIGJpbmRcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XG4gICAgICAgIGRpcnNXaXRoSW5zZXJ0LnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcbiAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcbiAgZGlycyxcbiAgdm1cbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFkaXJzKSB7XG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIHZhciBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcbiAgICB9XG4gICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XG4gICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcbn1cblxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW1xuICByZWYsXG4gIGRpcmVjdGl2ZXNcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmICghb2xkVm5vZGUuZGF0YS5hdHRycyAmJiAhdm5vZGUuZGF0YS5hdHRycykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1ciwgb2xkO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGF0dHJzLl9fb2JfXykge1xuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIpO1xuICAgIH1cbiAgfVxuICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUU5ICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xuICAgIHNldEF0dHIoZWxtLCAndmFsdWUnLCBhdHRycy52YWx1ZSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcbiAgICBpZiAoYXR0cnNba2V5XSA9PSBudWxsKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGtleSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnID8gJ2ZhbHNlJyA6ICd0cnVlJyk7XG4gIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBhdHRycyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgdXBkYXRlOiB1cGRhdGVBdHRyc1xufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcbiAgaWYgKCFkYXRhLnN0YXRpY0NsYXNzICYmICFkYXRhLmNsYXNzICYmXG4gICAgICAoIW9sZERhdGEgfHwgKCFvbGREYXRhLnN0YXRpY0NsYXNzICYmICFvbGREYXRhLmNsYXNzKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjbHMgPSBnZW5DbGFzc0ZvclZub2RlKHZub2RlKTtcblxuICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG4gIHZhciB0cmFuc2l0aW9uQ2xhc3MgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXM7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3MpIHtcbiAgICBjbHMgPSBjb25jYXQoY2xzLCBzdHJpbmdpZnlDbGFzcyh0cmFuc2l0aW9uQ2xhc3MpKTtcbiAgfVxuXG4gIC8vIHNldCB0aGUgY2xhc3NcbiAgaWYgKGNscyAhPT0gZWwuX3ByZXZDbGFzcykge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XG4gIH1cbn1cblxudmFyIGtsYXNzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUNsYXNzLFxuICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG59O1xuXG4vKiAgKi9cblxudmFyIHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XG5cbmZ1bmN0aW9uIHBhcnNlRmlsdGVycyAoZXhwKSB7XG4gIHZhciBpblNpbmdsZSA9IGZhbHNlO1xuICB2YXIgaW5Eb3VibGUgPSBmYWxzZTtcbiAgdmFyIGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcbiAgdmFyIGluUmVnZXggPSBmYWxzZTtcbiAgdmFyIGN1cmx5ID0gMDtcbiAgdmFyIHNxdWFyZSA9IDA7XG4gIHZhciBwYXJlbiA9IDA7XG4gIHZhciBsYXN0RmlsdGVySW5kZXggPSAwO1xuICB2YXIgYywgcHJldiwgaSwgZXhwcmVzc2lvbiwgZmlsdGVycztcblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJldiA9IGM7XG4gICAgYyA9IGV4cC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChpblNpbmdsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgeyBpblNpbmdsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpbkRvdWJsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1QykgeyBpbkRvdWJsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICBpZiAoYyA9PT0gMHg2MCAmJiBwcmV2ICE9PSAweDVDKSB7IGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5SZWdleCkge1xuICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1QykgeyBpblJlZ2V4ID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYyA9PT0gMHg3QyAmJiAvLyBwaXBlXG4gICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiZcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gMHg3QyAmJlxuICAgICAgIWN1cmx5ICYmICFzcXVhcmUgJiYgIXBhcmVuXG4gICAgKSB7XG4gICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cbiAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAweDIyOiBpbkRvdWJsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gXCJcbiAgICAgICAgY2FzZSAweDI3OiBpblNpbmdsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gJ1xuICAgICAgICBjYXNlIDB4NjA6IGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlOyBicmVhayAvLyBgXG4gICAgICAgIGNhc2UgMHgyODogcGFyZW4rKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIChcbiAgICAgICAgY2FzZSAweDI5OiBwYXJlbi0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKVxuICAgICAgICBjYXNlIDB4NUI6IHNxdWFyZSsrOyBicmVhayAgICAgICAgICAgICAgICAvLyBbXG4gICAgICAgIGNhc2UgMHg1RDogc3F1YXJlLS07IGJyZWFrICAgICAgICAgICAgICAgIC8vIF1cbiAgICAgICAgY2FzZSAweDdCOiBjdXJseSsrOyBicmVhayAgICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICBjYXNlIDB4N0Q6IGN1cmx5LS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICB9XG4gICAgICBpZiAoYyA9PT0gMHgyZikgeyAvLyAvXG4gICAgICAgIHZhciBqID0gaSAtIDE7XG4gICAgICAgIHZhciBwID0gKHZvaWQgMCk7XG4gICAgICAgIC8vIGZpbmQgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgcHJldiBjaGFyXG4gICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIHAgPSBleHAuY2hhckF0KGopO1xuICAgICAgICAgIGlmIChwICE9PSAnICcpIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcCB8fCAhdmFsaWREaXZpc2lvbkNoYXJSRS50ZXN0KHApKSB7XG4gICAgICAgICAgaW5SZWdleCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG4gICAgcHVzaEZpbHRlcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEZpbHRlciAoKSB7XG4gICAgKGZpbHRlcnMgfHwgKGZpbHRlcnMgPSBbXSkpLnB1c2goZXhwLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpKTtcbiAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgfVxuXG4gIGlmIChmaWx0ZXJzKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHByZXNzaW9uXG59XG5cbmZ1bmN0aW9uIHdyYXBGaWx0ZXIgKGV4cCwgZmlsdGVyKSB7XG4gIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgLy8gX2Y6IHJlc29sdmVGaWx0ZXJcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgZmlsdGVyICsgXCJcXFwiKShcIiArIGV4cCArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHZhciBuYW1lID0gZmlsdGVyLnNsaWNlKDAsIGkpO1xuICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgbmFtZSArIFwiXFxcIikoXCIgKyBleHAgKyBcIixcIiArIGFyZ3MpXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJhc2VXYXJuIChtc2cpIHtcbiAgY29uc29sZS5lcnJvcigoXCJbVnVlIGNvbXBpbGVyXTogXCIgKyBtc2cpKTtcbn1cblxuZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG4gIG1vZHVsZXMsXG4gIGtleVxuKSB7XG4gIHJldHVybiBtb2R1bGVzXG4gICAgPyBtb2R1bGVzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbVtrZXldOyB9KS5maWx0ZXIoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH0pXG4gICAgOiBbXVxufVxuXG5mdW5jdGlvbiBhZGRQcm9wIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgKGVsLnByb3BzIHx8IChlbC5wcm9wcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cblxuZnVuY3Rpb24gYWRkQXR0ciAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIChlbC5hdHRycyB8fCAoZWwuYXR0cnMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZERpcmVjdGl2ZSAoXG4gIGVsLFxuICBuYW1lLFxuICByYXdOYW1lLFxuICB2YWx1ZSxcbiAgYXJnLFxuICBtb2RpZmllcnNcbikge1xuICAoZWwuZGlyZWN0aXZlcyB8fCAoZWwuZGlyZWN0aXZlcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHJhd05hbWU6IHJhd05hbWUsIHZhbHVlOiB2YWx1ZSwgYXJnOiBhcmcsIG1vZGlmaWVyczogbW9kaWZpZXJzIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICBtb2RpZmllcnMsXG4gIGltcG9ydGFudFxuKSB7XG4gIC8vIGNoZWNrIGNhcHR1cmUgbW9kaWZpZXJcbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMuY2FwdHVyZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMuY2FwdHVyZTtcbiAgICBuYW1lID0gJyEnICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgY2FwdHVyZWRcbiAgfVxuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5vbmNlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5vbmNlO1xuICAgIG5hbWUgPSAnficgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBvbmNlXG4gIH1cbiAgdmFyIGV2ZW50cztcbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMubmF0aXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5uYXRpdmU7XG4gICAgZXZlbnRzID0gZWwubmF0aXZlRXZlbnRzIHx8IChlbC5uYXRpdmVFdmVudHMgPSB7fSk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzID0gZWwuZXZlbnRzIHx8IChlbC5ldmVudHMgPSB7fSk7XG4gIH1cbiAgdmFyIG5ld0hhbmRsZXIgPSB7IHZhbHVlOiB2YWx1ZSwgbW9kaWZpZXJzOiBtb2RpZmllcnMgfTtcbiAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcnMpKSB7XG4gICAgaW1wb3J0YW50ID8gaGFuZGxlcnMudW5zaGlmdChuZXdIYW5kbGVyKSA6IGhhbmRsZXJzLnB1c2gobmV3SGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoaGFuZGxlcnMpIHtcbiAgICBldmVudHNbbmFtZV0gPSBpbXBvcnRhbnQgPyBbbmV3SGFuZGxlciwgaGFuZGxlcnNdIDogW2hhbmRsZXJzLCBuZXdIYW5kbGVyXTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHNbbmFtZV0gPSBuZXdIYW5kbGVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEJpbmRpbmdBdHRyIChcbiAgZWwsXG4gIG5hbWUsXG4gIGdldFN0YXRpY1xuKSB7XG4gIHZhciBkeW5hbWljVmFsdWUgPVxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICc6JyArIG5hbWUpIHx8XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gIGlmIChkeW5hbWljVmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBwYXJzZUZpbHRlcnMoZHluYW1pY1ZhbHVlKVxuICB9IGVsc2UgaWYgKGdldFN0YXRpYyAhPT0gZmFsc2UpIHtcbiAgICB2YXIgc3RhdGljVmFsdWUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCBuYW1lKTtcbiAgICBpZiAoc3RhdGljVmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YXRpY1ZhbHVlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyIChlbCwgbmFtZSkge1xuICB2YXIgdmFsO1xuICBpZiAoKHZhbCA9IGVsLmF0dHJzTWFwW25hbWVdKSAhPSBudWxsKSB7XG4gICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGxpc3RbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cbmZ1bmN0aW9uIGdlbkNvbXBvbmVudE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcblxuICB2YXIgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gYmFzZVZhbHVlRXhwcmVzc2lvbjtcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPVxuICAgICAgXCIodHlwZW9mIFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiID09PSAnc3RyaW5nJ1wiICtcbiAgICAgICAgXCI/IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiLnRyaW0oKVwiICtcbiAgICAgICAgXCI6IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgdmFyIGFzc2lnbm1lbnQgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcblxuICBlbC5tb2RlbCA9IHtcbiAgICB2YWx1ZTogKFwiKFwiICsgdmFsdWUgKyBcIilcIiksXG4gICAgZXhwcmVzc2lvbjogKFwiXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksXG4gICAgY2FsbGJhY2s6IChcImZ1bmN0aW9uIChcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIikge1wiICsgYXNzaWdubWVudCArIFwifVwiKVxuICB9O1xufVxuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxuICovXG5mdW5jdGlvbiBnZW5Bc3NpZ25tZW50Q29kZSAoXG4gIHZhbHVlLFxuICBhc3NpZ25tZW50XG4pIHtcbiAgdmFyIG1vZGVsUnMgPSBwYXJzZU1vZGVsKHZhbHVlKTtcbiAgaWYgKG1vZGVsUnMuaWR4ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICh2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJ2YXIgJCRleHAgPSBcIiArIChtb2RlbFJzLmV4cCkgKyBcIiwgJCRpZHggPSBcIiArIChtb2RlbFJzLmlkeCkgKyBcIjtcIiArXG4gICAgICBcImlmICghQXJyYXkuaXNBcnJheSgkJGV4cCkpe1wiICtcbiAgICAgICAgdmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQgKyBcIn1cIiArXG4gICAgICBcImVsc2V7JCRleHAuc3BsaWNlKCQkaWR4LCAxLCBcIiArIGFzc2lnbm1lbnQgKyBcIil9XCJcbiAgfVxufVxuXG4vKipcbiAqIHBhcnNlIGRpcmVjdGl2ZSBtb2RlbCB0byBkbyB0aGUgYXJyYXkgdXBkYXRlIHRyYW5zZm9ybS4gYVtpZHhdID0gdmFsID0+ICQkYS5zcGxpY2UoJCRpZHgsIDEsIHZhbClcbiAqXG4gKiBmb3IgbG9vcCBwb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtpZHhdXG4gKiAtIHRlc3RbdGVzdDFbaWR4XV1cbiAqIC0gdGVzdFtcImFcIl1baWR4XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2lkeF1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFbaWR4XV1cbiAqXG4gKi9cblxudmFyIGxlbjtcbnZhciBzdHI7XG52YXIgY2hyO1xudmFyIGluZGV4JDE7XG52YXIgZXhwcmVzc2lvblBvcztcbnZhciBleHByZXNzaW9uRW5kUG9zO1xuXG5mdW5jdGlvbiBwYXJzZU1vZGVsICh2YWwpIHtcbiAgc3RyID0gdmFsO1xuICBsZW4gPSBzdHIubGVuZ3RoO1xuICBpbmRleCQxID0gZXhwcmVzc2lvblBvcyA9IGV4cHJlc3Npb25FbmRQb3MgPSAwO1xuXG4gIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhwOiB2YWwsXG4gICAgICBpZHg6IG51bGxcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgfSBlbHNlIGlmIChjaHIgPT09IDB4NUIpIHtcbiAgICAgIHBhcnNlQnJhY2tldChjaHIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXhwOiB2YWwuc3Vic3RyaW5nKDAsIGV4cHJlc3Npb25Qb3MpLFxuICAgIGlkeDogdmFsLnN1YnN0cmluZyhleHByZXNzaW9uUG9zICsgMSwgZXhwcmVzc2lvbkVuZFBvcylcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXh0ICgpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KCsraW5kZXgkMSlcbn1cblxuZnVuY3Rpb24gZW9mICgpIHtcbiAgcmV0dXJuIGluZGV4JDEgPj0gbGVuXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nU3RhcnQgKGNocikge1xuICByZXR1cm4gY2hyID09PSAweDIyIHx8IGNociA9PT0gMHgyN1xufVxuXG5mdW5jdGlvbiBwYXJzZUJyYWNrZXQgKGNocikge1xuICB2YXIgaW5CcmFja2V0ID0gMTtcbiAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChjaHIgPT09IDB4NUIpIHsgaW5CcmFja2V0Kys7IH1cbiAgICBpZiAoY2hyID09PSAweDVEKSB7IGluQnJhY2tldC0tOyB9XG4gICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xuICAgICAgZXhwcmVzc2lvbkVuZFBvcyA9IGluZGV4JDE7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyAoY2hyKSB7XG4gIHZhciBzdHJpbmdRdW90ZSA9IGNocjtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoY2hyID09PSBzdHJpbmdRdW90ZSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB3YXJuJDE7XG5cbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcbi8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG52YXIgUkFOR0VfVE9LRU4gPSAnX19yJztcbnZhciBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xuXG5mdW5jdGlvbiBtb2RlbCAoXG4gIGVsLFxuICBkaXIsXG4gIF93YXJuXG4pIHtcbiAgd2FybiQxID0gX3dhcm47XG4gIHZhciB2YWx1ZSA9IGRpci52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGRpci5tb2RpZmllcnM7XG4gIHZhciB0YWcgPSBlbC50YWc7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBkeW5hbWljVHlwZSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dHlwZSddIHx8IGVsLmF0dHJzTWFwWyc6dHlwZSddO1xuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgZHluYW1pY1R5cGUpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgXCI8aW5wdXQgOnR5cGU9XFxcIlwiICsgZHluYW1pY1R5cGUgKyBcIlxcXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46XFxuXCIgK1xuICAgICAgICBcInYtbW9kZWwgZG9lcyBub3Qgc3VwcG9ydCBkeW5hbWljIGlucHV0IHR5cGVzLiBVc2Ugdi1pZiBicmFuY2hlcyBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBpbnB1dHMgd2l0aCB0eXBlPVwiZmlsZVwiIGFyZSByZWFkIG9ubHkgYW5kIHNldHRpbmcgdGhlIGlucHV0J3NcbiAgICAvLyB2YWx1ZSB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiIHR5cGU9XFxcImZpbGVcXFwiPjpcXG5cIiArXG4gICAgICAgIFwiRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgIGdlblNlbGVjdChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ3JhZGlvJykge1xuICAgIGdlblJhZGlvTW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpIHtcbiAgICBnZW5EZWZhdWx0TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKCFjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMShcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgXCJ2LW1vZGVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBlbGVtZW50IHR5cGUuIFwiICtcbiAgICAgICdJZiB5b3UgYXJlIHdvcmtpbmcgd2l0aCBjb250ZW50ZWRpdGFibGUsIGl0XFwncyByZWNvbW1lbmRlZCB0byAnICtcbiAgICAgICd3cmFwIGEgbGlicmFyeSBkZWRpY2F0ZWQgZm9yIHRoYXQgcHVycG9zZSBpbnNpZGUgYSBjdXN0b20gY29tcG9uZW50LidcbiAgICApO1xuICB9XG5cbiAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGdlbkNoZWNrYm94TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhciB0cnVlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0cnVlLXZhbHVlJykgfHwgJ3RydWUnO1xuICB2YXIgZmFsc2VWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2ZhbHNlLXZhbHVlJykgfHwgJ2ZhbHNlJztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLFxuICAgIFwiQXJyYXkuaXNBcnJheShcIiArIHZhbHVlICsgXCIpXCIgK1xuICAgICAgXCI/X2koXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpPi0xXCIgKyAoXG4gICAgICAgIHRydWVWYWx1ZUJpbmRpbmcgPT09ICd0cnVlJ1xuICAgICAgICAgID8gKFwiOihcIiArIHZhbHVlICsgXCIpXCIpXG4gICAgICAgICAgOiAoXCI6X3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKVwiKVxuICAgICAgKVxuICApO1xuICBhZGRIYW5kbGVyKGVsLCBDSEVDS0JPWF9SQURJT19UT0tFTixcbiAgICBcInZhciAkJGE9XCIgKyB2YWx1ZSArIFwiLFwiICtcbiAgICAgICAgJyQkZWw9JGV2ZW50LnRhcmdldCwnICtcbiAgICAgICAgXCIkJGM9JCRlbC5jaGVja2VkPyhcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIik6KFwiICsgZmFsc2VWYWx1ZUJpbmRpbmcgKyBcIik7XCIgK1xuICAgICdpZihBcnJheS5pc0FycmF5KCQkYSkpeycgK1xuICAgICAgXCJ2YXIgJCR2PVwiICsgKG51bWJlciA/ICdfbignICsgdmFsdWVCaW5kaW5nICsgJyknIDogdmFsdWVCaW5kaW5nKSArIFwiLFwiICtcbiAgICAgICAgICAnJCRpPV9pKCQkYSwkJHYpOycgK1xuICAgICAgXCJpZigkJGMpeyQkaTwwJiYoXCIgKyB2YWx1ZSArIFwiPSQkYS5jb25jYXQoJCR2KSl9XCIgK1xuICAgICAgXCJlbHNleyQkaT4tMSYmKFwiICsgdmFsdWUgKyBcIj0kJGEuc2xpY2UoMCwkJGkpLmNvbmNhdCgkJGEuc2xpY2UoJCRpKzEpKSl9XCIgK1xuICAgIFwifWVsc2V7XCIgKyB2YWx1ZSArIFwiPSQkY31cIixcbiAgICBudWxsLCB0cnVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhbHVlQmluZGluZyA9IG51bWJlciA/IChcIl9uKFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpIDogdmFsdWVCaW5kaW5nO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsIChcIl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIENIRUNLQk9YX1JBRElPX1RPS0VOLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVCaW5kaW5nKSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlblNlbGVjdCAoXG4gICAgZWwsXG4gICAgdmFsdWUsXG4gICAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgc2VsZWN0ZWRWYWwgPSBcIkFycmF5LnByb3RvdHlwZS5maWx0ZXJcIiArXG4gICAgXCIuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KVwiICtcbiAgICBcIi5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFxcXCJfdmFsdWVcXFwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKG51bWJlciA/ICdfbih2YWwpJyA6ICd2YWwnKSArIFwifSlcIjtcblxuICB2YXIgYXNzaWdubWVudCA9ICckZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF0nO1xuICB2YXIgY29kZSA9IFwidmFyICQkc2VsZWN0ZWRWYWwgPSBcIiArIHNlbGVjdGVkVmFsICsgXCI7XCI7XG4gIGNvZGUgPSBjb2RlICsgXCIgXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGNvZGUsIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5EZWZhdWx0TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIGxhenkgPSByZWYubGF6eTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG4gIHZhciBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XG4gIHZhciBldmVudCA9IGxhenlcbiAgICA/ICdjaGFuZ2UnXG4gICAgOiB0eXBlID09PSAncmFuZ2UnXG4gICAgICA/IFJBTkdFX1RPS0VOXG4gICAgICA6ICdpbnB1dCc7XG5cbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQudGFyZ2V0LnZhbHVlJztcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIiRldmVudC50YXJnZXQudmFsdWUudHJpbSgpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuXG4gIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gIGlmIChuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xuICAgIGNvZGUgPSBcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIiArIGNvZGU7XG4gIH1cblxuICBhZGRQcm9wKGVsLCAndmFsdWUnLCAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIGV2ZW50LCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgaWYgKHRyaW0gfHwgbnVtYmVyIHx8IHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgdmFyIGV2ZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKG9uW1JBTkdFX1RPS0VOXSkge1xuICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcbiAgICBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIGlmIChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pIHtcbiAgICAvLyBDaHJvbWUgZmlyZXMgbWljcm90YXNrcyBpbiBiZXR3ZWVuIGNsaWNrL2NoYW5nZSwgbGVhZHMgdG8gIzQ1MjFcbiAgICBldmVudCA9IGlzQ2hyb21lID8gJ2NsaWNrJyA6ICdjaGFuZ2UnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0JDE7XG5cbmZ1bmN0aW9uIGFkZCQxIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIG9uY2UsXG4gIGNhcHR1cmVcbikge1xuICBpZiAob25jZSkge1xuICAgIHZhciBvbGRIYW5kbGVyID0gaGFuZGxlcjtcbiAgICB2YXIgX3RhcmdldCA9IHRhcmdldCQxOyAvLyBzYXZlIGN1cnJlbnQgdGFyZ2V0IGVsZW1lbnQgaW4gY2xvc3VyZVxuICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHZhciByZXMgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgICAgID8gb2xkSGFuZGxlcihldilcbiAgICAgICAgOiBvbGRIYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICAgIHJlbW92ZSQyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMiAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBfdGFyZ2V0XG4pIHtcbiAgKF90YXJnZXQgfHwgdGFyZ2V0JDEpLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoIW9sZFZub2RlLmRhdGEub24gJiYgIXZub2RlLmRhdGEub24pIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDEsIHJlbW92ZSQyLCB2bm9kZS5jb250ZXh0KTtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoIW9sZFZub2RlLmRhdGEuZG9tUHJvcHMgJiYgIXZub2RlLmRhdGEuZG9tUHJvcHMpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXI7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAocHJvcHMuX19vYl9fKSB7XG4gICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgIGlmIChwcm9wc1trZXldID09IG51bGwpIHtcbiAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcbiAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHsgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDsgfVxuICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgeyBjb250aW51ZSB9XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcbiAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgIHZhciBzdHJDdXIgPSBjdXIgPT0gbnVsbCA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCB2bm9kZSwgc3RyQ3VyKSkge1xuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoXG4gIGVsbSxcbiAgdm5vZGUsXG4gIGNoZWNrVmFsXG4pIHtcbiAgcmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXG4gICAgdm5vZGUudGFnID09PSAnb3B0aW9uJyB8fFxuICAgIGlzRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICBpc0lucHV0Q2hhbmdlZChlbG0sIGNoZWNrVmFsKVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXMgbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG4gIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG0gJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbFxufVxuXG5mdW5jdGlvbiBpc0lucHV0Q2hhbmdlZCAoZWxtLCBuZXdWYWwpIHtcbiAgdmFyIHZhbHVlID0gZWxtLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcbiAgaWYgKChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcikgfHwgZWxtLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKVxuICB9XG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLnRyaW0pIHtcbiAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gIH1cbiAgcmV0dXJuIHZhbHVlICE9PSBuZXdWYWxcbn1cblxudmFyIGRvbVByb3BzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxuICB1cGRhdGU6IHVwZGF0ZURPTVByb3BzXG59O1xuXG4vKiAgKi9cblxudmFyIHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGxpc3REZWxpbWl0ZXIgPSAvOyg/IVteKF0qXFwpKS9nO1xuICB2YXIgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xuICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdmFyIHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXIpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG4vLyBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgc3R5bGUgZGF0YSBvbiB0aGUgc2FtZSB2bm9kZVxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcbiAgLy8gc3RhdGljIHN0eWxlIGlzIHByZS1wcm9jZXNzZWQgaW50byBhbiBvYmplY3QgZHVyaW5nIGNvbXBpbGF0aW9uXG4gIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG4gIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlXG4gICAgPyBleHRlbmQoZGF0YS5zdGF0aWNTdHlsZSwgc3R5bGUpXG4gICAgOiBzdHlsZVxufVxuXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcgKGJpbmRpbmdTdHlsZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5nU3R5bGUpKSB7XG4gICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICBpZiAodHlwZW9mIGJpbmRpbmdTdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxuICB9XG4gIHJldHVybiBiaW5kaW5nU3R5bGVcbn1cblxuLyoqXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXG4gKiBzbyB0aGF0IHBhcmVudCBjb21wb25lbnQncyBzdHlsZSBjb3VsZCBvdmVycmlkZSBpdFxuICovXG5mdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgc3R5bGVEYXRhO1xuXG4gIGlmIChjaGVja0NoaWxkKSB7XG4gICAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoY2hpbGROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgfVxuXG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGNzc1ZhclJFID0gL14tLS87XG52YXIgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbnZhciBzZXRQcm9wID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWwpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcbiAgfSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG4gIH0gZWxzZSB7XG4gICAgZWwuc3R5bGVbbm9ybWFsaXplKG5hbWUpXSA9IHZhbDtcbiAgfVxufTtcblxudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG5cbnZhciB0ZXN0RWw7XG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHRlc3RFbCA9IHRlc3RFbCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gdGVzdEVsLnN0eWxlKSkge1xuICAgIHJldHVybiBwcm9wXG4gIH1cbiAgdmFyIHVwcGVyID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJlZml4ZWQgPSBwcmVmaXhlc1tpXSArIHVwcGVyO1xuICAgIGlmIChwcmVmaXhlZCBpbiB0ZXN0RWwuc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZFxuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG5cbiAgaWYgKCFkYXRhLnN0YXRpY1N0eWxlICYmICFkYXRhLnN0eWxlICYmXG4gICAgICAhb2xkRGF0YS5zdGF0aWNTdHlsZSAmJiAhb2xkRGF0YS5zdHlsZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGN1ciwgbmFtZTtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGRWbm9kZS5kYXRhLnN0YXRpY1N0eWxlO1xuICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkVm5vZGUuZGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gIHZub2RlLmRhdGEuc3R5bGUgPSBzdHlsZS5fX29iX18gPyBleHRlbmQoe30sIHN0eWxlKSA6IHN0eWxlO1xuXG4gIHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAobmV3U3R5bGVbbmFtZV0gPT0gbnVsbCkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICB9XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1ci50cmltKCkpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmJCQxKSB7XG4gIGlmICghZGVmJCQxKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGlmIChkZWYkJDEuY3NzICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XG4gICAgfVxuICAgIGV4dGVuZChyZXMsIGRlZiQkMSk7XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMSlcbiAgfVxufVxuXG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlckNsYXNzOiAobmFtZSArIFwiLWVudGVyXCIpLFxuICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKSxcbiAgICBsZWF2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlXCIpLFxuICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlLWFjdGl2ZVwiKVxuICB9XG59KTtcblxudmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xudmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG52YXIgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbnZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcbnZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG52YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5pZiAoaGFzVHJhbnNpdGlvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZCkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZCkge1xuICAgIGFuaW1hdGlvblByb3AgPSAnV2Via2l0QW5pbWF0aW9uJztcbiAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICB9XG59XG5cbi8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxudmFyIHJhZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbiAgOiBzZXRUaW1lb3V0O1xuXG5mdW5jdGlvbiBuZXh0RnJhbWUgKGZuKSB7XG4gIHJhZihmdW5jdGlvbiAoKSB7XG4gICAgcmFmKGZuKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICAoZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSkpLnB1c2goY2xzKTtcbiAgYWRkQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgdmFyIHR5cGU7XG4gIHZhciB0aW1lb3V0ID0gMDtcbiAgdmFyIHByb3BDb3VudCA9IDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXG4gICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgOiBBTklNQVRJT05cbiAgICAgIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgIDogMDtcbiAgfVxuICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxuICB9KSlcbn1cblxuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGVsLl9sZWF2ZUNiKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoIWRhdGEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwuX2VudGVyQ2IgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XG4gIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcbiAgdmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcbiAgdmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xuICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICB9XG5cbiAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3NcbiAgICA/IGFwcGVhckNsYXNzXG4gICAgOiBlbnRlckNsYXNzO1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgID8gYXBwZWFyVG9DbGFzc1xuICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICA6IGJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgOiBlbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgIDogYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgIDogZW50ZXJDYW5jZWxsZWQ7XG5cbiAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcbiAgICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IpIHtcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XG4gICAgICB9XG4gICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgfSk7XG4gIH1cblxuICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gIGJlZm9yZUVudGVySG9vayAmJiBiZWZvcmVFbnRlckhvb2soZWwpO1xuICBpZiAoZXhwZWN0c0NTUykge1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRFbnRlckR1cmF0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xuICAgIHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xuICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgfVxuXG4gIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgIGNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVhdmUgKHZub2RlLCBybSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcbiAgaWYgKGVsLl9lbnRlckNiKSB7XG4gICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fZW50ZXJDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoIWRhdGEpIHtcbiAgICByZXR1cm4gcm0oKVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbC5fbGVhdmVDYiB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3M7XG4gIHZhciBsZWF2ZVRvQ2xhc3MgPSBkYXRhLmxlYXZlVG9DbGFzcztcbiAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmU7XG4gIHZhciBsZWF2ZSA9IGRhdGEubGVhdmU7XG4gIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xuICB2YXIgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkO1xuICB2YXIgZGVsYXlMZWF2ZSA9IGRhdGEuZGVsYXlMZWF2ZTtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG4gIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24ubGVhdmVcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBleHBsaWNpdExlYXZlRHVyYXRpb24gIT0gbnVsbCkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uLCAnbGVhdmUnLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgY2IgPSBlbC5fbGVhdmVDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuX3BlbmRpbmcpIHtcbiAgICAgIGVsLnBhcmVudE5vZGUuX3BlbmRpbmdbdm5vZGUua2V5XSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgfVxuICAgICAgbGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKGVsKTtcbiAgICB9XG4gICAgZWwuX2xlYXZlQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgIGRlbGF5TGVhdmUocGVyZm9ybUxlYXZlKTtcbiAgfSBlbHNlIHtcbiAgICBwZXJmb3JtTGVhdmUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZSAoKSB7XG4gICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyByZWNvcmQgbGVhdmluZyBlbGVtZW50XG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVt2bm9kZS5rZXldID0gdm5vZGU7XG4gICAgfVxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG4gICAgICBcImdvdCBcIiArIChKU09OLnN0cmluZ2lmeSh2YWwpKSArIFwiLlwiLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXG4gICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gIGlmICghZm4pIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyIGludm9rZXJGbnMgPSBmbi5mbnM7XG4gIGlmIChpbnZva2VyRm5zKSB7XG4gICAgLy8gaW52b2tlclxuICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuICAgICAgICA/IGludm9rZXJGbnNbMF1cbiAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICB9XG59XG5cbmZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICBlbnRlcih2bm9kZSk7XG4gIH1cbn1cblxudmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XG4gIGNyZWF0ZTogX2VudGVyLFxuICBhY3RpdmF0ZTogX2VudGVyLFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSQkMSAodm5vZGUsIHJtKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICB9XG4gIH1cbn0gOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXTtcblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChpc0lFOSkge1xuICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIG1vZGVsJDEgPSB7XG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHZhciBjYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIGNiKCk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGNiLCAwKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBlbC50eXBlID09PSAndGV4dCcgfHwgZWwudHlwZSA9PT0gJ3Bhc3N3b3JkJykge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICBpZiAoIWlzQW5kcm9pZCkge1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICB2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcbiAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgZWwub3B0aW9ucyk7IH0pXG4gICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGVsLm9wdGlvbnMpO1xuICAgICAgaWYgKG5lZWRSZXNldCkge1xuICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG4gICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBvcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbnNbaV0pLCB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICA6IG9wdGlvbi52YWx1ZVxufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8qICAqL1xuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICA6IHZub2RlXG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24gPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiAmJiAhaXNJRTkpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24gJiYgIWlzSUU5KSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcbiAgICBlbCxcbiAgICBiaW5kaW5nLFxuICAgIHZub2RlLFxuICAgIG9sZFZub2RlLFxuICAgIGlzRGVzdHJveVxuICApIHtcbiAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gIG1vZGVsOiBtb2RlbCQxLFxuICBzaG93OiBzaG93XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBhIHNpbmdsZSBlbGVtZW50L2NvbXBvbmVudC5cbi8vIHN1cHBvcnRzIHRyYW5zaXRpb24gbW9kZSAob3V0LWluIC8gaW4tb3V0KVxuXG52YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgY3NzOiBCb29sZWFuLFxuICBtb2RlOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgZW50ZXJDbGFzczogU3RyaW5nLFxuICBsZWF2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxufTtcblxuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuZnVuY3Rpb24gZ2V0UmVhbENoaWxkICh2bm9kZSkge1xuICB2YXIgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAvLyBwcm9wc1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcbiAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XG4gIH1cbiAgLy8gZXZlbnRzLlxuICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgZm9yICh2YXIga2V5JDEgaW4gbGlzdGVuZXJzKSB7XG4gICAgZGF0YVtjYW1lbGl6ZShrZXkkMSldID0gbGlzdGVuZXJzW2tleSQxXTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgcmV0dXJuIC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKVxuICAgID8gaCgna2VlcC1hbGl2ZScpXG4gICAgOiBudWxsXG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWc7IH0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2FybihcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAvLyBwYXJlbnQgY29udGFpbmVyIG5vZGUgYWxzbyBoYXMgdHJhbnNpdGlvbiwgc2tpcC5cbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgIHZhciBpZCA9IFwiX190cmFuc2l0aW9uLVwiICsgKHRoaXMuX3VpZCkgKyBcIi1cIjtcbiAgICBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxuICAgICAgPyBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgdmFyIGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfSkpIHtcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG9sZENoaWxkICYmIG9sZENoaWxkLmRhdGEgJiYgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkpIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZCAmJiAob2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XG4gICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmF3Q2hpbGRcbiAgfVxufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgbGlzdCBpdGVtcy5cbi8vIHN1cHBvcnRzIG1vdmUgdHJhbnNpdGlvbnMgdXNpbmcgdGhlIEZMSVAgdGVjaG5pcXVlLlxuXG4vLyBCZWNhdXNlIHRoZSB2ZG9tJ3MgY2hpbGRyZW4gdXBkYXRlIGFsZ29yaXRobSBpcyBcInVuc3RhYmxlXCIgLSBpLmUuXG4vLyBpdCBkb2Vzbid0IGd1YXJhbnRlZSB0aGUgcmVsYXRpdmUgcG9zaXRpb25pbmcgb2YgcmVtb3ZlZCBlbGVtZW50cyxcbi8vIHdlIGZvcmNlIHRyYW5zaXRpb24tZ3JvdXAgdG8gdXBkYXRlIGl0cyBjaGlsZHJlbiBpbnRvIHR3byBwYXNzZXM6XG4vLyBpbiB0aGUgZmlyc3QgcGFzcywgd2UgcmVtb3ZlIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVtb3ZlZCxcbi8vIHRyaWdnZXJpbmcgdGhlaXIgbGVhdmluZyB0cmFuc2l0aW9uOyBpbiB0aGUgc2Vjb25kIHBhc3MsIHdlIGluc2VydC9tb3ZlXG4vLyBpbnRvIHRoZSBmaW5hbCBkZXNpcmVkIHN0YXRlLiBUaGlzIHdheSBpbiB0aGUgc2Vjb25kIHBhc3MgcmVtb3ZlZFxuLy8gbm9kZXMgd2lsbCByZW1haW4gd2hlcmUgdGhleSBzaG91bGQgYmUuXG5cbnZhciBwcm9wcyA9IGV4dGVuZCh7XG4gIHRhZzogU3RyaW5nLFxuICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcblxuZGVsZXRlIHByb3BzLm1vZGU7XG5cbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gIHByb3BzOiBwcm9wcyxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgaWYgKGMudGFnKSB7XG4gICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xuICAgICAgICAgIDsoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgd2FybigoXCI8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPFwiICsgbmFtZSArIFwiPlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgfSxcblxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZSAoKSB7XG4gICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgIHRoaXMuX19wYXRjaF9fKFxuICAgICAgdGhpcy5fdm5vZGUsXG4gICAgICB0aGlzLmtlcHQsXG4gICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICApO1xuICAgIHRoaXMuX3Zub2RlID0gdGhpcy5rZXB0O1xuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgdmFyIGYgPSBib2R5Lm9mZnNldEhlaWdodDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9oYXNNb3ZlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufTtcblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZSQzLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuVnVlJDMuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlJDMuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZSQzLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG5leHRlbmQoVnVlJDMub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZSQzLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlJDMucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcblxuLy8gcHVibGljIG1vdW50IG1ldGhvZFxuVnVlJDMucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUkMyk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzQ2hyb21lKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICAgIGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgIFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcbiAgICAgIFwiTWFrZSBzdXJlIHRvIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIHdoZW4gZGVwbG95aW5nIGZvciBwcm9kdWN0aW9uLlxcblwiICtcbiAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICk7XG4gIH1cbn0sIDApO1xuXG4vKiAgKi9cblxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbmZ1bmN0aW9uIHNob3VsZERlY29kZSAoY29udGVudCwgZW5jb2RlZCkge1xuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pbm5lckhUTUwgPSBcIjxkaXYgYT1cXFwiXCIgKyBjb250ZW50ICsgXCJcXFwiPlwiO1xuICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKGVuY29kZWQpID4gMFxufVxuXG4vLyAjMzY2M1xuLy8gSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gc2hvdWxkRGVjb2RlKCdcXG4nLCAnJiMxMDsnKSA6IGZhbHNlO1xuXG4vKiAgKi9cblxudmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKFxuICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXG4gICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicidcbik7XG5cbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxudmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKFxuICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcbik7XG5cbi8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxudmFyIGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXG4gICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG4gICd0aXRsZSx0cix0cmFjaydcbik7XG5cbi8qICAqL1xuXG52YXIgZGVjb2RlcjtcblxuZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gIGRlY29kZXIgPSBkZWNvZGVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkZWNvZGVyLmlubmVySFRNTCA9IGh0bWw7XG4gIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG59XG5cbi8qKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gKi9cblxuLyohXG4gKiBIVE1MIFBhcnNlciBCeSBKb2huIFJlc2lnIChlam9obi5vcmcpXG4gKiBNb2RpZmllZCBieSBKdXJpeSBcImthbmdheFwiIFpheXRzZXZcbiAqIE9yaWdpbmFsIGNvZGUgYnkgRXJpayBBcnZpZHNzb24sIE1vemlsbGEgUHVibGljIExpY2Vuc2VcbiAqIGh0dHA6Ly9lcmlrLmVhZS5uZXQvc2ltcGxlaHRtbHBhcnNlci9zaW1wbGVodG1scGFyc2VyLmpzXG4gKi9cblxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG52YXIgc2luZ2xlQXR0cklkZW50aWZpZXIgPSAvKFteXFxzXCInPD4vPV0rKS87XG52YXIgc2luZ2xlQXR0ckFzc2lnbiA9IC8oPzo9KS87XG52YXIgc2luZ2xlQXR0clZhbHVlcyA9IFtcbiAgLy8gYXR0ciB2YWx1ZSBkb3VibGUgcXVvdGVzXG4gIC9cIihbXlwiXSopXCIrLy5zb3VyY2UsXG4gIC8vIGF0dHIgdmFsdWUsIHNpbmdsZSBxdW90ZXNcbiAgLycoW14nXSopJysvLnNvdXJjZSxcbiAgLy8gYXR0ciB2YWx1ZSwgbm8gcXVvdGVzXG4gIC8oW15cXHNcIic9PD5gXSspLy5zb3VyY2Vcbl07XG52YXIgYXR0cmlidXRlID0gbmV3IFJlZ0V4cChcbiAgJ15cXFxccyonICsgc2luZ2xlQXR0cklkZW50aWZpZXIuc291cmNlICtcbiAgJyg/OlxcXFxzKignICsgc2luZ2xlQXR0ckFzc2lnbi5zb3VyY2UgKyAnKScgK1xuICAnXFxcXHMqKD86JyArIHNpbmdsZUF0dHJWYWx1ZXMuam9pbignfCcpICsgJykpPydcbik7XG5cbi8vIGNvdWxkIHVzZSBodHRwczovL3d3dy53My5vcmcvVFIvMTk5OS9SRUMteG1sLW5hbWVzLTE5OTkwMTE0LyNOVC1RTmFtZVxuLy8gYnV0IGZvciBWdWUgdGVtcGxhdGVzIHdlIGNhbiBlbmZvcmNlIGEgc2ltcGxlIGNoYXJzZXRcbnZhciBuY25hbWUgPSAnW2EtekEtWl9dW1xcXFx3XFxcXC1cXFxcLl0qJztcbnZhciBxbmFtZUNhcHR1cmUgPSAnKCg/OicgKyBuY25hbWUgKyAnXFxcXDopPycgKyBuY25hbWUgKyAnKSc7XG52YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgnXjwnICsgcW5hbWVDYXB0dXJlKTtcbnZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG52YXIgZW5kVGFnID0gbmV3IFJlZ0V4cCgnXjxcXFxcLycgKyBxbmFtZUNhcHR1cmUgKyAnW14+XSo+Jyk7XG52YXIgZG9jdHlwZSA9IC9ePCFET0NUWVBFIFtePl0rPi9pO1xudmFyIGNvbW1lbnQgPSAvXjwhLS0vO1xudmFyIGNvbmRpdGlvbmFsQ29tbWVudCA9IC9ePCFcXFsvO1xuXG52YXIgSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiA9IGZhbHNlO1xuJ3gnLnJlcGxhY2UoL3goLik/L2csIGZ1bmN0aW9uIChtLCBnKSB7XG4gIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBnID09PSAnJztcbn0pO1xuXG4vLyBTcGVjaWFsIEVsZW1lbnRzIChjYW4gY29udGFpbiBhbnl0aGluZylcbnZhciBpc1BsYWluVGV4dEVsZW1lbnQgPSBtYWtlTWFwKCdzY3JpcHQsc3R5bGUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciByZUNhY2hlID0ge307XG5cbnZhciBkZWNvZGluZ01hcCA9IHtcbiAgJyZsdDsnOiAnPCcsXG4gICcmZ3Q7JzogJz4nLFxuICAnJnF1b3Q7JzogJ1wiJyxcbiAgJyZhbXA7JzogJyYnLFxuICAnJiMxMDsnOiAnXFxuJ1xufTtcbnZhciBlbmNvZGVkQXR0ciA9IC8mKD86bHR8Z3R8cXVvdHxhbXApOy9nO1xudmFyIGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMTApOy9nO1xuXG5mdW5jdGlvbiBkZWNvZGVBdHRyICh2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpIHtcbiAgdmFyIHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShyZSwgZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBkZWNvZGluZ01hcFttYXRjaF07IH0pXG59XG5cbmZ1bmN0aW9uIHBhcnNlSFRNTCAoaHRtbCwgb3B0aW9ucykge1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XG4gIHZhciBpc1VuYXJ5VGFnJCQxID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xuICB2YXIgY2FuQmVMZWZ0T3BlblRhZyQkMSA9IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyB8fCBubztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3QsIGxhc3RUYWc7XG4gIHdoaWxlIChodG1sKSB7XG4gICAgbGFzdCA9IGh0bWw7XG4gICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHBsYWludGV4dCBjb250ZW50IGVsZW1lbnQgbGlrZSBzY3JpcHQvc3R5bGVcbiAgICBpZiAoIWxhc3RUYWcgfHwgIWlzUGxhaW5UZXh0RWxlbWVudChsYXN0VGFnKSkge1xuICAgICAgdmFyIHRleHRFbmQgPSBodG1sLmluZGV4T2YoJzwnKTtcbiAgICAgIGlmICh0ZXh0RW5kID09PSAwKSB7XG4gICAgICAgIC8vIENvbW1lbnQ6XG4gICAgICAgIGlmIChjb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XG5cbiAgICAgICAgICBpZiAoY29tbWVudEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50I0Rvd25sZXZlbC1yZXZlYWxlZF9jb25kaXRpb25hbF9jb21tZW50XG4gICAgICAgIGlmIChjb25kaXRpb25hbENvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuICAgICAgICAgIGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbmRpdGlvbmFsRW5kICsgMik7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvY3R5cGU6XG4gICAgICAgIHZhciBkb2N0eXBlTWF0Y2ggPSBodG1sLm1hdGNoKGRvY3R5cGUpO1xuICAgICAgICBpZiAoZG9jdHlwZU1hdGNoKSB7XG4gICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgdmFyIGVuZFRhZ01hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xuICAgICAgICBpZiAoZW5kVGFnTWF0Y2gpIHtcbiAgICAgICAgICB2YXIgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICBhZHZhbmNlKGVuZFRhZ01hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgcGFyc2VFbmRUYWcoZW5kVGFnTWF0Y2hbMV0sIGN1ckluZGV4LCBpbmRleCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHRhZzpcbiAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XG4gICAgICAgICAgaGFuZGxlU3RhcnRUYWcoc3RhcnRUYWdNYXRjaCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGV4dCA9ICh2b2lkIDApLCByZXN0JDEgPSAodm9pZCAwKSwgbmV4dCA9ICh2b2lkIDApO1xuICAgICAgaWYgKHRleHRFbmQgPj0gMCkge1xuICAgICAgICByZXN0JDEgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgIWVuZFRhZy50ZXN0KHJlc3QkMSkgJiZcbiAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCQxKSAmJlxuICAgICAgICAgICFjb21tZW50LnRlc3QocmVzdCQxKSAmJlxuICAgICAgICAgICFjb25kaXRpb25hbENvbW1lbnQudGVzdChyZXN0JDEpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XG4gICAgICAgICAgbmV4dCA9IHJlc3QkMS5pbmRleE9mKCc8JywgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPCAwKSB7IGJyZWFrIH1cbiAgICAgICAgICB0ZXh0RW5kICs9IG5leHQ7XG4gICAgICAgICAgcmVzdCQxID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gaHRtbC5zdWJzdHJpbmcoMCwgdGV4dEVuZCk7XG4gICAgICAgIGFkdmFuY2UodGV4dEVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0RW5kIDwgMCkge1xuICAgICAgICB0ZXh0ID0gaHRtbDtcbiAgICAgICAgaHRtbCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jaGFycyAmJiB0ZXh0KSB7XG4gICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFja2VkVGFnID0gbGFzdFRhZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHJlU3RhY2tlZFRhZyA9IHJlQ2FjaGVbc3RhY2tlZFRhZ10gfHwgKHJlQ2FjaGVbc3RhY2tlZFRhZ10gPSBuZXcgUmVnRXhwKCcoW1xcXFxzXFxcXFNdKj8pKDwvJyArIHN0YWNrZWRUYWcgKyAnW14+XSo+KScsICdpJykpO1xuICAgICAgdmFyIGVuZFRhZ0xlbmd0aCA9IDA7XG4gICAgICB2YXIgcmVzdCA9IGh0bWwucmVwbGFjZShyZVN0YWNrZWRUYWcsIGZ1bmN0aW9uIChhbGwsIHRleHQsIGVuZFRhZykge1xuICAgICAgICBlbmRUYWdMZW5ndGggPSBlbmRUYWcubGVuZ3RoO1xuICAgICAgICBpZiAoIWlzUGxhaW5UZXh0RWxlbWVudChzdGFja2VkVGFnKSAmJiBzdGFja2VkVGFnICE9PSAnbm9zY3JpcHQnKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IS0tKFtcXHNcXFNdKj8pLS0+L2csICckMScpXG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCAnJDEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jaGFycykge1xuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9KTtcbiAgICAgIGluZGV4ICs9IGh0bWwubGVuZ3RoIC0gcmVzdC5sZW5ndGg7XG4gICAgICBodG1sID0gcmVzdDtcbiAgICAgIHBhcnNlRW5kVGFnKHN0YWNrZWRUYWcsIGluZGV4IC0gZW5kVGFnTGVuZ3RoLCBpbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzdGFjay5sZW5ndGggJiYgb3B0aW9ucy53YXJuKSB7XG4gICAgICAgIG9wdGlvbnMud2FybigoXCJNYWwtZm9ybWF0dGVkIHRhZyBhdCBlbmQgb2YgdGVtcGxhdGU6IFxcXCJcIiArIGh0bWwgKyBcIlxcXCJcIikpO1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBDbGVhbiB1cCBhbnkgcmVtYWluaW5nIHRhZ3NcbiAgcGFyc2VFbmRUYWcoKTtcblxuICBmdW5jdGlvbiBhZHZhbmNlIChuKSB7XG4gICAgaW5kZXggKz0gbjtcbiAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0YXJ0VGFnICgpIHtcbiAgICB2YXIgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB7XG4gICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxuICAgICAgICBhdHRyczogW10sXG4gICAgICAgIHN0YXJ0OiBpbmRleFxuICAgICAgfTtcbiAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcbiAgICAgIHZhciBlbmQsIGF0dHI7XG4gICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYWR2YW5jZShhdHRyWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmF0dHJzLnB1c2goYXR0cik7XG4gICAgICB9XG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XG4gICAgICAgIGFkdmFuY2UoZW5kWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmVuZCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdGFydFRhZyAobWF0Y2gpIHtcbiAgICB2YXIgdGFnTmFtZSA9IG1hdGNoLnRhZ05hbWU7XG4gICAgdmFyIHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgaWYgKGV4cGVjdEhUTUwpIHtcbiAgICAgIGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xuICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5CZUxlZnRPcGVuVGFnJCQxKHRhZ05hbWUpICYmIGxhc3RUYWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCB0YWdOYW1lID09PSAnaHRtbCcgJiYgbGFzdFRhZyA9PT0gJ2hlYWQnIHx8ICEhdW5hcnlTbGFzaDtcblxuICAgIHZhciBsID0gbWF0Y2guYXR0cnMubGVuZ3RoO1xuICAgIHZhciBhdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcbiAgICAgIC8vIGhhY2tpc2ggd29yayBhcm91bmQgRkYgYnVnIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTM2OTc3OFxuICAgICAgaWYgKElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gJiYgYXJnc1swXS5pbmRleE9mKCdcIlwiJykgPT09IC0xKSB7XG4gICAgICAgIGlmIChhcmdzWzNdID09PSAnJykgeyBkZWxldGUgYXJnc1szXTsgfVxuICAgICAgICBpZiAoYXJnc1s0XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNF07IH1cbiAgICAgICAgaWYgKGFyZ3NbNV0gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzVdOyB9XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBhcmdzWzNdIHx8IGFyZ3NbNF0gfHwgYXJnc1s1XSB8fCAnJztcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cihcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzXG4gICAgICAgIClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCF1bmFyeSkge1xuICAgICAgc3RhY2sucHVzaCh7IHRhZzogdGFnTmFtZSwgbG93ZXJDYXNlZFRhZzogdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRyczogYXR0cnMgfSk7XG4gICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpIHsgc3RhcnQgPSBpbmRleDsgfVxuICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxuXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGxvd2VyQ2FzZWRUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgIGlmIChzdGFja1twb3NdLmxvd2VyQ2FzZWRUYWcgPT09IGxvd2VyQ2FzZWRUYWdOYW1lKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyB0YWcgbmFtZSBpcyBwcm92aWRlZCwgY2xlYW4gc2hvcFxuICAgICAgcG9zID0gMDtcbiAgICB9XG5cbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXG4gICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSBwb3M7IGktLSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgKGkgPiBwb3MgfHwgIXRhZ05hbWUpICYmXG4gICAgICAgICAgICBvcHRpb25zLndhcm4pIHtcbiAgICAgICAgICBvcHRpb25zLndhcm4oXG4gICAgICAgICAgICAoXCJ0YWcgPFwiICsgKHN0YWNrW2ldLnRhZykgKyBcIj4gaGFzIG5vIG1hdGNoaW5nIGVuZCB0YWcuXCIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xuICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgb3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGVmYXVsdFRhZ1JFID0gL1xce1xceygoPzoufFxcbikrPylcXH1cXH0vZztcbnZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcblxudmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcbiAgdmFyIG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICB2YXIgY2xvc2UgPSBkZWxpbWl0ZXJzWzFdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKVxufSk7XG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXG4gIHRleHQsXG4gIGRlbGltaXRlcnNcbikge1xuICB2YXIgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgdmFyIG1hdGNoLCBpbmRleDtcbiAgd2hpbGUgKChtYXRjaCA9IHRhZ1JFLmV4ZWModGV4dCkpKSB7XG4gICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAvLyBwdXNoIHRleHQgdG9rZW5cbiAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpKTtcbiAgICB9XG4gICAgLy8gdGFnIHRva2VuXG4gICAgdmFyIGV4cCA9IHBhcnNlRmlsdGVycyhtYXRjaFsxXS50cmltKCkpO1xuICAgIHRva2Vucy5wdXNoKChcIl9zKFwiICsgZXhwICsgXCIpXCIpKTtcbiAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgfVxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0ZXh0LnNsaWNlKGxhc3RJbmRleCkpKTtcbiAgfVxuICByZXR1cm4gdG9rZW5zLmpvaW4oJysnKVxufVxuXG4vKiAgKi9cblxudmFyIG9uUkUgPSAvXkB8XnYtb246LztcbnZhciBkaXJSRSA9IC9edi18XkB8XjovO1xudmFyIGZvckFsaWFzUkUgPSAvKC4qPylcXHMrKD86aW58b2YpXFxzKyguKikvO1xudmFyIGZvckl0ZXJhdG9yUkUgPSAvXFwoKFxce1tefV0qXFx9fFteLF0qKSwoW14sXSopKD86LChbXixdKikpP1xcKS87XG5cbnZhciBhcmdSRSA9IC86KC4qKSQvO1xudmFyIGJpbmRSRSA9IC9eOnxedi1iaW5kOi87XG52YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5dKy9nO1xuXG52YXIgZGVjb2RlSFRNTENhY2hlZCA9IGNhY2hlZChkZWNvZGUpO1xuXG4vLyBjb25maWd1cmFibGUgc3RhdGVcbnZhciB3YXJuJDI7XG52YXIgZGVsaW1pdGVycztcbnZhciB0cmFuc2Zvcm1zO1xudmFyIHByZVRyYW5zZm9ybXM7XG52YXIgcG9zdFRyYW5zZm9ybXM7XG52YXIgcGxhdGZvcm1Jc1ByZVRhZztcbnZhciBwbGF0Zm9ybU11c3RVc2VQcm9wO1xudmFyIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlO1xuXG4vKipcbiAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gQVNULlxuICovXG5mdW5jdGlvbiBwYXJzZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgd2FybiQyID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSA9IG9wdGlvbnMuZ2V0VGFnTmFtZXNwYWNlIHx8IG5vO1xuICBwbGF0Zm9ybU11c3RVc2VQcm9wID0gb3B0aW9ucy5tdXN0VXNlUHJvcCB8fCBubztcbiAgcGxhdGZvcm1Jc1ByZVRhZyA9IG9wdGlvbnMuaXNQcmVUYWcgfHwgbm87XG4gIHByZVRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3ByZVRyYW5zZm9ybU5vZGUnKTtcbiAgdHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtTm9kZScpO1xuICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcbiAgZGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycztcblxuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcbiAgdmFyIHJvb3Q7XG4gIHZhciBjdXJyZW50UGFyZW50O1xuICB2YXIgaW5WUHJlID0gZmFsc2U7XG4gIHZhciBpblByZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZykge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgd2FybiQyKG1zZyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5kUHJlIChlbGVtZW50KSB7XG4gICAgLy8gY2hlY2sgcHJlIHN0YXRlXG4gICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICBpblZQcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICBpblByZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgIHdhcm46IHdhcm4kMixcbiAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQgKHRhZywgYXR0cnMsIHVuYXJ5KSB7XG4gICAgICAvLyBjaGVjayBuYW1lc3BhY2UuXG4gICAgICAvLyBpbmhlcml0IHBhcmVudCBucyBpZiB0aGVyZSBpcyBvbmVcbiAgICAgIHZhciBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XG5cbiAgICAgIC8vIGhhbmRsZSBJRSBzdmcgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmIG5zID09PSAnc3ZnJykge1xuICAgICAgICBhdHRycyA9IGd1YXJkSUVTVkdCdWcoYXR0cnMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudCA9IHtcbiAgICAgICAgdHlwZTogMSxcbiAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgIGF0dHJzTGlzdDogYXR0cnMsXG4gICAgICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgICAgICBwYXJlbnQ6IGN1cnJlbnRQYXJlbnQsXG4gICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgfTtcbiAgICAgIGlmIChucykge1xuICAgICAgICBlbGVtZW50Lm5zID0gbnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xuICAgICAgICBlbGVtZW50LmZvcmJpZGRlbiA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKFxuICAgICAgICAgICdUZW1wbGF0ZXMgc2hvdWxkIG9ubHkgYmUgcmVzcG9uc2libGUgZm9yIG1hcHBpbmcgdGhlIHN0YXRlIHRvIHRoZSAnICtcbiAgICAgICAgICAnVUkuIEF2b2lkIHBsYWNpbmcgdGFncyB3aXRoIHNpZGUtZWZmZWN0cyBpbiB5b3VyIHRlbXBsYXRlcywgc3VjaCBhcyAnICtcbiAgICAgICAgICBcIjxcIiArIHRhZyArIFwiPlwiICsgJywgYXMgdGhleSB3aWxsIG5vdCBiZSBwYXJzZWQuJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBseSBwcmUtdHJhbnNmb3Jtc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByZVRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NQcmUoZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgICAgIGluVlByZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgICBpblByZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NSYXdBdHRycyhlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3NGb3IoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NJZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc09uY2UoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NLZXkoZWxlbWVudCk7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgYWZ0ZXJcbiAgICAgICAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXG4gICAgICAgIGVsZW1lbnQucGxhaW4gPSAhZWxlbWVudC5rZXkgJiYgIWF0dHJzLmxlbmd0aDtcblxuICAgICAgICBwcm9jZXNzUmVmKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzU2xvdChlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdHJhbnNmb3Jtcy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgdHJhbnNmb3Jtc1tpJDFdKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2hlY2tSb290Q29uc3RyYWludHMgKGVsKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIFwiQ2Fubm90IHVzZSA8XCIgKyAoZWwudGFnKSArIFwiPiBhcyBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgaXQgbWF5IFwiICtcbiAgICAgICAgICAgICAgJ2NvbnRhaW4gbXVsdGlwbGUgbm9kZXMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWZvcicpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgJ0Nhbm5vdCB1c2Ugdi1mb3Igb24gc3RhdGVmdWwgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlICcgK1xuICAgICAgICAgICAgICAnaXQgcmVuZGVycyBtdWx0aXBsZSBlbGVtZW50cy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0cmVlIG1hbmFnZW1lbnRcbiAgICAgIGlmICghcm9vdCkge1xuICAgICAgICByb290ID0gZWxlbWVudDtcbiAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMocm9vdCk7XG4gICAgICB9IGVsc2UgaWYgKCFzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgLy8gYWxsb3cgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYsIHYtZWxzZS1pZiBhbmQgdi1lbHNlXG4gICAgICAgIGlmIChyb290LmlmICYmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpKSB7XG4gICAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMoZWxlbWVudCk7XG4gICAgICAgICAgYWRkSWZDb25kaXRpb24ocm9vdCwge1xuICAgICAgICAgICAgZXhwOiBlbGVtZW50LmVsc2VpZixcbiAgICAgICAgICAgIGJsb2NrOiBlbGVtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgXCJDb21wb25lbnQgdGVtcGxhdGUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcm9vdCBlbGVtZW50LiBcIiArXG4gICAgICAgICAgICBcIklmIHlvdSBhcmUgdXNpbmcgdi1pZiBvbiBtdWx0aXBsZSBlbGVtZW50cywgXCIgK1xuICAgICAgICAgICAgXCJ1c2Ugdi1lbHNlLWlmIHRvIGNoYWluIHRoZW0gaW5zdGVhZC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50UGFyZW50ICYmICFlbGVtZW50LmZvcmJpZGRlbikge1xuICAgICAgICBpZiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSB7XG4gICAgICAgICAgcHJvY2Vzc0lmQ29uZGl0aW9ucyhlbGVtZW50LCBjdXJyZW50UGFyZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnNsb3RTY29wZSkgeyAvLyBzY29wZWQgc2xvdFxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQucGxhaW4gPSBmYWxzZTtcbiAgICAgICAgICB2YXIgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnXCJkZWZhdWx0XCInOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgIGVsZW1lbnQucGFyZW50ID0gY3VycmVudFBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF1bmFyeSkge1xuICAgICAgICBjdXJyZW50UGFyZW50ID0gZWxlbWVudDtcbiAgICAgICAgc3RhY2sucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZFByZShlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIC8vIGFwcGx5IHBvc3QtdHJhbnNmb3Jtc1xuICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgcG9zdFRyYW5zZm9ybXMubGVuZ3RoOyBpJDIrKykge1xuICAgICAgICBwb3N0VHJhbnNmb3Jtc1tpJDJdKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbmQ6IGZ1bmN0aW9uIGVuZCAoKSB7XG4gICAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgdmFyIGVsZW1lbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBsYXN0Tm9kZSA9IGVsZW1lbnQuY2hpbGRyZW5bZWxlbWVudC5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0Tm9kZSAmJiBsYXN0Tm9kZS50eXBlID09PSAzICYmIGxhc3ROb2RlLnRleHQgPT09ICcgJyAmJiAhaW5QcmUpIHtcbiAgICAgICAgZWxlbWVudC5jaGlsZHJlbi5wb3AoKTtcbiAgICAgIH1cbiAgICAgIC8vIHBvcCBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoIC09IDE7XG4gICAgICBjdXJyZW50UGFyZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICBlbmRQcmUoZWxlbWVudCk7XG4gICAgfSxcblxuICAgIGNoYXJzOiBmdW5jdGlvbiBjaGFycyAodGV4dCkge1xuICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHRleHQgPT09IHRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgJ0NvbXBvbmVudCB0ZW1wbGF0ZSByZXF1aXJlcyBhIHJvb3QgZWxlbWVudCwgcmF0aGVyIHRoYW4ganVzdCB0ZXh0LidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICgodGV4dCA9IHRleHQudHJpbSgpKSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIChcInRleHQgXFxcIlwiICsgdGV4dCArIFwiXFxcIiBvdXRzaWRlIHJvb3QgZWxlbWVudCB3aWxsIGJlIGlnbm9yZWQuXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vIElFIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJlxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQudGFnID09PSAndGV4dGFyZWEnICYmXG4gICAgICAgICAgY3VycmVudFBhcmVudC5hdHRyc01hcC5wbGFjZWhvbGRlciA9PT0gdGV4dCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlbiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW47XG4gICAgICB0ZXh0ID0gaW5QcmUgfHwgdGV4dC50cmltKClcbiAgICAgICAgPyBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpXG4gICAgICAgIC8vIG9ubHkgcHJlc2VydmUgd2hpdGVzcGFjZSBpZiBpdHMgbm90IHJpZ2h0IGFmdGVyIGEgc3RhcnRpbmcgdGFnXG4gICAgICAgIDogcHJlc2VydmVXaGl0ZXNwYWNlICYmIGNoaWxkcmVuLmxlbmd0aCA/ICcgJyA6ICcnO1xuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb247XG4gICAgICAgIGlmICghaW5WUHJlICYmIHRleHQgIT09ICcgJyAmJiAoZXhwcmVzc2lvbiA9IHBhcnNlVGV4dCh0ZXh0LCBkZWxpbWl0ZXJzKSkpIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDIsXG4gICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRleHQgIT09ICcgJyB8fCAhY2hpbGRyZW4ubGVuZ3RoIHx8IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnRleHQgIT09ICcgJykge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiByb290XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NQcmUgKGVsKSB7XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1wcmUnKSAhPSBudWxsKSB7XG4gICAgZWwucHJlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMgKGVsKSB7XG4gIHZhciBsID0gZWwuYXR0cnNMaXN0Lmxlbmd0aDtcbiAgaWYgKGwpIHtcbiAgICB2YXIgYXR0cnMgPSBlbC5hdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGVsLmF0dHJzTGlzdFtpXS5uYW1lLFxuICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoZWwuYXR0cnNMaXN0W2ldLnZhbHVlKVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWVsLnByZSkge1xuICAgIC8vIG5vbiByb290IG5vZGUgaW4gcHJlIGJsb2NrcyB3aXRoIG5vIGF0dHJpYnV0ZXNcbiAgICBlbC5wbGFpbiA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0tleSAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEJpbmRpbmdBdHRyKGVsLCAna2V5Jyk7XG4gIGlmIChleHApIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHdhcm4kMihcIjx0ZW1wbGF0ZT4gY2Fubm90IGJlIGtleWVkLiBQbGFjZSB0aGUga2V5IG9uIHJlYWwgZWxlbWVudHMgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIGVsLmtleSA9IGV4cDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmVmIChlbCkge1xuICB2YXIgcmVmID0gZ2V0QmluZGluZ0F0dHIoZWwsICdyZWYnKTtcbiAgaWYgKHJlZikge1xuICAgIGVsLnJlZiA9IHJlZjtcbiAgICBlbC5yZWZJbkZvciA9IGNoZWNrSW5Gb3IoZWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NGb3IgKGVsKSB7XG4gIHZhciBleHA7XG4gIGlmICgoZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZm9yJykpKSB7XG4gICAgdmFyIGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XG4gICAgaWYgKCFpbk1hdGNoKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcbiAgICAgICAgKFwiSW52YWxpZCB2LWZvciBleHByZXNzaW9uOiBcIiArIGV4cClcbiAgICAgICk7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZWwuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XG4gICAgdmFyIGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCk7XG4gICAgdmFyIGl0ZXJhdG9yTWF0Y2ggPSBhbGlhcy5tYXRjaChmb3JJdGVyYXRvclJFKTtcbiAgICBpZiAoaXRlcmF0b3JNYXRjaCkge1xuICAgICAgZWwuYWxpYXMgPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcbiAgICAgIGVsLml0ZXJhdG9yMSA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgICAgaWYgKGl0ZXJhdG9yTWF0Y2hbM10pIHtcbiAgICAgICAgZWwuaXRlcmF0b3IyID0gaXRlcmF0b3JNYXRjaFszXS50cmltKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmFsaWFzID0gYWxpYXM7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZiAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJyk7XG4gIGlmIChleHApIHtcbiAgICBlbC5pZiA9IGV4cDtcbiAgICBhZGRJZkNvbmRpdGlvbihlbCwge1xuICAgICAgZXhwOiBleHAsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScpICE9IG51bGwpIHtcbiAgICAgIGVsLmVsc2UgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgZWxzZWlmID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicpO1xuICAgIGlmIChlbHNlaWYpIHtcbiAgICAgIGVsLmVsc2VpZiA9IGVsc2VpZjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmQ29uZGl0aW9ucyAoZWwsIHBhcmVudCkge1xuICB2YXIgcHJldiA9IGZpbmRQcmV2RWxlbWVudChwYXJlbnQuY2hpbGRyZW4pO1xuICBpZiAocHJldiAmJiBwcmV2LmlmKSB7XG4gICAgYWRkSWZDb25kaXRpb24ocHJldiwge1xuICAgICAgZXhwOiBlbC5lbHNlaWYsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybiQyKFxuICAgICAgXCJ2LVwiICsgKGVsLmVsc2VpZiA/ICgnZWxzZS1pZj1cIicgKyBlbC5lbHNlaWYgKyAnXCInKSA6ICdlbHNlJykgKyBcIiBcIiArXG4gICAgICBcInVzZWQgb24gZWxlbWVudCA8XCIgKyAoZWwudGFnKSArIFwiPiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdi1pZi5cIlxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFByZXZFbGVtZW50IChjaGlsZHJlbikge1xuICB2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5baV1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW5baV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcInRleHQgXFxcIlwiICsgKGNoaWxkcmVuW2ldLnRleHQudHJpbSgpKSArIFwiXFxcIiBiZXR3ZWVuIHYtaWYgYW5kIHYtZWxzZSgtaWYpIFwiICtcbiAgICAgICAgICBcIndpbGwgYmUgaWdub3JlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4ucG9wKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZElmQ29uZGl0aW9uIChlbCwgY29uZGl0aW9uKSB7XG4gIGlmICghZWwuaWZDb25kaXRpb25zKSB7XG4gICAgZWwuaWZDb25kaXRpb25zID0gW107XG4gIH1cbiAgZWwuaWZDb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc09uY2UgKGVsKSB7XG4gIHZhciBvbmNlJCQxID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Ytb25jZScpO1xuICBpZiAob25jZSQkMSAhPSBudWxsKSB7XG4gICAgZWwub25jZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Nsb3QgKGVsKSB7XG4gIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIGVsLnNsb3ROYW1lID0gZ2V0QmluZGluZ0F0dHIoZWwsICduYW1lJyk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwua2V5KSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiYGtleWAgZG9lcyBub3Qgd29yayBvbiA8c2xvdD4gYmVjYXVzZSBzbG90cyBhcmUgYWJzdHJhY3Qgb3V0bGV0cyBcIiArXG4gICAgICAgIFwiYW5kIGNhbiBwb3NzaWJseSBleHBhbmQgaW50byBtdWx0aXBsZSBlbGVtZW50cy4gXCIgK1xuICAgICAgICBcIlVzZSB0aGUga2V5IG9uIGEgd3JhcHBpbmcgZWxlbWVudCBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdFRhcmdldCA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc2xvdCcpO1xuICAgIGlmIChzbG90VGFyZ2V0KSB7XG4gICAgICBlbC5zbG90VGFyZ2V0ID0gc2xvdFRhcmdldCA9PT0gJ1wiXCInID8gJ1wiZGVmYXVsdFwiJyA6IHNsb3RUYXJnZXQ7XG4gICAgfVxuICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIGVsLnNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzY29wZScpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50IChlbCkge1xuICB2YXIgYmluZGluZztcbiAgaWYgKChiaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdpcycpKSkge1xuICAgIGVsLmNvbXBvbmVudCA9IGJpbmRpbmc7XG4gIH1cbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICdpbmxpbmUtdGVtcGxhdGUnKSAhPSBudWxsKSB7XG4gICAgZWwuaW5saW5lVGVtcGxhdGUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NBdHRycyAoZWwpIHtcbiAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIHZhciBpLCBsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBpc1Byb3A7XG4gIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG5hbWUgPSByYXdOYW1lID0gbGlzdFtpXS5uYW1lO1xuICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgLy8gbWFyayBlbGVtZW50IGFzIGR5bmFtaWNcbiAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgIC8vIG1vZGlmaWVyc1xuICAgICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMobmFtZSk7XG4gICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7IC8vIHYtYmluZFxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmlsdGVycyh2YWx1ZSk7XG4gICAgICAgIGlzUHJvcCA9IGZhbHNlO1xuICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5wcm9wKSB7XG4gICAgICAgICAgICBpc1Byb3AgPSB0cnVlO1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpbm5lckh0bWwnKSB7IG5hbWUgPSAnaW5uZXJIVE1MJzsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLmNhbWVsKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Byb3AgfHwgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpKSB7XG4gICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHsgLy8gdi1vblxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG9uUkUsICcnKTtcbiAgICAgICAgYWRkSGFuZGxlcihlbCwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgICB9IGVsc2UgeyAvLyBub3JtYWwgZGlyZWN0aXZlc1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGRpclJFLCAnJyk7XG4gICAgICAgIC8vIHBhcnNlIGFyZ1xuICAgICAgICB2YXIgYXJnTWF0Y2ggPSBuYW1lLm1hdGNoKGFyZ1JFKTtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ01hdGNoICYmIGFyZ01hdGNoWzFdO1xuICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLShhcmcubGVuZ3RoICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIGFkZERpcmVjdGl2ZShlbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIGFyZywgbW9kaWZpZXJzKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSA9PT0gJ21vZGVsJykge1xuICAgICAgICAgIGNoZWNrRm9yQWxpYXNNb2RlbChlbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxpdGVyYWwgYXR0cmlidXRlXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlVGV4dCh2YWx1ZSwgZGVsaW1pdGVycyk7XG4gICAgICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgbmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBpZD1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmlkPVwidmFsXCI+LidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhZGRBdHRyKGVsLCBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0luRm9yIChlbCkge1xuICB2YXIgcGFyZW50ID0gZWw7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LmZvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyAobmFtZSkge1xuICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgbWF0Y2guZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXRbbS5zbGljZSgxKV0gPSB0cnVlOyB9KTtcbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUF0dHJzTWFwIChhdHRycykge1xuICB2YXIgbWFwID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbWFwW2F0dHJzW2ldLm5hbWVdICYmICFpc0lFKSB7XG4gICAgICB3YXJuJDIoJ2R1cGxpY2F0ZSBhdHRyaWJ1dGU6ICcgKyBhdHRyc1tpXS5uYW1lKTtcbiAgICB9XG4gICAgbWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyAoZWwpIHtcbiAgcmV0dXJuIChcbiAgICBlbC50YWcgPT09ICdzdHlsZScgfHxcbiAgICAoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXG4gICAgICAhZWwuYXR0cnNNYXAudHlwZSB8fFxuICAgICAgZWwuYXR0cnNNYXAudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCdcbiAgICApKVxuICApXG59XG5cbnZhciBpZU5TQnVnID0gL154bWxuczpOU1xcZCsvO1xudmFyIGllTlNQcmVmaXggPSAvXk5TXFxkKzovO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyAoYXR0cnMpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICBpZiAoIWllTlNCdWcudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICBhdHRyLm5hbWUgPSBhdHRyLm5hbWUucmVwbGFjZShpZU5TUHJlZml4LCAnJyk7XG4gICAgICByZXMucHVzaChhdHRyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvckFsaWFzTW9kZWwgKGVsLCB2YWx1ZSkge1xuICB2YXIgX2VsID0gZWw7XG4gIHdoaWxlIChfZWwpIHtcbiAgICBpZiAoX2VsLmZvciAmJiBfZWwuYWxpYXMgPT09IHZhbHVlKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgICBcIllvdSBhcmUgYmluZGluZyB2LW1vZGVsIGRpcmVjdGx5IHRvIGEgdi1mb3IgaXRlcmF0aW9uIGFsaWFzLiBcIiArXG4gICAgICAgIFwiVGhpcyB3aWxsIG5vdCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgdi1mb3Igc291cmNlIGFycmF5IGJlY2F1c2UgXCIgK1xuICAgICAgICBcIndyaXRpbmcgdG8gdGhlIGFsaWFzIGlzIGxpa2UgbW9kaWZ5aW5nIGEgZnVuY3Rpb24gbG9jYWwgdmFyaWFibGUuIFwiICtcbiAgICAgICAgXCJDb25zaWRlciB1c2luZyBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCB1c2Ugdi1tb2RlbCBvbiBhbiBvYmplY3QgcHJvcGVydHkgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgX2VsID0gX2VsLnBhcmVudDtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGlzU3RhdGljS2V5O1xudmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcblxudmFyIGdlblN0YXRpY0tleXNDYWNoZWQgPSBjYWNoZWQoZ2VuU3RhdGljS2V5cyQxKTtcblxuLyoqXG4gKiBHb2FsIG9mIHRoZSBvcHRpbWl6ZXI6IHdhbGsgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBBU1QgdHJlZVxuICogYW5kIGRldGVjdCBzdWItdHJlZXMgdGhhdCBhcmUgcHVyZWx5IHN0YXRpYywgaS5lLiBwYXJ0cyBvZlxuICogdGhlIERPTSB0aGF0IG5ldmVyIG5lZWRzIHRvIGNoYW5nZS5cbiAqXG4gKiBPbmNlIHdlIGRldGVjdCB0aGVzZSBzdWItdHJlZXMsIHdlIGNhbjpcbiAqXG4gKiAxLiBIb2lzdCB0aGVtIGludG8gY29uc3RhbnRzLCBzbyB0aGF0IHdlIG5vIGxvbmdlciBuZWVkIHRvXG4gKiAgICBjcmVhdGUgZnJlc2ggbm9kZXMgZm9yIHRoZW0gb24gZWFjaCByZS1yZW5kZXI7XG4gKiAyLiBDb21wbGV0ZWx5IHNraXAgdGhlbSBpbiB0aGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAqL1xuZnVuY3Rpb24gb3B0aW1pemUgKHJvb3QsIG9wdGlvbnMpIHtcbiAgaWYgKCFyb290KSB7IHJldHVybiB9XG4gIGlzU3RhdGljS2V5ID0gZ2VuU3RhdGljS2V5c0NhY2hlZChvcHRpb25zLnN0YXRpY0tleXMgfHwgJycpO1xuICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIC8vIGZpcnN0IHBhc3M6IG1hcmsgYWxsIG5vbi1zdGF0aWMgbm9kZXMuXG4gIG1hcmtTdGF0aWMkMShyb290KTtcbiAgLy8gc2Vjb25kIHBhc3M6IG1hcmsgc3RhdGljIHJvb3RzLlxuICBtYXJrU3RhdGljUm9vdHMocm9vdCwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzJDEgKGtleXMpIHtcbiAgcmV0dXJuIG1ha2VNYXAoXG4gICAgJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMnICtcbiAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcbiAgKVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljJDEgKG5vZGUpIHtcbiAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYyhub2RlKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIC8vIGRvIG5vdCBtYWtlIGNvbXBvbmVudCBzbG90IGNvbnRlbnQgc3RhdGljLiB0aGlzIGF2b2lkc1xuICAgIC8vIDEuIGNvbXBvbmVudHMgbm90IGFibGUgdG8gbXV0YXRlIHNsb3Qgbm9kZXNcbiAgICAvLyAyLiBzdGF0aWMgc2xvdCBjb250ZW50IGZhaWxzIGZvciBob3QtcmVsb2FkaW5nXG4gICAgaWYgKFxuICAgICAgIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiZcbiAgICAgIG5vZGUudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGxcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgbWFya1N0YXRpYyQxKGNoaWxkKTtcbiAgICAgIGlmICghY2hpbGQuc3RhdGljKSB7XG4gICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyAobm9kZSwgaXNJbkZvcikge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgaWYgKG5vZGUuc3RhdGljIHx8IG5vZGUub25jZSkge1xuICAgICAgbm9kZS5zdGF0aWNJbkZvciA9IGlzSW5Gb3I7XG4gICAgfVxuICAgIC8vIEZvciBhIG5vZGUgdG8gcXVhbGlmeSBhcyBhIHN0YXRpYyByb290LCBpdCBzaG91bGQgaGF2ZSBjaGlsZHJlbiB0aGF0XG4gICAgLy8gYXJlIG5vdCBqdXN0IHN0YXRpYyB0ZXh0LiBPdGhlcndpc2UgdGhlIGNvc3Qgb2YgaG9pc3Rpbmcgb3V0IHdpbGxcbiAgICAvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXG4gICAgaWYgKG5vZGUuc3RhdGljICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmICEoXG4gICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAzXG4gICAgKSkge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuY2hpbGRyZW5baV0sIGlzSW5Gb3IgfHwgISFub2RlLmZvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgd2Fsa1Rocm91Z2hDb25kaXRpb25zQmxvY2tzKG5vZGUuaWZDb25kaXRpb25zLCBpc0luRm9yKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fsa1Rocm91Z2hDb25kaXRpb25zQmxvY2tzIChjb25kaXRpb25CbG9ja3MsIGlzSW5Gb3IpIHtcbiAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IGNvbmRpdGlvbkJsb2Nrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIG1hcmtTdGF0aWNSb290cyhjb25kaXRpb25CbG9ja3NbaV0uYmxvY2ssIGlzSW5Gb3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDIpIHsgLy8gZXhwcmVzc2lvblxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IDMpIHsgLy8gdGV4dFxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuICEhKG5vZGUucHJlIHx8IChcbiAgICAhbm9kZS5oYXNCaW5kaW5ncyAmJiAvLyBubyBkeW5hbWljIGJpbmRpbmdzXG4gICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxuICAgICFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXG4gICAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBjb21wb25lbnRcbiAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcbiAgICBPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSlcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IgKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUucGFyZW50KSB7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIGlmIChub2RlLnRhZyAhPT0gJ3RlbXBsYXRlJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChub2RlLmZvcikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG52YXIgZm5FeHBSRSA9IC9eXFxzKihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5mdW5jdGlvblxccypcXCgvO1xudmFyIHNpbXBsZVBhdGhSRSA9IC9eXFxzKltBLVphLXpfJF1bXFx3JF0qKD86XFwuW0EtWmEtel8kXVtcXHckXSp8XFxbJy4qPyddfFxcW1wiLio/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqXFxzKiQvO1xuXG4vLyBrZXlDb2RlIGFsaWFzZXNcbnZhciBrZXlDb2RlcyA9IHtcbiAgZXNjOiAyNyxcbiAgdGFiOiA5LFxuICBlbnRlcjogMTMsXG4gIHNwYWNlOiAzMixcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MCxcbiAgJ2RlbGV0ZSc6IFs4LCA0Nl1cbn07XG5cbi8vICM0ODY4OiBtb2RpZmllcnMgdGhhdCBwcmV2ZW50IHRoZSBleGVjdXRpb24gb2YgdGhlIGxpc3RlbmVyXG4vLyBuZWVkIHRvIGV4cGxpY2l0bHkgcmV0dXJuIG51bGwgc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmVtb3ZlXG4vLyB0aGUgbGlzdGVuZXIgZm9yIC5vbmNlXG52YXIgZ2VuR3VhcmQgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7IHJldHVybiAoXCJpZihcIiArIGNvbmRpdGlvbiArIFwiKXJldHVybiBudWxsO1wiKTsgfTtcblxudmFyIG1vZGlmaWVyQ29kZSA9IHtcbiAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxuICBwcmV2ZW50OiAnJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyxcbiAgc2VsZjogZ2VuR3VhcmQoXCIkZXZlbnQudGFyZ2V0ICE9PSAkZXZlbnQuY3VycmVudFRhcmdldFwiKSxcbiAgY3RybDogZ2VuR3VhcmQoXCIhJGV2ZW50LmN0cmxLZXlcIiksXG4gIHNoaWZ0OiBnZW5HdWFyZChcIiEkZXZlbnQuc2hpZnRLZXlcIiksXG4gIGFsdDogZ2VuR3VhcmQoXCIhJGV2ZW50LmFsdEtleVwiKSxcbiAgbWV0YTogZ2VuR3VhcmQoXCIhJGV2ZW50Lm1ldGFLZXlcIiksXG4gIGxlZnQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDBcIiksXG4gIG1pZGRsZTogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMVwiKSxcbiAgcmlnaHQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJcIilcbn07XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXJzIChldmVudHMsIG5hdGl2ZSkge1xuICB2YXIgcmVzID0gbmF0aXZlID8gJ25hdGl2ZU9uOnsnIDogJ29uOnsnO1xuICBmb3IgKHZhciBuYW1lIGluIGV2ZW50cykge1xuICAgIHJlcyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyAoZ2VuSGFuZGxlcihuYW1lLCBldmVudHNbbmFtZV0pKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ30nXG59XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXIgKFxuICBuYW1lLFxuICBoYW5kbGVyXG4pIHtcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgcmV0dXJuICdmdW5jdGlvbigpe30nXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgIHJldHVybiAoXCJbXCIgKyAoaGFuZGxlci5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGdlbkhhbmRsZXIobmFtZSwgaGFuZGxlcik7IH0pLmpvaW4oJywnKSkgKyBcIl1cIilcbiAgfVxuXG4gIHZhciBpc01ldGhvZFBhdGggPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgdmFyIGlzRnVuY3Rpb25FeHByZXNzaW9uID0gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuXG4gIGlmICghaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICByZXR1cm4gaXNNZXRob2RQYXRoIHx8IGlzRnVuY3Rpb25FeHByZXNzaW9uXG4gICAgICA/IGhhbmRsZXIudmFsdWVcbiAgICAgIDogKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIChoYW5kbGVyLnZhbHVlKSArIFwifVwiKSAvLyBpbmxpbmUgc3RhdGVtZW50XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvZGUgPSAnJztcbiAgICB2YXIgZ2VuTW9kaWZpZXJDb2RlID0gJyc7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICAgIGlmIChtb2RpZmllckNvZGVba2V5XSkge1xuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gbW9kaWZpZXJDb2RlW2tleV07XG4gICAgICAgIC8vIGxlZnQvcmlnaHRcbiAgICAgICAgaWYgKGtleUNvZGVzW2tleV0pIHtcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgY29kZSArPSBnZW5LZXlGaWx0ZXIoa2V5cyk7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBtb2RpZmllcnMgbGlrZSBwcmV2ZW50IGFuZCBzdG9wIGdldCBleGVjdXRlZCBhZnRlciBrZXkgZmlsdGVyaW5nXG4gICAgaWYgKGdlbk1vZGlmaWVyQ29kZSkge1xuICAgICAgY29kZSArPSBnZW5Nb2RpZmllckNvZGU7XG4gICAgfVxuICAgIHZhciBoYW5kbGVyQ29kZSA9IGlzTWV0aG9kUGF0aFxuICAgICAgPyBoYW5kbGVyLnZhbHVlICsgJygkZXZlbnQpJ1xuICAgICAgOiBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgICA/IChcIihcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKSgkZXZlbnQpXCIpXG4gICAgICAgIDogaGFuZGxlci52YWx1ZTtcbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIGNvZGUgKyBoYW5kbGVyQ29kZSArIFwifVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xuICByZXR1cm4gKFwiaWYoISgnYnV0dG9uJyBpbiAkZXZlbnQpJiZcIiArIChrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpKSArIFwiKXJldHVybiBudWxsO1wiKVxufVxuXG5mdW5jdGlvbiBnZW5GaWx0ZXJDb2RlIChrZXkpIHtcbiAgdmFyIGtleVZhbCA9IHBhcnNlSW50KGtleSwgMTApO1xuICBpZiAoa2V5VmFsKSB7XG4gICAgcmV0dXJuIChcIiRldmVudC5rZXlDb2RlIT09XCIgKyBrZXlWYWwpXG4gIH1cbiAgdmFyIGFsaWFzID0ga2V5Q29kZXNba2V5XTtcbiAgcmV0dXJuIChcIl9rKCRldmVudC5rZXlDb2RlLFwiICsgKEpTT04uc3RyaW5naWZ5KGtleSkpICsgKGFsaWFzID8gJywnICsgSlNPTi5zdHJpbmdpZnkoYWxpYXMpIDogJycpICsgXCIpXCIpXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kJDEgKGVsLCBkaXIpIHtcbiAgZWwud3JhcERhdGEgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiAoXCJfYihcIiArIGNvZGUgKyBcIiwnXCIgKyAoZWwudGFnKSArIFwiJyxcIiArIChkaXIudmFsdWUpICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5wcm9wID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGJhc2VEaXJlY3RpdmVzID0ge1xuICBiaW5kOiBiaW5kJDEsXG4gIGNsb2FrOiBub29wXG59O1xuXG4vKiAgKi9cblxuLy8gY29uZmlndXJhYmxlIHN0YXRlXG52YXIgd2FybiQzO1xudmFyIHRyYW5zZm9ybXMkMTtcbnZhciBkYXRhR2VuRm5zO1xudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyQxO1xudmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyQxO1xudmFyIHN0YXRpY1JlbmRlckZucztcbnZhciBvbmNlQ291bnQ7XG52YXIgY3VycmVudE9wdGlvbnM7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlIChcbiAgYXN0LFxuICBvcHRpb25zXG4pIHtcbiAgLy8gc2F2ZSBwcmV2aW91cyBzdGF0aWNSZW5kZXJGbnMgc28gZ2VuZXJhdGUgY2FsbHMgY2FuIGJlIG5lc3RlZFxuICB2YXIgcHJldlN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcbiAgdmFyIGN1cnJlbnRTdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnMgPSBbXTtcbiAgdmFyIHByZXZPbmNlQ291bnQgPSBvbmNlQ291bnQ7XG4gIG9uY2VDb3VudCA9IDA7XG4gIGN1cnJlbnRPcHRpb25zID0gb3B0aW9ucztcbiAgd2FybiQzID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB0cmFuc2Zvcm1zJDEgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybUNvZGUnKTtcbiAgZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICBwbGF0Zm9ybURpcmVjdGl2ZXMkMSA9IG9wdGlvbnMuZGlyZWN0aXZlcyB8fCB7fTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnJDEgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIHZhciBjb2RlID0gYXN0ID8gZ2VuRWxlbWVudChhc3QpIDogJ19jKFwiZGl2XCIpJztcbiAgc3RhdGljUmVuZGVyRm5zID0gcHJldlN0YXRpY1JlbmRlckZucztcbiAgb25jZUNvdW50ID0gcHJldk9uY2VDb3VudDtcbiAgcmV0dXJuIHtcbiAgICByZW5kZXI6IChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgY29kZSArIFwifVwiKSxcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGN1cnJlbnRTdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5FbGVtZW50IChlbCkge1xuICBpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbClcbiAgfSBlbHNlIGlmIChlbC5vbmNlICYmICFlbC5vbmNlUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbk9uY2UoZWwpXG4gIH0gZWxzZSBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsKVxuICB9IGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbClcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RUYXJnZXQpIHtcbiAgICByZXR1cm4gZ2VuQ2hpbGRyZW4oZWwpIHx8ICd2b2lkIDAnXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICByZXR1cm4gZ2VuU2xvdChlbClcbiAgfSBlbHNlIHtcbiAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgIHZhciBjb2RlO1xuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkYXRhID0gZWwucGxhaW4gPyB1bmRlZmluZWQgOiBnZW5EYXRhKGVsKTtcblxuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHRydWUpO1xuICAgICAgY29kZSA9IFwiX2MoJ1wiICsgKGVsLnRhZykgKyBcIidcIiArIChkYXRhID8gKFwiLFwiICsgZGF0YSkgOiAnJykgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIjtcbiAgICB9XG4gICAgLy8gbW9kdWxlIHRyYW5zZm9ybXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMkMS5sZW5ndGg7IGkrKykge1xuICAgICAgY29kZSA9IHRyYW5zZm9ybXMkMVtpXShlbCwgY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH1cbn1cblxuLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcbmZ1bmN0aW9uIGdlblN0YXRpYyAoZWwpIHtcbiAgZWwuc3RhdGljUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgc3RhdGljUmVuZGVyRm5zLnB1c2goKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCkpICsgXCJ9XCIpKTtcbiAgcmV0dXJuIChcIl9tKFwiICsgKHN0YXRpY1JlbmRlckZucy5sZW5ndGggLSAxKSArIChlbC5zdGF0aWNJbkZvciA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbn1cblxuLy8gdi1vbmNlXG5mdW5jdGlvbiBnZW5PbmNlIChlbCkge1xuICBlbC5vbmNlUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbClcbiAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgIHZhciBrZXkgPSAnJztcbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yKSB7XG4gICAgICAgIGtleSA9IHBhcmVudC5rZXk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICBpZiAoIWtleSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDMoXG4gICAgICAgIFwidi1vbmNlIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHYtZm9yIHRoYXQgaXMga2V5ZWQuIFwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwpXG4gICAgfVxuICAgIHJldHVybiAoXCJfbyhcIiArIChnZW5FbGVtZW50KGVsKSkgKyBcIixcIiArIChvbmNlQ291bnQrKykgKyAoa2V5ID8gKFwiLFwiICsga2V5KSA6IFwiXCIpICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbClcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JZiAoZWwpIHtcbiAgZWwuaWZQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIGdlbklmQ29uZGl0aW9ucyhlbC5pZkNvbmRpdGlvbnMuc2xpY2UoKSlcbn1cblxuZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChjb25kaXRpb25zKSB7XG4gIGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJ19lKCknXG4gIH1cblxuICB2YXIgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xuICBpZiAoY29uZGl0aW9uLmV4cCkge1xuICAgIHJldHVybiAoXCIoXCIgKyAoY29uZGl0aW9uLmV4cCkgKyBcIik/XCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSArIFwiOlwiICsgKGdlbklmQ29uZGl0aW9ucyhjb25kaXRpb25zKSkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIlwiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkpXG4gIH1cblxuICAvLyB2LWlmIHdpdGggdi1vbmNlIHNob3VsZCBnZW5lcmF0ZSBjb2RlIGxpa2UgKGEpP19tKDApOl9tKDEpXG4gIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAgKGVsKSB7XG4gICAgcmV0dXJuIGVsLm9uY2UgPyBnZW5PbmNlKGVsKSA6IGdlbkVsZW1lbnQoZWwpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRm9yIChlbCkge1xuICB2YXIgZXhwID0gZWwuZm9yO1xuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgdmFyIGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IChcIixcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG5cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBtYXliZUNvbXBvbmVudChlbCkgJiYgZWwudGFnICE9PSAnc2xvdCcgJiYgZWwudGFnICE9PSAndGVtcGxhdGUnICYmICFlbC5rZXlcbiAgKSB7XG4gICAgd2FybiQzKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtZm9yPVxcXCJcIiArIGFsaWFzICsgXCIgaW4gXCIgKyBleHAgKyBcIlxcXCI+OiBjb21wb25lbnQgbGlzdHMgcmVuZGVyZWQgd2l0aCBcIiArXG4gICAgICBcInYtZm9yIHNob3VsZCBoYXZlIGV4cGxpY2l0IGtleXMuIFwiICtcbiAgICAgIFwiU2VlIGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2xpc3QuaHRtbCNrZXkgZm9yIG1vcmUgaW5mby5cIixcbiAgICAgIHRydWUgLyogdGlwICovXG4gICAgKTtcbiAgfVxuXG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gXCJfbCgoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArIChnZW5FbGVtZW50KGVsKSkgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAneyc7XG5cbiAgLy8gZGlyZWN0aXZlcyBmaXJzdC5cbiAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cbiAgdmFyIGRpcnMgPSBnZW5EaXJlY3RpdmVzKGVsKTtcbiAgaWYgKGRpcnMpIHsgZGF0YSArPSBkaXJzICsgJywnOyB9XG5cbiAgLy8ga2V5XG4gIGlmIChlbC5rZXkpIHtcbiAgICBkYXRhICs9IFwia2V5OlwiICsgKGVsLmtleSkgKyBcIixcIjtcbiAgfVxuICAvLyByZWZcbiAgaWYgKGVsLnJlZikge1xuICAgIGRhdGEgKz0gXCJyZWY6XCIgKyAoZWwucmVmKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5yZWZJbkZvcikge1xuICAgIGRhdGEgKz0gXCJyZWZJbkZvcjp0cnVlLFwiO1xuICB9XG4gIC8vIHByZVxuICBpZiAoZWwucHJlKSB7XG4gICAgZGF0YSArPSBcInByZTp0cnVlLFwiO1xuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCB0YWcgbmFtZSBmb3IgY29tcG9uZW50cyB1c2luZyBcImlzXCIgYXR0cmlidXRlXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBkYXRhICs9IFwidGFnOlxcXCJcIiArIChlbC50YWcpICsgXCJcXFwiLFwiO1xuICB9XG4gIC8vIG1vZHVsZSBkYXRhIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xuICAgIGRhdGEgKz0gZGF0YUdlbkZuc1tpXShlbCk7XG4gIH1cbiAgLy8gYXR0cmlidXRlc1xuICBpZiAoZWwuYXR0cnMpIHtcbiAgICBkYXRhICs9IFwiYXR0cnM6e1wiICsgKGdlblByb3BzKGVsLmF0dHJzKSkgKyBcIn0sXCI7XG4gIH1cbiAgLy8gRE9NIHByb3BzXG4gIGlmIChlbC5wcm9wcykge1xuICAgIGRhdGEgKz0gXCJkb21Qcm9wczp7XCIgKyAoZ2VuUHJvcHMoZWwucHJvcHMpKSArIFwifSxcIjtcbiAgfVxuICAvLyBldmVudCBoYW5kbGVyc1xuICBpZiAoZWwuZXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwuZXZlbnRzKSkgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwubmF0aXZlRXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlKSkgKyBcIixcIjtcbiAgfVxuICAvLyBzbG90IHRhcmdldFxuICBpZiAoZWwuc2xvdFRhcmdldCkge1xuICAgIGRhdGEgKz0gXCJzbG90OlwiICsgKGVsLnNsb3RUYXJnZXQpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgIGRhdGEgKz0gKGdlblNjb3BlZFNsb3RzKGVsLnNjb3BlZFNsb3RzKSkgKyBcIixcIjtcbiAgfVxuICAvLyBjb21wb25lbnQgdi1tb2RlbFxuICBpZiAoZWwubW9kZWwpIHtcbiAgICBkYXRhICs9IFwibW9kZWw6e3ZhbHVlOlwiICsgKGVsLm1vZGVsLnZhbHVlKSArIFwiLGNhbGxiYWNrOlwiICsgKGVsLm1vZGVsLmNhbGxiYWNrKSArIFwiLGV4cHJlc3Npb246XCIgKyAoZWwubW9kZWwuZXhwcmVzc2lvbikgKyBcIn0sXCI7XG4gIH1cbiAgLy8gaW5saW5lLXRlbXBsYXRlXG4gIGlmIChlbC5pbmxpbmVUZW1wbGF0ZSkge1xuICAgIHZhciBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsKTtcbiAgICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgIGRhdGEgKz0gaW5saW5lVGVtcGxhdGUgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgZGF0YSA9IGRhdGEucmVwbGFjZSgvLCQvLCAnJykgKyAnfSc7XG4gIC8vIHYtYmluZCBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBEYXRhKSB7XG4gICAgZGF0YSA9IGVsLndyYXBEYXRhKGRhdGEpO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMgKGVsKSB7XG4gIHZhciBkaXJzID0gZWwuZGlyZWN0aXZlcztcbiAgaWYgKCFkaXJzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSAnZGlyZWN0aXZlczpbJztcbiAgdmFyIGhhc1J1bnRpbWUgPSBmYWxzZTtcbiAgdmFyIGksIGwsIGRpciwgbmVlZFJ1bnRpbWU7XG4gIGZvciAoaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgbmVlZFJ1bnRpbWUgPSB0cnVlO1xuICAgIHZhciBnZW4gPSBwbGF0Zm9ybURpcmVjdGl2ZXMkMVtkaXIubmFtZV0gfHwgYmFzZURpcmVjdGl2ZXNbZGlyLm5hbWVdO1xuICAgIGlmIChnZW4pIHtcbiAgICAgIC8vIGNvbXBpbGUtdGltZSBkaXJlY3RpdmUgdGhhdCBtYW5pcHVsYXRlcyBBU1QuXG4gICAgICAvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXG4gICAgICBuZWVkUnVudGltZSA9ICEhZ2VuKGVsLCBkaXIsIHdhcm4kMyk7XG4gICAgfVxuICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgaGFzUnVudGltZSA9IHRydWU7XG4gICAgICByZXMgKz0gXCJ7bmFtZTpcXFwiXCIgKyAoZGlyLm5hbWUpICsgXCJcXFwiLHJhd05hbWU6XFxcIlwiICsgKGRpci5yYXdOYW1lKSArIFwiXFxcIlwiICsgKGRpci52YWx1ZSA/IChcIix2YWx1ZTooXCIgKyAoZGlyLnZhbHVlKSArIFwiKSxleHByZXNzaW9uOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkpKSA6ICcnKSArIChkaXIuYXJnID8gKFwiLGFyZzpcXFwiXCIgKyAoZGlyLmFyZykgKyBcIlxcXCJcIikgOiAnJykgKyAoZGlyLm1vZGlmaWVycyA/IChcIixtb2RpZmllcnM6XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLm1vZGlmaWVycykpKSA6ICcnKSArIFwifSxcIjtcbiAgICB9XG4gIH1cbiAgaWYgKGhhc1J1bnRpbWUpIHtcbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICddJ1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklubGluZVRlbXBsYXRlIChlbCkge1xuICB2YXIgYXN0ID0gZWwuY2hpbGRyZW5bMF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIChcbiAgICBlbC5jaGlsZHJlbi5sZW5ndGggPiAxIHx8IGFzdC50eXBlICE9PSAxXG4gICkpIHtcbiAgICB3YXJuJDMoJ0lubGluZS10ZW1wbGF0ZSBjb21wb25lbnRzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50LicpO1xuICB9XG4gIGlmIChhc3QudHlwZSA9PT0gMSkge1xuICAgIHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIGN1cnJlbnRPcHRpb25zKTtcbiAgICByZXR1cm4gKFwiaW5saW5lVGVtcGxhdGU6e3JlbmRlcjpmdW5jdGlvbigpe1wiICsgKGlubGluZVJlbmRlckZucy5yZW5kZXIpICsgXCJ9LHN0YXRpY1JlbmRlckZuczpbXCIgKyAoaW5saW5lUmVuZGVyRm5zLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcImZ1bmN0aW9uKCl7XCIgKyBjb2RlICsgXCJ9XCIpOyB9KS5qb2luKCcsJykpICsgXCJdfVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3RzIChzbG90cykge1xuICByZXR1cm4gKFwic2NvcGVkU2xvdHM6X3UoW1wiICsgKE9iamVjdC5rZXlzKHNsb3RzKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZ2VuU2NvcGVkU2xvdChrZXksIHNsb3RzW2tleV0pOyB9KS5qb2luKCcsJykpICsgXCJdKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90IChrZXksIGVsKSB7XG4gIHJldHVybiBcIltcIiArIGtleSArIFwiLGZ1bmN0aW9uKFwiICsgKFN0cmluZyhlbC5hdHRyc01hcC5zY29wZSkpICsgXCIpe1wiICtcbiAgICBcInJldHVybiBcIiArIChlbC50YWcgPT09ICd0ZW1wbGF0ZSdcbiAgICAgID8gZ2VuQ2hpbGRyZW4oZWwpIHx8ICd2b2lkIDAnXG4gICAgICA6IGdlbkVsZW1lbnQoZWwpKSArIFwifV1cIlxufVxuXG5mdW5jdGlvbiBnZW5DaGlsZHJlbiAoZWwsIGNoZWNrU2tpcCkge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHZhciBlbCQxID0gY2hpbGRyZW5bMF07XG4gICAgLy8gb3B0aW1pemUgc2luZ2xlIHYtZm9yXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBlbCQxLmZvciAmJlxuICAgICAgICBlbCQxLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICAgICBlbCQxLnRhZyAhPT0gJ3Nsb3QnKSB7XG4gICAgICByZXR1cm4gZ2VuRWxlbWVudChlbCQxKVxuICAgIH1cbiAgICB2YXIgbm9ybWFsaXphdGlvblR5cGUgPSBjaGVja1NraXAgPyBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbikgOiAwO1xuICAgIHJldHVybiAoXCJbXCIgKyAoY2hpbGRyZW4ubWFwKGdlbk5vZGUpLmpvaW4oJywnKSkgKyBcIl1cIiArIChub3JtYWxpemF0aW9uVHlwZSA/IChcIixcIiArIG5vcm1hbGl6YXRpb25UeXBlKSA6ICcnKSlcbiAgfVxufVxuXG4vLyBkZXRlcm1pbmUgdGhlIG5vcm1hbGl6YXRpb24gbmVlZGVkIGZvciB0aGUgY2hpbGRyZW4gYXJyYXkuXG4vLyAwOiBubyBub3JtYWxpemF0aW9uIG5lZWRlZFxuLy8gMTogc2ltcGxlIG5vcm1hbGl6YXRpb24gbmVlZGVkIChwb3NzaWJsZSAxLWxldmVsIGRlZXAgbmVzdGVkIGFycmF5KVxuLy8gMjogZnVsbCBub3JtYWxpemF0aW9uIG5lZWRlZFxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvblR5cGUgKGNoaWxkcmVuKSB7XG4gIHZhciByZXMgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGVsLnR5cGUgIT09IDEpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5lZWRzTm9ybWFsaXphdGlvbihjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAyO1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKG1heWJlQ29tcG9uZW50KGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBtYXliZUNvbXBvbmVudChjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIG5lZWRzTm9ybWFsaXphdGlvbiAoZWwpIHtcbiAgcmV0dXJuIGVsLmZvciAhPT0gdW5kZWZpbmVkIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyB8fCBlbC50YWcgPT09ICdzbG90J1xufVxuXG5mdW5jdGlvbiBtYXliZUNvbXBvbmVudCAoZWwpIHtcbiAgcmV0dXJuICFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWckMShlbC50YWcpXG59XG5cbmZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIHJldHVybiBnZW5FbGVtZW50KG5vZGUpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblRleHQobm9kZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5UZXh0ICh0ZXh0KSB7XG4gIHJldHVybiAoXCJfdihcIiArICh0ZXh0LnR5cGUgPT09IDJcbiAgICA/IHRleHQuZXhwcmVzc2lvbiAvLyBubyBuZWVkIGZvciAoKSBiZWNhdXNlIGFscmVhZHkgd3JhcHBlZCBpbiBfcygpXG4gICAgOiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMoSlNPTi5zdHJpbmdpZnkodGV4dC50ZXh0KSkpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblNsb3QgKGVsKSB7XG4gIHZhciBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XG4gIHZhciBjaGlsZHJlbiA9IGdlbkNoaWxkcmVuKGVsKTtcbiAgdmFyIHJlcyA9IFwiX3QoXCIgKyBzbG90TmFtZSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKTtcbiAgdmFyIGF0dHJzID0gZWwuYXR0cnMgJiYgKFwie1wiICsgKGVsLmF0dHJzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gKChjYW1lbGl6ZShhLm5hbWUpKSArIFwiOlwiICsgKGEudmFsdWUpKTsgfSkuam9pbignLCcpKSArIFwifVwiKTtcbiAgdmFyIGJpbmQkJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kJ107XG4gIGlmICgoYXR0cnMgfHwgYmluZCQkMSkgJiYgIWNoaWxkcmVuKSB7XG4gICAgcmVzICs9IFwiLG51bGxcIjtcbiAgfVxuICBpZiAoYXR0cnMpIHtcbiAgICByZXMgKz0gXCIsXCIgKyBhdHRycztcbiAgfVxuICBpZiAoYmluZCQkMSkge1xuICAgIHJlcyArPSAoYXR0cnMgPyAnJyA6ICcsbnVsbCcpICsgXCIsXCIgKyBiaW5kJCQxO1xuICB9XG4gIHJldHVybiByZXMgKyAnKSdcbn1cblxuLy8gY29tcG9uZW50TmFtZSBpcyBlbC5jb21wb25lbnQsIHRha2UgaXQgYXMgYXJndW1lbnQgdG8gc2h1biBmbG93J3MgcGVzc2ltaXN0aWMgcmVmaW5lbWVudFxuZnVuY3Rpb24gZ2VuQ29tcG9uZW50IChjb21wb25lbnROYW1lLCBlbCkge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgdHJ1ZSk7XG4gIHJldHVybiAoXCJfYyhcIiArIGNvbXBvbmVudE5hbWUgKyBcIixcIiArIChnZW5EYXRhKGVsKSkgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuUHJvcHMgKHByb3BzKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgcmVzICs9IFwiXFxcIlwiICsgKHByb3AubmFtZSkgKyBcIlxcXCI6XCIgKyAodHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKHByb3AudmFsdWUpKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiByZXMuc2xpY2UoMCwgLTEpXG59XG5cbi8vICMzODk1LCAjNDI2OFxuZnVuY3Rpb24gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzICh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0XG4gICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgJ1xcXFx1MjAyOCcpXG4gICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcXFx1MjAyOScpXG59XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBrZXl3b3JkcyBzaG91bGQgbm90IGFwcGVhciBpbnNpZGUgZXhwcmVzc2lvbnMsIGJ1dCBvcGVyYXRvcnMgbGlrZVxuLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxudmFyIHByb2hpYml0ZWRLZXl3b3JkUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkbyxpZixmb3IsbGV0LG5ldyx0cnksdmFyLGNhc2UsZWxzZSx3aXRoLGF3YWl0LGJyZWFrLGNhdGNoLGNsYXNzLGNvbnN0LCcgK1xuICAnc3VwZXIsdGhyb3csd2hpbGUseWllbGQsZGVsZXRlLGV4cG9ydCxpbXBvcnQscmV0dXJuLHN3aXRjaCxkZWZhdWx0LCcgK1xuICAnZXh0ZW5kcyxmaW5hbGx5LGNvbnRpbnVlLGRlYnVnZ2VyLGZ1bmN0aW9uLGFyZ3VtZW50cydcbikuc3BsaXQoJywnKS5qb2luKCdcXFxcYnxcXFxcYicpICsgJ1xcXFxiJyk7XG5cbi8vIHRoZXNlIHVuYXJ5IG9wZXJhdG9ycyBzaG91bGQgbm90IGJlIHVzZWQgYXMgcHJvcGVydHkvbWV0aG9kIG5hbWVzXG52YXIgdW5hcnlPcGVyYXRvcnNSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RlbGV0ZSx0eXBlb2Ysdm9pZCdcbikuc3BsaXQoJywnKS5qb2luKCdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpfFxcXFxiJykgKyAnXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKScpO1xuXG4vLyBjaGVjayB2YWxpZCBpZGVudGlmaWVyIGZvciB2LWZvclxudmFyIGlkZW50UkUgPSAvW0EtWmEtel8kXVtcXHckXSovO1xuXG4vLyBzdHJpcCBzdHJpbmdzIGluIGV4cHJlc3Npb25zXG52YXIgc3RyaXBTdHJpbmdSRSA9IC8nKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYC9nO1xuXG4vLyBkZXRlY3QgcHJvYmxlbWF0aWMgZXhwcmVzc2lvbnMgaW4gYSB0ZW1wbGF0ZVxuZnVuY3Rpb24gZGV0ZWN0RXJyb3JzIChhc3QpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZiAoYXN0KSB7XG4gICAgY2hlY2tOb2RlKGFzdCwgZXJyb3JzKTtcbiAgfVxuICByZXR1cm4gZXJyb3JzXG59XG5cbmZ1bmN0aW9uIGNoZWNrTm9kZSAobm9kZSwgZXJyb3JzKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcbiAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuYXR0cnNNYXBbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChuYW1lID09PSAndi1mb3InKSB7XG4gICAgICAgICAgICBjaGVja0Zvcihub2RlLCAoXCJ2LWZvcj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgY2hlY2tFdmVudCh2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tFeHByZXNzaW9uKHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoZWNrTm9kZShub2RlLmNoaWxkcmVuW2ldLCBlcnJvcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIpIHtcbiAgICBjaGVja0V4cHJlc3Npb24obm9kZS5leHByZXNzaW9uLCBub2RlLnRleHQsIGVycm9ycyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFdmVudCAoZXhwLCB0ZXh0LCBlcnJvcnMpIHtcbiAgdmFyIGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKS5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcbiAgaWYgKGtleXdvcmRNYXRjaCkge1xuICAgIGVycm9ycy5wdXNoKFxuICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IHVuYXJ5IG9wZXJhdG9yIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSlcbiAgICApO1xuICB9XG4gIGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIGVycm9ycyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yIChub2RlLCB0ZXh0LCBlcnJvcnMpIHtcbiAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZm9yIHx8ICcnLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5hbGlhcywgJ3YtZm9yIGFsaWFzJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IxLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjIsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIGVycm9ycyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSWRlbnRpZmllciAoaWRlbnQsIHR5cGUsIHRleHQsIGVycm9ycykge1xuICBpZiAodHlwZW9mIGlkZW50ID09PSAnc3RyaW5nJyAmJiAhaWRlbnRSRS50ZXN0KGlkZW50KSkge1xuICAgIGVycm9ycy5wdXNoKChcImludmFsaWQgXCIgKyB0eXBlICsgXCIgXFxcIlwiICsgaWRlbnQgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFeHByZXNzaW9uIChleHAsIHRleHQsIGVycm9ycykge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbigoXCJyZXR1cm4gXCIgKyBleHApKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciBrZXl3b3JkTWF0Y2ggPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJykubWF0Y2gocHJvaGliaXRlZEtleXdvcmRSRSk7XG4gICAgaWYgKGtleXdvcmRNYXRjaCkge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3JzLnB1c2goKFwiaW52YWxpZCBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkpKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJhc2VDb21waWxlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgYXN0ID0gcGFyc2UodGVtcGxhdGUudHJpbSgpLCBvcHRpb25zKTtcbiAgb3B0aW1pemUoYXN0LCBvcHRpb25zKTtcbiAgdmFyIGNvZGUgPSBnZW5lcmF0ZShhc3QsIG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIGFzdDogYXN0LFxuICAgIHJlbmRlcjogY29kZS5yZW5kZXIsXG4gICAgc3RhdGljUmVuZGVyRm5zOiBjb2RlLnN0YXRpY1JlbmRlckZuc1xuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VGdW5jdGlvbiAoY29kZSwgZXJyb3JzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihjb2RlKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvcnMucHVzaCh7IGVycjogZXJyLCBjb2RlOiBjb2RlIH0pO1xuICAgIHJldHVybiBub29wXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXIgKGJhc2VPcHRpb25zKSB7XG4gIHZhciBmdW5jdGlvbkNvbXBpbGVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZnVuY3Rpb24gY29tcGlsZSAoXG4gICAgdGVtcGxhdGUsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgZmluYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucyk7XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIHZhciB0aXBzID0gW107XG4gICAgZmluYWxPcHRpb25zLndhcm4gPSBmdW5jdGlvbiAobXNnLCB0aXAkJDEpIHtcbiAgICAgICh0aXAkJDEgPyB0aXBzIDogZXJyb3JzKS5wdXNoKG1zZyk7XG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAvLyBtZXJnZSBjdXN0b20gbW9kdWxlc1xuICAgICAgaWYgKG9wdGlvbnMubW9kdWxlcykge1xuICAgICAgICBmaW5hbE9wdGlvbnMubW9kdWxlcyA9IChiYXNlT3B0aW9ucy5tb2R1bGVzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5tb2R1bGVzKTtcbiAgICAgIH1cbiAgICAgIC8vIG1lcmdlIGN1c3RvbSBkaXJlY3RpdmVzXG4gICAgICBpZiAob3B0aW9ucy5kaXJlY3RpdmVzKSB7XG4gICAgICAgIGZpbmFsT3B0aW9ucy5kaXJlY3RpdmVzID0gZXh0ZW5kKFxuICAgICAgICAgIE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMuZGlyZWN0aXZlcyksXG4gICAgICAgICAgb3B0aW9ucy5kaXJlY3RpdmVzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAvLyBjb3B5IG90aGVyIG9wdGlvbnNcbiAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmIChrZXkgIT09ICdtb2R1bGVzJyAmJiBrZXkgIT09ICdkaXJlY3RpdmVzJykge1xuICAgICAgICAgIGZpbmFsT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNvbXBpbGVkID0gYmFzZUNvbXBpbGUodGVtcGxhdGUsIGZpbmFsT3B0aW9ucyk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgZGV0ZWN0RXJyb3JzKGNvbXBpbGVkLmFzdCkpO1xuICAgIH1cbiAgICBjb21waWxlZC5lcnJvcnMgPSBlcnJvcnM7XG4gICAgY29tcGlsZWQudGlwcyA9IHRpcHM7XG4gICAgcmV0dXJuIGNvbXBpbGVkXG4gIH1cblxuICBmdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbnMgKFxuICAgIHRlbXBsYXRlLFxuICAgIG9wdGlvbnMsXG4gICAgdm1cbiAgKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gZGV0ZWN0IHBvc3NpYmxlIENTUCByZXN0cmljdGlvblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gMScpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0aGUgc3RhbmRhbG9uZSBidWlsZCBvZiBWdWUuanMgaW4gYW4gJyArXG4gICAgICAgICAgICAnZW52aXJvbm1lbnQgd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArXG4gICAgICAgICAgICAnVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGNhbm5vdCB3b3JrIGluIHRoaXMgZW52aXJvbm1lbnQuIENvbnNpZGVyICcgK1xuICAgICAgICAgICAgJ3JlbGF4aW5nIHRoZSBwb2xpY3kgdG8gYWxsb3cgdW5zYWZlLWV2YWwgb3IgcHJlLWNvbXBpbGluZyB5b3VyICcgK1xuICAgICAgICAgICAgJ3RlbXBsYXRlcyBpbnRvIHJlbmRlciBmdW5jdGlvbnMuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBjYWNoZVxuICAgIHZhciBrZXkgPSBvcHRpb25zLmRlbGltaXRlcnNcbiAgICAgID8gU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVycykgKyB0ZW1wbGF0ZVxuICAgICAgOiB0ZW1wbGF0ZTtcbiAgICBpZiAoZnVuY3Rpb25Db21waWxlQ2FjaGVba2V5XSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uQ29tcGlsZUNhY2hlW2tleV1cbiAgICB9XG5cbiAgICAvLyBjb21waWxlXG4gICAgdmFyIGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIHRlbXBsYXRlICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgY29tcGlsZWQuZXJyb3JzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gKFwiLSBcIiArIGUpOyB9KS5qb2luKCdcXG4nKSArICdcXG4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoY29tcGlsZWQudGlwcyAmJiBjb21waWxlZC50aXBzLmxlbmd0aCkge1xuICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKG1zZykgeyByZXR1cm4gdGlwKG1zZywgdm0pOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0dXJuIGNvZGUgaW50byBmdW5jdGlvbnNcbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGZuR2VuRXJyb3JzID0gW107XG4gICAgcmVzLnJlbmRlciA9IG1ha2VGdW5jdGlvbihjb21waWxlZC5yZW5kZXIsIGZuR2VuRXJyb3JzKTtcbiAgICB2YXIgbCA9IGNvbXBpbGVkLnN0YXRpY1JlbmRlckZucy5sZW5ndGg7XG4gICAgcmVzLnN0YXRpY1JlbmRlckZucyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgcmVzLnN0YXRpY1JlbmRlckZuc1tpXSA9IG1ha2VGdW5jdGlvbihjb21waWxlZC5zdGF0aWNSZW5kZXJGbnNbaV0sIGZuR2VuRXJyb3JzKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmdW5jdGlvbiBnZW5lcmF0aW9uIGVycm9ycy5cbiAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSBpcyBhIGJ1ZyBpbiB0aGUgY29tcGlsZXIgaXRzZWxmLlxuICAgIC8vIG1vc3RseSBmb3IgY29kZWdlbiBkZXZlbG9wbWVudCB1c2VcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCghY29tcGlsZWQuZXJyb3JzIHx8ICFjb21waWxlZC5lcnJvcnMubGVuZ3RoKSAmJiBmbkdlbkVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkZhaWxlZCB0byBnZW5lcmF0ZSByZW5kZXIgZnVuY3Rpb246XFxuXFxuXCIgK1xuICAgICAgICAgIGZuR2VuRXJyb3JzLm1hcChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gcmVmLmVycjtcbiAgICAgICAgICAgIHZhciBjb2RlID0gcmVmLmNvZGU7XG5cbiAgICAgICAgICAgIHJldHVybiAoKGVyci50b1N0cmluZygpKSArIFwiIGluXFxuXFxuXCIgKyBjb2RlICsgXCJcXG5cIik7XG4gICAgICAgIH0pLmpvaW4oJ1xcbicpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChmdW5jdGlvbkNvbXBpbGVDYWNoZVtrZXldID0gcmVzKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb21waWxlOiBjb21waWxlLFxuICAgIGNvbXBpbGVUb0Z1bmN0aW9uczogY29tcGlsZVRvRnVuY3Rpb25zXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB2YXIgc3RhdGljQ2xhc3MgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnY2xhc3MnKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGljQ2xhc3MpIHtcbiAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlVGV4dChzdGF0aWNDbGFzcywgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgd2FybihcbiAgICAgICAgXCJjbGFzcz1cXFwiXCIgKyBzdGF0aWNDbGFzcyArIFwiXFxcIjogXCIgK1xuICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhdGljQ2xhc3MpIHtcbiAgICBlbC5zdGF0aWNDbGFzcyA9IEpTT04uc3RyaW5naWZ5KHN0YXRpY0NsYXNzKTtcbiAgfVxuICB2YXIgY2xhc3NCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdjbGFzcycsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChjbGFzc0JpbmRpbmcpIHtcbiAgICBlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljQ2xhc3MpIHtcbiAgICBkYXRhICs9IFwic3RhdGljQ2xhc3M6XCIgKyAoZWwuc3RhdGljQ2xhc3MpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLmNsYXNzQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJjbGFzczpcIiArIChlbC5jbGFzc0JpbmRpbmcpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIGtsYXNzJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljQ2xhc3MnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSxcbiAgZ2VuRGF0YTogZ2VuRGF0YSQxXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQxIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY1N0eWxlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3N0eWxlJyk7XG4gIGlmIChzdGF0aWNTdHlsZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlVGV4dChzdGF0aWNTdHlsZSwgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJzdHlsZT1cXFwiXCIgKyBzdGF0aWNTdHlsZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgc3R5bGU9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpzdHlsZT1cInZhbFwiPi4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsLnN0YXRpY1N0eWxlID0gSlNPTi5zdHJpbmdpZnkocGFyc2VTdHlsZVRleHQoc3RhdGljU3R5bGUpKTtcbiAgfVxuXG4gIHZhciBzdHlsZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3N0eWxlJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKHN0eWxlQmluZGluZykge1xuICAgIGVsLnN0eWxlQmluZGluZyA9IHN0eWxlQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhJDIgKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNTdHlsZSkge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNTdHlsZTpcIiArIChlbC5zdGF0aWNTdHlsZSkgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuc3R5bGVCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcInN0eWxlOihcIiArIChlbC5zdHlsZUJpbmRpbmcpICsgXCIpLFwiO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBzdHlsZSQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY1N0eWxlJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUkMSxcbiAgZ2VuRGF0YTogZ2VuRGF0YSQyXG59O1xuXG52YXIgbW9kdWxlcyQxID0gW1xuICBrbGFzcyQxLFxuICBzdHlsZSQxXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdGV4dCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGh0bWwgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICdpbm5lckhUTUwnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpKTtcbiAgfVxufVxuXG52YXIgZGlyZWN0aXZlcyQxID0ge1xuICBtb2RlbDogbW9kZWwsXG4gIHRleHQ6IHRleHQsXG4gIGh0bWw6IGh0bWxcbn07XG5cbi8qICAqL1xuXG52YXIgYmFzZU9wdGlvbnMgPSB7XG4gIGV4cGVjdEhUTUw6IHRydWUsXG4gIG1vZHVsZXM6IG1vZHVsZXMkMSxcbiAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyQxLFxuICBpc1ByZVRhZzogaXNQcmVUYWcsXG4gIGlzVW5hcnlUYWc6IGlzVW5hcnlUYWcsXG4gIG11c3RVc2VQcm9wOiBtdXN0VXNlUHJvcCxcbiAgY2FuQmVMZWZ0T3BlblRhZzogY2FuQmVMZWZ0T3BlblRhZyxcbiAgaXNSZXNlcnZlZFRhZzogaXNSZXNlcnZlZFRhZyxcbiAgZ2V0VGFnTmFtZXNwYWNlOiBnZXRUYWdOYW1lc3BhY2UsXG4gIHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMobW9kdWxlcyQxKVxufTtcblxudmFyIHJlZiQxID0gY3JlYXRlQ29tcGlsZXIoYmFzZU9wdGlvbnMpO1xudmFyIGNvbXBpbGVUb0Z1bmN0aW9ucyA9IHJlZiQxLmNvbXBpbGVUb0Z1bmN0aW9ucztcblxuLyogICovXG5cbnZhciBpZFRvVGVtcGxhdGUgPSBjYWNoZWQoZnVuY3Rpb24gKGlkKSB7XG4gIHZhciBlbCA9IHF1ZXJ5KGlkKTtcbiAgcmV0dXJuIGVsICYmIGVsLmlubmVySFRNTFxufSk7XG5cbnZhciBtb3VudCA9IFZ1ZSQzLnByb3RvdHlwZS4kbW91bnQ7XG5WdWUkMy5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBxdWVyeShlbCk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSB8fCBlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJEbyBub3QgbW91bnQgVnVlIHRvIDxodG1sPiBvciA8Ym9keT4gLSBtb3VudCB0byBub3JtYWwgZWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgLy8gcmVzb2x2ZSB0ZW1wbGF0ZS9lbCBhbmQgY29udmVydCB0byByZW5kZXIgZnVuY3Rpb25cbiAgaWYgKCFvcHRpb25zLnJlbmRlcikge1xuICAgIHZhciB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodGVtcGxhdGUuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IGlkVG9UZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAoXCJUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogXCIgKyAob3B0aW9ucy50ZW1wbGF0ZSkpLFxuICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybignaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246JyArIHRlbXBsYXRlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAgIHRlbXBsYXRlID0gZ2V0T3V0ZXJIVE1MKGVsKTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiA9IGNvbXBpbGVUb0Z1bmN0aW9ucyh0ZW1wbGF0ZSwge1xuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lczogc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgICAgIGRlbGltaXRlcnM6IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgfSwgdGhpcyk7XG4gICAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XG4gICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlIGVuZCcpO1xuICAgICAgICBtZWFzdXJlKCgodGhpcy5fbmFtZSkgKyBcIiBjb21waWxlXCIpLCAnY29tcGlsZScsICdjb21waWxlIGVuZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbW91bnQuY2FsbCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLyoqXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVySFRNTCAoZWwpIHtcbiAgaWYgKGVsLm91dGVySFRNTCkge1xuICAgIHJldHVybiBlbC5vdXRlckhUTUxcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUxcbiAgfVxufVxuXG5WdWUkMy5jb21waWxlID0gY29tcGlsZVRvRnVuY3Rpb25zO1xuXG5leHBvcnQgZGVmYXVsdCBWdWUkMztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBwcmljZUN1cnJlbmNpZXMgPSBbe1xuICAgIGlkOiBcImRvbGxhcl91c1wiLFxuICAgIG5hbWU6IFwiVVMgRG9sbGFyXCIsXG4gICAgbGFiZWw6IFwiJFwiLFxuICAgIHZhbDogMVxufSwge1xuICAgIGlkOiBcImV1cm9cIixcbiAgICBuYW1lOiBcIkV1cm9cIixcbiAgICBsYWJlbDogXCLigqxcIixcbiAgICB2YWw6IDAuOTE4NjAzXG59LCB7XG4gICAgaWQ6IFwicG91bmRcIixcbiAgICBuYW1lOiBcIlBvdW5kXCIsXG4gICAgbGFiZWw6IFwiwqNcIixcbiAgICB2YWw6IDAuNzkzNzUyXG59LCB7XG4gICAgaWQ6IFwiZG9sbGFyX2NhXCIsXG4gICAgbmFtZTogXCJDYW5hZGlhbiBEb2xsYXJcIixcbiAgICBsYWJlbDogXCIkXCIsXG4gICAgdmFsOiAxLjMzNDQ4XG59LCB7XG4gICAgaWQ6IFwiZG9sbGFyX2F1XCIsXG4gICAgbmFtZTogXCJBdXN0cmFsaWFuIERvbGxhclwiLFxuICAgIGxhYmVsOiBcIiRcIixcbiAgICB2YWw6IDEuMzA5MzFcbn1dO1xuXG5leHBvcnQgZGVmYXVsdCBwcmljZUN1cnJlbmNpZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgcHJpY2VNb2RlcyA9IFt7XG4gICAgaWQ6IFwibG93XCIsXG4gICAgbmFtZTogXCJMb3dcIixcbn0sIHtcbiAgICBpZDogXCJhdmVyYWdlXCIsXG4gICAgbmFtZTogXCJBdmVyYWdlXCIsXG59LCB7XG4gICAgaWQ6IFwiaGlnaFwiLFxuICAgIG5hbWU6IFwiSGlnaFwiLFxufV07XG5cbmV4cG9ydCBkZWZhdWx0IHByaWNlTW9kZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgZGVja1BhcnRzID0gW3tcbiAgICBpZDogXCJtYWluXCIsXG4gICAgbmFtZTogXCJNYWluXCIsXG4gICAgZmlsZUlkOiBcIiNtYWluXCIsXG4gICAgc2l6ZTogWzQwLCA2MF1cbn0sIHtcbiAgICBpZDogXCJleHRyYVwiLFxuICAgIG5hbWU6IFwiRXh0cmFcIixcbiAgICBmaWxlSWQ6IFwiI2V4dHJhXCIsXG4gICAgc2l6ZTogWzAsIDE1XVxufSwge1xuICAgIGlkOiBcInNpZGVcIixcbiAgICBuYW1lOiBcIlNpZGVcIixcbiAgICBmaWxlSWQ6IFwiIXNpZGVcIixcbiAgICBzaXplOiBbMCwgMTVdXG59XTtcblxuZXhwb3J0IGRlZmF1bHQgZGVja1BhcnRzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBkYXRhUHJpY2VDdXJyZW5jaWVzIGZyb20gXCIuL2RhdGEvcHJpY2VDdXJyZW5jaWVzXCI7XG5pbXBvcnQgZGF0YVByaWNlTW9kZXMgZnJvbSBcIi4vZGF0YS9wcmljZU1vZGVzXCI7XG5pbXBvcnQgZGF0YURlY2tQYXJ0cyBmcm9tIFwiLi9kYXRhL2RlY2tQYXJ0c1wiO1xuXG5jb25zdCBhcHBEYXRhID0ge1xuICAgIGRlY2twYXJ0czogZGF0YURlY2tQYXJ0cyxcbiAgICBkZWNrOiB7XG4gICAgICAgIG5hbWU6IFwiVW5uYW1lZFwiLFxuICAgICAgICBsaW5rOiBcIlwiLFxuICAgICAgICBsaXN0OiB7XG4gICAgICAgICAgICBtYWluOiBbXSxcbiAgICAgICAgICAgIGV4dHJhOiBbXSxcbiAgICAgICAgICAgIHNpZGU6IFtdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNhcmRzOiB7XG4gICAgICAgIHBhaXJzOiBbXSxcbiAgICAgICAgZGF0YToge31cbiAgICB9LFxuICAgIGJ1aWxkZXI6IHtcbiAgICAgICAgZmlsdGVyOiBcIlwiLFxuICAgICAgICBwYWlyc0ZpbHRlcmVkOiBbXSxcbiAgICB9LFxuICAgIHByaWNlOiB7XG4gICAgICAgIGFjdGl2ZUN1cnJlbmN5OiBcImRvbGxhcl91c1wiLFxuICAgICAgICBtb2RlczogZGF0YVByaWNlTW9kZXMsXG4gICAgICAgIGN1cnJlbmNpZXM6IGRhdGFQcmljZUN1cnJlbmNpZXNcbiAgICB9LFxuICAgIGFqYXg6IHtcbiAgICAgICAgY3VycmVudGx5TG9hZGluZzogZmFsc2UsXG4gICAgICAgIG5hbWVzTG9hZGVkOiBmYWxzZSxcbiAgICAgICAgcHJpY2VzTG9hZGVkOiBmYWxzZVxuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGFwcERhdGE7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgdXJpTG9jYXRpb25Ob1BhcmFtID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsb2NhdGlvbi5vcmlnaW4gKyBsb2NhdGlvbi5wYXRobmFtZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVyaUxvY2F0aW9uTm9QYXJhbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBlYWNoT2JqZWN0ID0gZnVuY3Rpb24gKG9iamVjdCwgZm4pIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICBjb25zdCBsID0ga2V5cy5sZW5ndGg7XG4gICAgbGV0IGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBsKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRLZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGZuKG9iamVjdFtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgaSk7XG4gICAgICAgIGkrKztcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBlYWNoT2JqZWN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7XG4gICAgbmFtZUFQSSxcbiAgICBpbWFnZUFQSSxcbiAgICBidXlBUElcbn0gZnJvbSBcIi4uL2RhdGEvYXBpVVJMc1wiO1xuaW1wb3J0IHV0aWxFYWNoT2JqZWN0IGZyb20gXCIuL3V0aWxFYWNoT2JqZWN0XCI7XG5cbmNvbnN0IGFwaUxvYWROYW1lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG5cbiAgICB2bS5hamF4LmN1cnJlbnRseUxvYWRpbmcgPSB0cnVlO1xuICAgIHZtLmFqYXgubmFtZXNMb2FkZWQgPSBmYWxzZTtcblxuICAgIGZldGNoKG5hbWVBUEkpXG4gICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKGpzb24gPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0RGF0YSA9IHt9O1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0UGFpcnMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVTdG9yYWdlID0gW107XG5cbiAgICAgICAgICAgIHV0aWxFYWNoT2JqZWN0KGpzb24sIChuYW1lLCBpZCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc3VsdERhdGFbaWRdID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBpbWc6IGAke2ltYWdlQVBJfS8ke2lkfS5qcGdgLFxuICAgICAgICAgICAgICAgICAgICBsaW5rOiBgJHtidXlBUEl9JHtlbmNvZGVVUkkobmFtZSl9YCxcbiAgICAgICAgICAgICAgICAgICAgcHJpY2U6IGZhbHNlXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vT25seSBhZGQgZWFjaCBjYXJkIG9uY2UgdG8gcGFycywgc2tpcCBhbHRlcm5hdGUgYXJ0c1xuICAgICAgICAgICAgICAgIGlmIChuYW1lU3RvcmFnZS5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRQYWlycy5wdXNoKFtpZCwgbmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5hbWVTdG9yYWdlLnB1c2gobmFtZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdm0uY2FyZHMuZGF0YSA9IHJlc3VsdERhdGE7XG4gICAgICAgICAgICB2bS5jYXJkcy5wYWlycyA9IHJlc3VsdFBhaXJzLnNvcnQoKGEsIGIpID0+IGFbMV0ubG9jYWxlQ29tcGFyZShiWzFdKSk7XG4gICAgICAgICAgICB2bS5idWlsZGVyVXBkYXRlTmFtZXMoKTtcblxuICAgICAgICAgICAgdm0uYWpheC5jdXJyZW50bHlMb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB2bS5hamF4Lm5hbWVzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBhcGlMb2FkTmFtZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0IGNvbnN0IG5hbWVBUEkgPSBcIi4vYXBpL25hbWVzL25hbWVzLm1pbi5qc29uXCI7XG5leHBvcnQgY29uc3QgcHJpY2VBUEkgPSBcIi4vYXBpL3ByaWNlcy9wcmljZXMucGhwP249XCI7XG5leHBvcnQgY29uc3QgaW1hZ2VBUEkgPSBcImh0dHBzOi8veWdvcHJvZGVjay5jb20vcGljc1wiO1xuZXhwb3J0IGNvbnN0IGJ1eUFQSSA9IFwiaHR0cDovL3l1Z2lvaHByaWNlcy5jb20vY2FyZF9wcmljZT9uYW1lPVwiO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7XG4gICAgcHJpY2VBUElcbn0gZnJvbSBcIi4uL2RhdGEvYXBpVVJMc1wiO1xuLy9pbXBvcnQgdXRpbEVhY2hPYmplY3QgZnJvbSBcIi4vdXRpbEVhY2hPYmplY3RcIjtcblxuY29uc3QgYXBpTG9hZFByaWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgLy9BcnJheSBvZiB1bmlxdWUgaWRzLCBtaW51cyB0aGUgb25lcyB3aGVyZSBwcmljZXMgd2VyZSBhbHJlYWR5IGxvYWRlZFxuICAgIGNvbnN0IGNhcmRJZHMgPSB2bS5kZWNrQ2FyZHNXaXRob3V0UHJpY2VEYXRhKCk7XG5cbiAgICBpZiAoY2FyZElkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGNhcmROYW1lcyA9IGNhcmRJZHMubWFwKGNhcmRJZCA9PiB2bS5jYXJkcy5kYXRhW2NhcmRJZF0ubmFtZSk7XG4gICAgICAgIGNvbnN0IHByaWNlUXVlcnkgPSBidG9hKEpTT04uc3RyaW5naWZ5KGNhcmROYW1lcykpO1xuXG4gICAgICAgIHZtLmFqYXguY3VycmVudGx5TG9hZGluZyA9IHRydWU7XG4gICAgICAgIHZtLmFqYXgucHJpY2VzTG9hZGVkID0gZmFsc2U7XG5cbiAgICAgICAgZmV0Y2gocHJpY2VBUEkgKyBwcmljZVF1ZXJ5KVxuICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oanNvbiA9PiB7XG4gICAgICAgICAgICAgICAgY2FyZElkcy5mb3JFYWNoKChpZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJpY2VEYXRhID0ganNvbltpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhcmQgPSB2bS5jYXJkcy5kYXRhW2lkXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FyZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZC5wcmljZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3c6IHByaWNlRGF0YS5sb3csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZlcmFnZTogcHJpY2VEYXRhLmF2ZXJhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaDogcHJpY2VEYXRhLmhpZ2hcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZtLmFqYXguY3VycmVudGx5TG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZtLmFqYXgucHJpY2VzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZtLmFqYXgucHJpY2VzTG9hZGVkID0gdHJ1ZTtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBhcGlMb2FkUHJpY2VzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBkZWNrUGFydHMgZnJvbSBcIi4uL2RhdGEvZGVja1BhcnRzXCI7XG5cbmNvbnN0IGNvbnZlcnRGaWxlVG9EZWNrID0gZnVuY3Rpb24gKGZpbGVDb250ZW50KSB7XG4gICAgY29uc3QgZmlsZUNvbnRlbnRUcmltbWVkID0gZmlsZUNvbnRlbnQucmVwbGFjZSgvI2NyZWF0ZWQuKy8sIFwiXCIpLnRyaW0oKTtcbiAgICBjb25zdCBhcnIgPSBmaWxlQ29udGVudFRyaW1tZWQuc3BsaXQoL1sjIV0uKy9nKS5zcGxpY2UoMSk7XG4gICAgY29uc3QgYXJyUGFydHMgPSBhcnIubWFwKHBhcnQgPT4gcGFydC5zcGxpdChcIlxcblwiKS5maWx0ZXIobGluZSA9PiBsaW5lLmxlbmd0aCA+IDEpLm1hcChOdW1iZXIpKTtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcblxuICAgIGRlY2tQYXJ0cy5mb3JFYWNoKChkZWNrcGFydCwgaW5kZXgpID0+IHtcbiAgICAgICAgcmVzdWx0W2RlY2twYXJ0LmlkXSA9IGFyclBhcnRzW2luZGV4XTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjb252ZXJ0RmlsZVRvRGVjaztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgY29udmVydEZpbGVUb0RlY2sgZnJvbSBcIi4vY29udmVydEZpbGVUb0RlY2tcIjtcblxuY29uc3QgZGVja0xvYWQgPSBmdW5jdGlvbiAoZmlsZSkge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuXG4gICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGNvbnN0IGZpbGVDb250ZW50ID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgICBjb25zdCBkZWNrTGlzdCA9IGNvbnZlcnRGaWxlVG9EZWNrKGZpbGVDb250ZW50KTtcblxuICAgICAgICB2bS5kZWNrLm5hbWUgPSBmaWxlLm5hbWUucmVwbGFjZShcIi55ZGtcIiwgXCJcIik7XG4gICAgICAgIHZtLmRlY2subGlzdCA9IGRlY2tMaXN0O1xuICAgICAgICB2bS5kZWNrVXBkYXRlKCk7XG4gICAgfTtcblxuICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZGVja0xvYWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IGRlY2tQYXJ0cyBmcm9tIFwiLi4vZGF0YS9kZWNrUGFydHNcIjtcblxuY29uc3QgdXJpRGVja0RlY29kZSA9IGZ1bmN0aW9uIChkZWNrVXJpKSB7XG4gICAgY29uc3QgZGVja0FycmF5ID0gSlNPTi5wYXJzZShhdG9iKGRlY2tVcmkucmVwbGFjZShcIj9kPVwiLCBcIlwiKSkpO1xuICAgIGNvbnN0IGRlY2tMaXN0ID0ge307XG5cbiAgICBkZWNrUGFydHMuZm9yRWFjaCgoZGVja3BhcnQsIGluZGV4KSA9PiB7XG4gICAgICAgIGRlY2tMaXN0W2RlY2twYXJ0LmlkXSA9IGRlY2tBcnJheVsxXVtpbmRleF07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gW2RlY2tBcnJheVswXSwgZGVja0xpc3RdO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXJpRGVja0RlY29kZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgdXJpRGVja0RlY29kZSBmcm9tIFwiLi91cmlEZWNrRGVjb2RlXCI7XG5cbmNvbnN0IGRlY2tMb2FkVXJpID0gZnVuY3Rpb24gKHVyaURlY2spIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgY29uc3QgZGVja0FycmF5ID0gdXJpRGVja0RlY29kZSh1cmlEZWNrKTtcblxuICAgIHZtLmRlY2submFtZSA9IGRlY2tBcnJheVswXTtcbiAgICB2bS5kZWNrLmxpc3QgPSBkZWNrQXJyYXlbMV07XG4gICAgdm0uZGVja1VwZGF0ZSh1cmlEZWNrKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGRlY2tMb2FkVXJpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cblxuY29uc3QgdXJpRGVja0VuY29kZSA9IGZ1bmN0aW9uIChkZWNrKSB7XG4gICAgY29uc3QgZGVja0FycmF5ID0gW2RlY2submFtZSwgT2JqZWN0LnZhbHVlcyhkZWNrLmxpc3QpXTtcbiAgICBjb25zdCBkZWNrVXJpID0gYnRvYShKU09OLnN0cmluZ2lmeShkZWNrQXJyYXkpKTtcblxuICAgIHJldHVybiBcIj9kPVwiICsgZGVja1VyaTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVyaURlY2tFbmNvZGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHVyaURlY2tFbmNvZGUgZnJvbSBcIi4vdXJpRGVja0VuY29kZVwiO1xuXG5jb25zdCBkZWNrVXBkYXRlID0gZnVuY3Rpb24gKGRlY2tMaW5rKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuXG4gICAgdm0uZGVjay5saW5rID0gZGVja0xpbmsgfHwgdXJpRGVja0VuY29kZSh2bS5kZWNrKTtcbiAgICB2bS5hamF4LnByaWNlc0xvYWRlZCA9IGZhbHNlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZGVja1VwZGF0ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgdXRpbEVhY2hPYmplY3QgZnJvbSBcIi4vdXRpbEVhY2hPYmplY3RcIjtcblxuY29uc3QgZGVja0NhcmRzV2l0aG91dFByaWNlRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgY29uc3QgZGF0YSA9IHZtLmNhcmRzLmRhdGE7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICB1dGlsRWFjaE9iamVjdCh2bS5kZWNrLmxpc3QsIGRlY2twYXJ0ID0+IHtcbiAgICAgICAgZGVja3BhcnQuZm9yRWFjaChjYXJkSWQgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5pbmRleE9mKGNhcmRJZCkgPT09IC0xICYmICFkYXRhW2NhcmRJZF0ucHJpY2UpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjYXJkSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBkZWNrQ2FyZHNXaXRob3V0UHJpY2VEYXRhO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IHByaWNlQ29udmVydCA9IGZ1bmN0aW9uIChwcmljZSkge1xuICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICBjb25zdCBjdXJyZW5jeSA9IHZtLnByaWNlLmN1cnJlbmNpZXMuZmluZChpdGVtID0+IGl0ZW0uaWQgPT09IHZtLnByaWNlLmFjdGl2ZUN1cnJlbmN5KTtcbiAgICBjb25zdCB2YWwgPSAocHJpY2UgKiBjdXJyZW5jeS52YWwpLnRvRml4ZWQoMik7XG5cbiAgICByZXR1cm4gdmFsICsgY3VycmVuY3kubGFiZWw7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwcmljZUNvbnZlcnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgcHJpY2VGb3JDYXJkID0gZnVuY3Rpb24gKGlkLCBtb2RlKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIGNvbnN0IHByaWNlID0gdm0uY2FyZHMuZGF0YVtpZF0ucHJpY2VbbW9kZV07XG5cbiAgICBpZiAocHJpY2UpIHtcbiAgICAgICAgcmV0dXJuIHZtLnByaWNlQ29udmVydChwcmljZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiTm90IGZvdW5kXCI7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgcHJpY2VGb3JDYXJkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB1dGlsRWFjaE9iamVjdCBmcm9tIFwiLi91dGlsRWFjaE9iamVjdFwiO1xuXG5jb25zdCBwcmljZUZvclNlY3Rpb24gPSBmdW5jdGlvbiAoc2VjdGlvbiwgbW9kZSkge1xuICAgIGNvbnN0IHByaWNlU3VtID0gZnVuY3Rpb24gKGFycikge1xuICAgICAgICBsZXQgcmVzdWx0ID0gMDtcblxuICAgICAgICBpZiAoYXJyICYmIGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFyci5mb3JFYWNoKGlkID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXJkRGF0YSA9IHZtLmNhcmRzLmRhdGFbaWRdO1xuICAgICAgICAgICAgICAgIGlmIChjYXJkRGF0YSAmJiBjYXJkRGF0YS5wcmljZSAmJiBjYXJkRGF0YS5wcmljZVttb2RlXSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gY2FyZERhdGEucHJpY2VbbW9kZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIGxldCBwcmljZSA9IDA7XG5cbiAgICBpZiAoc2VjdGlvbiA9PT0gXCIqXCIpIHtcbiAgICAgICAgdXRpbEVhY2hPYmplY3Qodm0uZGVjay5saXN0LCBkZWNrcGFydCA9PiB7XG4gICAgICAgICAgICBwcmljZSArPSBwcmljZVN1bShkZWNrcGFydCk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHByaWNlID0gcHJpY2VTdW0odm0uZGVjay5saXN0W3NlY3Rpb25dKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdm0ucHJpY2VDb252ZXJ0KHByaWNlKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHByaWNlRm9yU2VjdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBidWlsZGVyVXBkYXRlTmFtZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIGNvbnN0IGZpbHRlciA9IHZtLmJ1aWxkZXIuZmlsdGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgbGV0IHJlc3VsdCA9IHZtLmNhcmRzLnBhaXJzLmZpbHRlcihjYXJkID0+IHtcbiAgICAgICAgcmV0dXJuIGNhcmRbMV0udG9Mb3dlckNhc2UoKS5pbmRleE9mKGZpbHRlcikgIT09IC0xO1xuICAgIH0pO1xuXG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPiA1MDApIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNwbGljZSgwLCA1MDApO1xuICAgIH1cblxuICAgIHZtLmJ1aWxkZXIucGFpcnNGaWx0ZXJlZCA9IHJlc3VsdDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGJ1aWxkZXJVcGRhdGVOYW1lcztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBidWlsZGVyRGVja0FkZCA9IGZ1bmN0aW9uIChpZCwgcGFydCkge1xuICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICBjb25zdCBjYXJkSWQgPSBOdW1iZXIoaWQpO1xuICAgIGNvbnN0IGRlY2tQYXJ0ID0gdm0uZGVjay5saXN0W3BhcnRdO1xuICAgIGNvbnN0IGRlY2tQYXJ0TWF4ID0gdm0uZGVja3BhcnRzLmZpbmQoZGVja3BhcnQgPT4gZGVja3BhcnQuaWQgPT09IHBhcnQpLnNpemVbMV07XG5cbiAgICBpZiAoZGVja1BhcnQubGVuZ3RoIDwgZGVja1BhcnRNYXggJiYgZGVja1BhcnQuZmlsdGVyKGlkID0+IGlkID09PSBjYXJkSWQpLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgZGVja1BhcnQucHVzaChjYXJkSWQpO1xuICAgICAgICB2bS5kZWNrVXBkYXRlKCk7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgYnVpbGRlckRlY2tBZGQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgYnVpbGRlckRlY2tSZW1vdmUgPSBmdW5jdGlvbiAoaWQsIHBhcnQpIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgbGV0IGZvdW5kQ2FyZCA9IGZhbHNlO1xuXG4gICAgdm0uZGVjay5saXN0W3BhcnRdID0gdm0uZGVjay5saXN0W3BhcnRdLmZpbHRlcihjYXJkSWQgPT4ge1xuICAgICAgICBpZiAoIWZvdW5kQ2FyZCkge1xuICAgICAgICAgICAgaWYgKGlkID09PSBjYXJkSWQpIHtcbiAgICAgICAgICAgICAgICBmb3VuZENhcmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICB2bS5kZWNrVXBkYXRlKCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBidWlsZGVyRGVja1JlbW92ZTtcbiIsIi8qIEZpbGVTYXZlci5qc1xuICogQSBzYXZlQXMoKSBGaWxlU2F2ZXIgaW1wbGVtZW50YXRpb24uXG4gKiAxLjMuMlxuICogMjAxNi0wNi0xNiAxODoyNToxOVxuICpcbiAqIEJ5IEVsaSBHcmV5LCBodHRwOi8vZWxpZ3JleS5jb21cbiAqIExpY2Vuc2U6IE1JVFxuICogICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VsaWdyZXkvRmlsZVNhdmVyLmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWRcbiAqL1xuXG4vKmdsb2JhbCBzZWxmICovXG4vKmpzbGludCBiaXR3aXNlOiB0cnVlLCBpbmRlbnQ6IDQsIGxheGJyZWFrOiB0cnVlLCBsYXhjb21tYTogdHJ1ZSwgc21hcnR0YWJzOiB0cnVlLCBwbHVzcGx1czogdHJ1ZSAqL1xuXG4vKiEgQHNvdXJjZSBodHRwOi8vcHVybC5lbGlncmV5LmNvbS9naXRodWIvRmlsZVNhdmVyLmpzL2Jsb2IvbWFzdGVyL0ZpbGVTYXZlci5qcyAqL1xuXG52YXIgc2F2ZUFzID0gc2F2ZUFzIHx8IChmdW5jdGlvbih2aWV3KSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHQvLyBJRSA8MTAgaXMgZXhwbGljaXRseSB1bnN1cHBvcnRlZFxuXHRpZiAodHlwZW9mIHZpZXcgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiAvTVNJRSBbMS05XVxcLi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuXHRcdHJldHVybjtcblx0fVxuXHR2YXJcblx0XHQgIGRvYyA9IHZpZXcuZG9jdW1lbnRcblx0XHQgIC8vIG9ubHkgZ2V0IFVSTCB3aGVuIG5lY2Vzc2FyeSBpbiBjYXNlIEJsb2IuanMgaGFzbid0IG92ZXJyaWRkZW4gaXQgeWV0XG5cdFx0LCBnZXRfVVJMID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdmlldy5VUkwgfHwgdmlldy53ZWJraXRVUkwgfHwgdmlldztcblx0XHR9XG5cdFx0LCBzYXZlX2xpbmsgPSBkb2MuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLCBcImFcIilcblx0XHQsIGNhbl91c2Vfc2F2ZV9saW5rID0gXCJkb3dubG9hZFwiIGluIHNhdmVfbGlua1xuXHRcdCwgY2xpY2sgPSBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHR2YXIgZXZlbnQgPSBuZXcgTW91c2VFdmVudChcImNsaWNrXCIpO1xuXHRcdFx0bm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0XHR9XG5cdFx0LCBpc19zYWZhcmkgPSAvY29uc3RydWN0b3IvaS50ZXN0KHZpZXcuSFRNTEVsZW1lbnQpIHx8IHZpZXcuc2FmYXJpXG5cdFx0LCBpc19jaHJvbWVfaW9zID0vQ3JpT1NcXC9bXFxkXSsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudClcblx0XHQsIHRocm93X291dHNpZGUgPSBmdW5jdGlvbihleCkge1xuXHRcdFx0KHZpZXcuc2V0SW1tZWRpYXRlIHx8IHZpZXcuc2V0VGltZW91dCkoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRocm93IGV4O1xuXHRcdFx0fSwgMCk7XG5cdFx0fVxuXHRcdCwgZm9yY2Vfc2F2ZWFibGVfdHlwZSA9IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJcblx0XHQvLyB0aGUgQmxvYiBBUEkgaXMgZnVuZGFtZW50YWxseSBicm9rZW4gYXMgdGhlcmUgaXMgbm8gXCJkb3dubG9hZGZpbmlzaGVkXCIgZXZlbnQgdG8gc3Vic2NyaWJlIHRvXG5cdFx0LCBhcmJpdHJhcnlfcmV2b2tlX3RpbWVvdXQgPSAxMDAwICogNDAgLy8gaW4gbXNcblx0XHQsIHJldm9rZSA9IGZ1bmN0aW9uKGZpbGUpIHtcblx0XHRcdHZhciByZXZva2VyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgZmlsZSA9PT0gXCJzdHJpbmdcIikgeyAvLyBmaWxlIGlzIGFuIG9iamVjdCBVUkxcblx0XHRcdFx0XHRnZXRfVVJMKCkucmV2b2tlT2JqZWN0VVJMKGZpbGUpO1xuXHRcdFx0XHR9IGVsc2UgeyAvLyBmaWxlIGlzIGEgRmlsZVxuXHRcdFx0XHRcdGZpbGUucmVtb3ZlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRzZXRUaW1lb3V0KHJldm9rZXIsIGFyYml0cmFyeV9yZXZva2VfdGltZW91dCk7XG5cdFx0fVxuXHRcdCwgZGlzcGF0Y2ggPSBmdW5jdGlvbihmaWxlc2F2ZXIsIGV2ZW50X3R5cGVzLCBldmVudCkge1xuXHRcdFx0ZXZlbnRfdHlwZXMgPSBbXS5jb25jYXQoZXZlbnRfdHlwZXMpO1xuXHRcdFx0dmFyIGkgPSBldmVudF90eXBlcy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdHZhciBsaXN0ZW5lciA9IGZpbGVzYXZlcltcIm9uXCIgKyBldmVudF90eXBlc1tpXV07XG5cdFx0XHRcdGlmICh0eXBlb2YgbGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRsaXN0ZW5lci5jYWxsKGZpbGVzYXZlciwgZXZlbnQgfHwgZmlsZXNhdmVyKTtcblx0XHRcdFx0XHR9IGNhdGNoIChleCkge1xuXHRcdFx0XHRcdFx0dGhyb3dfb3V0c2lkZShleCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdCwgYXV0b19ib20gPSBmdW5jdGlvbihibG9iKSB7XG5cdFx0XHQvLyBwcmVwZW5kIEJPTSBmb3IgVVRGLTggWE1MIGFuZCB0ZXh0LyogdHlwZXMgKGluY2x1ZGluZyBIVE1MKVxuXHRcdFx0Ly8gbm90ZTogeW91ciBicm93c2VyIHdpbGwgYXV0b21hdGljYWxseSBjb252ZXJ0IFVURi0xNiBVK0ZFRkYgdG8gRUYgQkIgQkZcblx0XHRcdGlmICgvXlxccyooPzp0ZXh0XFwvXFxTKnxhcHBsaWNhdGlvblxcL3htbHxcXFMqXFwvXFxTKlxcK3htbClcXHMqOy4qY2hhcnNldFxccyo9XFxzKnV0Zi04L2kudGVzdChibG9iLnR5cGUpKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgQmxvYihbU3RyaW5nLmZyb21DaGFyQ29kZSgweEZFRkYpLCBibG9iXSwge3R5cGU6IGJsb2IudHlwZX0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGJsb2I7XG5cdFx0fVxuXHRcdCwgRmlsZVNhdmVyID0gZnVuY3Rpb24oYmxvYiwgbmFtZSwgbm9fYXV0b19ib20pIHtcblx0XHRcdGlmICghbm9fYXV0b19ib20pIHtcblx0XHRcdFx0YmxvYiA9IGF1dG9fYm9tKGJsb2IpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRmlyc3QgdHJ5IGEuZG93bmxvYWQsIHRoZW4gd2ViIGZpbGVzeXN0ZW0sIHRoZW4gb2JqZWN0IFVSTHNcblx0XHRcdHZhclxuXHRcdFx0XHQgIGZpbGVzYXZlciA9IHRoaXNcblx0XHRcdFx0LCB0eXBlID0gYmxvYi50eXBlXG5cdFx0XHRcdCwgZm9yY2UgPSB0eXBlID09PSBmb3JjZV9zYXZlYWJsZV90eXBlXG5cdFx0XHRcdCwgb2JqZWN0X3VybFxuXHRcdFx0XHQsIGRpc3BhdGNoX2FsbCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRpc3BhdGNoKGZpbGVzYXZlciwgXCJ3cml0ZXN0YXJ0IHByb2dyZXNzIHdyaXRlIHdyaXRlZW5kXCIuc3BsaXQoXCIgXCIpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBvbiBhbnkgZmlsZXN5cyBlcnJvcnMgcmV2ZXJ0IHRvIHNhdmluZyB3aXRoIG9iamVjdCBVUkxzXG5cdFx0XHRcdCwgZnNfZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoKGlzX2Nocm9tZV9pb3MgfHwgKGZvcmNlICYmIGlzX3NhZmFyaSkpICYmIHZpZXcuRmlsZVJlYWRlcikge1xuXHRcdFx0XHRcdFx0Ly8gU2FmYXJpIGRvZXNuJ3QgYWxsb3cgZG93bmxvYWRpbmcgb2YgYmxvYiB1cmxzXG5cdFx0XHRcdFx0XHR2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblx0XHRcdFx0XHRcdHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHVybCA9IGlzX2Nocm9tZV9pb3MgPyByZWFkZXIucmVzdWx0IDogcmVhZGVyLnJlc3VsdC5yZXBsYWNlKC9eZGF0YTpbXjtdKjsvLCAnZGF0YTphdHRhY2htZW50L2ZpbGU7Jyk7XG5cdFx0XHRcdFx0XHRcdHZhciBwb3B1cCA9IHZpZXcub3Blbih1cmwsICdfYmxhbmsnKTtcblx0XHRcdFx0XHRcdFx0aWYoIXBvcHVwKSB2aWV3LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG5cdFx0XHRcdFx0XHRcdHVybD11bmRlZmluZWQ7IC8vIHJlbGVhc2UgcmVmZXJlbmNlIGJlZm9yZSBkaXNwYXRjaGluZ1xuXHRcdFx0XHRcdFx0XHRmaWxlc2F2ZXIucmVhZHlTdGF0ZSA9IGZpbGVzYXZlci5ET05FO1xuXHRcdFx0XHRcdFx0XHRkaXNwYXRjaF9hbGwoKTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRyZWFkZXIucmVhZEFzRGF0YVVSTChibG9iKTtcblx0XHRcdFx0XHRcdGZpbGVzYXZlci5yZWFkeVN0YXRlID0gZmlsZXNhdmVyLklOSVQ7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIGRvbid0IGNyZWF0ZSBtb3JlIG9iamVjdCBVUkxzIHRoYW4gbmVlZGVkXG5cdFx0XHRcdFx0aWYgKCFvYmplY3RfdXJsKSB7XG5cdFx0XHRcdFx0XHRvYmplY3RfdXJsID0gZ2V0X1VSTCgpLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGZvcmNlKSB7XG5cdFx0XHRcdFx0XHR2aWV3LmxvY2F0aW9uLmhyZWYgPSBvYmplY3RfdXJsO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR2YXIgb3BlbmVkID0gdmlldy5vcGVuKG9iamVjdF91cmwsIFwiX2JsYW5rXCIpO1xuXHRcdFx0XHRcdFx0aWYgKCFvcGVuZWQpIHtcblx0XHRcdFx0XHRcdFx0Ly8gQXBwbGUgZG9lcyBub3QgYWxsb3cgd2luZG93Lm9wZW4sIHNlZSBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vbGlicmFyeS9zYWZhcmkvZG9jdW1lbnRhdGlvbi9Ub29scy9Db25jZXB0dWFsL1NhZmFyaUV4dGVuc2lvbkd1aWRlL1dvcmtpbmd3aXRoV2luZG93c2FuZFRhYnMvV29ya2luZ3dpdGhXaW5kb3dzYW5kVGFicy5odG1sXG5cdFx0XHRcdFx0XHRcdHZpZXcubG9jYXRpb24uaHJlZiA9IG9iamVjdF91cmw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZpbGVzYXZlci5yZWFkeVN0YXRlID0gZmlsZXNhdmVyLkRPTkU7XG5cdFx0XHRcdFx0ZGlzcGF0Y2hfYWxsKCk7XG5cdFx0XHRcdFx0cmV2b2tlKG9iamVjdF91cmwpO1xuXHRcdFx0XHR9XG5cdFx0XHQ7XG5cdFx0XHRmaWxlc2F2ZXIucmVhZHlTdGF0ZSA9IGZpbGVzYXZlci5JTklUO1xuXG5cdFx0XHRpZiAoY2FuX3VzZV9zYXZlX2xpbmspIHtcblx0XHRcdFx0b2JqZWN0X3VybCA9IGdldF9VUkwoKS5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0c2F2ZV9saW5rLmhyZWYgPSBvYmplY3RfdXJsO1xuXHRcdFx0XHRcdHNhdmVfbGluay5kb3dubG9hZCA9IG5hbWU7XG5cdFx0XHRcdFx0Y2xpY2soc2F2ZV9saW5rKTtcblx0XHRcdFx0XHRkaXNwYXRjaF9hbGwoKTtcblx0XHRcdFx0XHRyZXZva2Uob2JqZWN0X3VybCk7XG5cdFx0XHRcdFx0ZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuRE9ORTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0ZnNfZXJyb3IoKTtcblx0XHR9XG5cdFx0LCBGU19wcm90byA9IEZpbGVTYXZlci5wcm90b3R5cGVcblx0XHQsIHNhdmVBcyA9IGZ1bmN0aW9uKGJsb2IsIG5hbWUsIG5vX2F1dG9fYm9tKSB7XG5cdFx0XHRyZXR1cm4gbmV3IEZpbGVTYXZlcihibG9iLCBuYW1lIHx8IGJsb2IubmFtZSB8fCBcImRvd25sb2FkXCIsIG5vX2F1dG9fYm9tKTtcblx0XHR9XG5cdDtcblx0Ly8gSUUgMTArIChuYXRpdmUgc2F2ZUFzKVxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYikge1xuXHRcdHJldHVybiBmdW5jdGlvbihibG9iLCBuYW1lLCBub19hdXRvX2JvbSkge1xuXHRcdFx0bmFtZSA9IG5hbWUgfHwgYmxvYi5uYW1lIHx8IFwiZG93bmxvYWRcIjtcblxuXHRcdFx0aWYgKCFub19hdXRvX2JvbSkge1xuXHRcdFx0XHRibG9iID0gYXV0b19ib20oYmxvYik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IoYmxvYiwgbmFtZSk7XG5cdFx0fTtcblx0fVxuXG5cdEZTX3Byb3RvLmFib3J0ID0gZnVuY3Rpb24oKXt9O1xuXHRGU19wcm90by5yZWFkeVN0YXRlID0gRlNfcHJvdG8uSU5JVCA9IDA7XG5cdEZTX3Byb3RvLldSSVRJTkcgPSAxO1xuXHRGU19wcm90by5ET05FID0gMjtcblxuXHRGU19wcm90by5lcnJvciA9XG5cdEZTX3Byb3RvLm9ud3JpdGVzdGFydCA9XG5cdEZTX3Byb3RvLm9ucHJvZ3Jlc3MgPVxuXHRGU19wcm90by5vbndyaXRlID1cblx0RlNfcHJvdG8ub25hYm9ydCA9XG5cdEZTX3Byb3RvLm9uZXJyb3IgPVxuXHRGU19wcm90by5vbndyaXRlZW5kID1cblx0XHRudWxsO1xuXG5cdHJldHVybiBzYXZlQXM7XG59KFxuXHQgICB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmXG5cdHx8IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93XG5cdHx8IHRoaXMuY29udGVudFxuKSk7XG4vLyBgc2VsZmAgaXMgdW5kZWZpbmVkIGluIEZpcmVmb3ggZm9yIEFuZHJvaWQgY29udGVudCBzY3JpcHQgY29udGV4dFxuLy8gd2hpbGUgYHRoaXNgIGlzIG5zSUNvbnRlbnRGcmFtZU1lc3NhZ2VNYW5hZ2VyXG4vLyB3aXRoIGFuIGF0dHJpYnV0ZSBgY29udGVudGAgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgd2luZG93XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzLnNhdmVBcyA9IHNhdmVBcztcbn0gZWxzZSBpZiAoKHR5cGVvZiBkZWZpbmUgIT09IFwidW5kZWZpbmVkXCIgJiYgZGVmaW5lICE9PSBudWxsKSAmJiAoZGVmaW5lLmFtZCAhPT0gbnVsbCkpIHtcbiAgZGVmaW5lKFwiRmlsZVNhdmVyLmpzXCIsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzYXZlQXM7XG4gIH0pO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBkZWNrUGFydHMgZnJvbSBcIi4uL2RhdGEvZGVja1BhcnRzXCI7XG5cbmNvbnN0IGNvbnZlcnREZWNrVG9GaWxlID0gZnVuY3Rpb24gKGRlY2tMaXN0KSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuXG4gICAgZGVja1BhcnRzLmZvckVhY2goZGVja3BhcnQgPT4ge1xuICAgICAgICByZXN1bHQucHVzaChkZWNrcGFydC5maWxlSWQpO1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGRlY2tMaXN0W2RlY2twYXJ0LmlkXSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCJcXG5cIik7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjb252ZXJ0RGVja1RvRmlsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgRmlsZVNhdmVyIGZyb20gXCJmaWxlLXNhdmVyL0ZpbGVTYXZlci5qc1wiO1xuXG5pbXBvcnQgY29udmVydERlY2tUb0ZpbGUgZnJvbSBcIi4vY29udmVydERlY2tUb0ZpbGUuanNcIjtcblxuY29uc3QgZmlsZURvd25sb2FkRGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgY29uc3QgZmlsZURhdGEgPSBjb252ZXJ0RGVja1RvRmlsZSh2bS5kZWNrLmxpc3QpO1xuICAgIGNvbnN0IGZpbGUgPSBuZXcgRmlsZShbZmlsZURhdGFdLCB2bS5kZWNrLm5hbWUgKyBcIi55ZGtcIiwge1xuICAgICAgICB0eXBlOiBcInRleHQveWRrXCJcbiAgICB9KTtcblxuICAgIHJldHVybiBGaWxlU2F2ZXIuc2F2ZUFzKGZpbGUpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZmlsZURvd25sb2FkRGVjaztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgdXJpTG9jYXRpb25Ob1BhcmFtIGZyb20gXCIuL21ldGhvZHMvdXJpTG9jYXRpb25Ob1BhcmFtXCI7XG5cbmltcG9ydCBhcGlMb2FkTmFtZXMgZnJvbSBcIi4vbWV0aG9kcy9hcGlMb2FkTmFtZXNcIjtcbmltcG9ydCBhcGlMb2FkUHJpY2VzIGZyb20gXCIuL21ldGhvZHMvYXBpTG9hZFByaWNlc1wiO1xuXG5pbXBvcnQgZGVja0xvYWQgZnJvbSBcIi4vbWV0aG9kcy9kZWNrTG9hZFwiO1xuaW1wb3J0IGRlY2tMb2FkVXJpIGZyb20gXCIuL21ldGhvZHMvZGVja0xvYWRVcmlcIjtcbmltcG9ydCBkZWNrVXBkYXRlIGZyb20gXCIuL21ldGhvZHMvZGVja1VwZGF0ZVwiO1xuaW1wb3J0IGRlY2tDYXJkc1dpdGhvdXRQcmljZURhdGEgZnJvbSBcIi4vbWV0aG9kcy9kZWNrQ2FyZHNXaXRob3V0UHJpY2VEYXRhXCI7XG5cbmltcG9ydCBwcmljZUNvbnZlcnQgZnJvbSBcIi4vbWV0aG9kcy9wcmljZUNvbnZlcnRcIjtcbmltcG9ydCBwcmljZUZvckNhcmQgZnJvbSBcIi4vbWV0aG9kcy9wcmljZUZvckNhcmRcIjtcbmltcG9ydCBwcmljZUZvclNlY3Rpb24gZnJvbSBcIi4vbWV0aG9kcy9wcmljZUZvclNlY3Rpb25cIjtcblxuaW1wb3J0IGJ1aWxkZXJVcGRhdGVOYW1lcyBmcm9tIFwiLi9tZXRob2RzL2J1aWxkZXJVcGRhdGVOYW1lc1wiO1xuaW1wb3J0IGJ1aWxkZXJEZWNrQWRkIGZyb20gXCIuL21ldGhvZHMvYnVpbGRlckRlY2tBZGRcIjtcbmltcG9ydCBidWlsZGVyRGVja1JlbW92ZSBmcm9tIFwiLi9tZXRob2RzL2J1aWxkZXJEZWNrUmVtb3ZlXCI7XG5cbmltcG9ydCBmaWxlRG93bmxvYWREZWNrIGZyb20gXCIuL21ldGhvZHMvZmlsZURvd25sb2FkRGVja1wiO1xuXG5jb25zdCBhcHBNZXRob2RzID0ge1xuICAgIHVyaUxvY2F0aW9uTm9QYXJhbSxcblxuICAgIGFwaUxvYWROYW1lcyxcbiAgICBhcGlMb2FkUHJpY2VzLFxuXG4gICAgZGVja0xvYWQsXG4gICAgZGVja0xvYWRVcmksXG4gICAgZGVja1VwZGF0ZSxcbiAgICBkZWNrQ2FyZHNXaXRob3V0UHJpY2VEYXRhLFxuXG4gICAgcHJpY2VDb252ZXJ0LFxuICAgIHByaWNlRm9yQ2FyZCxcbiAgICBwcmljZUZvclNlY3Rpb24sXG5cbiAgICBidWlsZGVyVXBkYXRlTmFtZXMsXG4gICAgYnVpbGRlckRlY2tBZGQsXG4gICAgYnVpbGRlckRlY2tSZW1vdmUsXG5cbiAgICBmaWxlRG93bmxvYWREZWNrLFxuXG4gICAgb25GaWxlQ2hhbmdlKGUpIHtcbiAgICAgICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgICAgICBjb25zdCBmaWxlcyA9IGUudGFyZ2V0LmZpbGVzIHx8IGUuZGF0YVRyYW5zZmVyLmZpbGVzO1xuXG4gICAgICAgIHZtLmRlY2tMb2FkKGZpbGVzWzBdKTtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBhcHBNZXRob2RzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBWdWUgZnJvbSBcIlZ1ZS9kaXN0L3Z1ZS5lc20uanNcIjtcbmltcG9ydCBhcHBEYXRhIGZyb20gXCIuL2FwcERhdGFcIjtcbmltcG9ydCBhcHBNZXRob2RzIGZyb20gXCIuL2FwcE1ldGhvZHNcIjtcblxuLy9yZWFkeS1ldmVudCByZXF1aXJlZCBiZWNhdXNlIHlnb3Byb2RlY2suY29tIGxvYWRzIHNjcmlwdHMgaW4gaGVhZFxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4ge1xuICAgIGNvbnN0IHVybFF1ZXJ5ID0gbG9jYXRpb24uc2VhcmNoO1xuICAgIGNvbnN0IHByaWNlQXBwID0gbmV3IFZ1ZSh7XG4gICAgICAgIGVsOiBcIiNhcHBcIixcbiAgICAgICAgZGF0YTogYXBwRGF0YSxcbiAgICAgICAgbWV0aG9kczogYXBwTWV0aG9kc1xuICAgIH0pO1xuXG4gICAgcHJpY2VBcHAuYXBpTG9hZE5hbWVzKCk7XG5cbiAgICBpZiAodXJsUXVlcnkuaW5kZXhPZihcIj9kXCIpICE9PSAtMSkge1xuICAgICAgICBwcmljZUFwcC5kZWNrTG9hZFVyaSh1cmxRdWVyeSk7XG4gICAgfVxufSk7XG4iXSwibmFtZXMiOlsiX3RvU3RyaW5nIiwidmFsIiwiSlNPTiIsInN0cmluZ2lmeSIsIlN0cmluZyIsInRvTnVtYmVyIiwibiIsInBhcnNlRmxvYXQiLCJpc05hTiIsIm1ha2VNYXAiLCJzdHIiLCJleHBlY3RzTG93ZXJDYXNlIiwibWFwIiwiT2JqZWN0IiwiY3JlYXRlIiwibGlzdCIsInNwbGl0IiwiaSIsImxlbmd0aCIsInRvTG93ZXJDYXNlIiwicmVtb3ZlIiwiYXJyIiwiaXRlbSIsImluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsImhhc093biIsIm9iaiIsImtleSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImlzUHJpbWl0aXZlIiwidmFsdWUiLCJjYWNoZWQiLCJmbiIsImNhY2hlIiwiYmluZCIsImN0eCIsImJvdW5kRm4iLCJhIiwibCIsImFyZ3VtZW50cyIsImFwcGx5IiwiX2xlbmd0aCIsInRvQXJyYXkiLCJzdGFydCIsInJldCIsIkFycmF5IiwiZXh0ZW5kIiwidG8iLCJfZnJvbSIsImlzT2JqZWN0IiwiaXNQbGFpbk9iamVjdCIsInRvU3RyaW5nIiwiT0JKRUNUX1NUUklORyIsInRvT2JqZWN0IiwicmVzIiwibm9vcCIsImxvb3NlRXF1YWwiLCJiIiwiaXNPYmplY3RBIiwiaXNPYmplY3RCIiwiZSIsImxvb3NlSW5kZXhPZiIsIm9uY2UiLCJjYWxsZWQiLCJpc1Jlc2VydmVkIiwiYyIsImNoYXJDb2RlQXQiLCJkZWYiLCJlbnVtZXJhYmxlIiwiZGVmaW5lUHJvcGVydHkiLCJwYXJzZVBhdGgiLCJwYXRoIiwiYmFpbFJFIiwidGVzdCIsInNlZ21lbnRzIiwiaXNOYXRpdmUiLCJDdG9yIiwicHVzaFRhcmdldCIsIl90YXJnZXQiLCJEZXAiLCJ0YXJnZXQiLCJwdXNoIiwicG9wVGFyZ2V0IiwidGFyZ2V0U3RhY2siLCJwb3AiLCJwcm90b0F1Z21lbnQiLCJzcmMiLCJfX3Byb3RvX18iLCJjb3B5QXVnbWVudCIsImtleXMiLCJvYnNlcnZlIiwiYXNSb290RGF0YSIsIm9iIiwiX19vYl9fIiwiT2JzZXJ2ZXIiLCJvYnNlcnZlclN0YXRlIiwic2hvdWxkQ29udmVydCIsImlzU2VydmVyUmVuZGVyaW5nIiwiaXNBcnJheSIsImlzRXh0ZW5zaWJsZSIsIl9pc1Z1ZSIsInZtQ291bnQiLCJkZWZpbmVSZWFjdGl2ZSQkMSIsImN1c3RvbVNldHRlciIsImRlcCIsInByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiY29uZmlndXJhYmxlIiwiZ2V0dGVyIiwiZ2V0Iiwic2V0dGVyIiwic2V0IiwiY2hpbGRPYiIsImRlcGVuZCIsIm5ld1ZhbCIsIm5vdGlmeSIsIk1hdGgiLCJtYXgiLCJkZWwiLCJkZXBlbmRBcnJheSIsIm1lcmdlRGF0YSIsImZyb20iLCJ0b1ZhbCIsImZyb21WYWwiLCJtZXJnZUhvb2siLCJwYXJlbnRWYWwiLCJjaGlsZFZhbCIsImNvbmNhdCIsIm1lcmdlQXNzZXRzIiwibm9ybWFsaXplUHJvcHMiLCJvcHRpb25zIiwicHJvcHMiLCJuYW1lIiwiY2FtZWxpemUiLCJ0eXBlIiwibm9ybWFsaXplRGlyZWN0aXZlcyIsImRpcnMiLCJkaXJlY3RpdmVzIiwidXBkYXRlIiwibWVyZ2VPcHRpb25zIiwicGFyZW50IiwiY2hpbGQiLCJ2bSIsIm1lcmdlRmllbGQiLCJzdHJhdCIsInN0cmF0cyIsImRlZmF1bHRTdHJhdCIsImV4dGVuZHNGcm9tIiwiZXh0ZW5kcyIsIm1peGlucyIsIm1peGluIiwicHJvdG90eXBlIiwiVnVlJDMiLCJyZXNvbHZlQXNzZXQiLCJpZCIsIndhcm5NaXNzaW5nIiwiYXNzZXRzIiwiY2FtZWxpemVkSWQiLCJQYXNjYWxDYXNlSWQiLCJjYXBpdGFsaXplIiwidmFsaWRhdGVQcm9wIiwicHJvcE9wdGlvbnMiLCJwcm9wc0RhdGEiLCJwcm9wIiwiYWJzZW50IiwiaXNUeXBlIiwiQm9vbGVhbiIsImh5cGhlbmF0ZSIsInVuZGVmaW5lZCIsImdldFByb3BEZWZhdWx0VmFsdWUiLCJwcmV2U2hvdWxkQ29udmVydCIsImRlZmF1bHQiLCIkb3B0aW9ucyIsIl9wcm9wcyIsImdldFR5cGUiLCJtYXRjaCIsImxlbiIsImhhbmRsZUVycm9yIiwiZXJyIiwiaW5mbyIsImNvbmZpZyIsImVycm9ySGFuZGxlciIsImluQnJvd3NlciIsImNvbnNvbGUiLCJlcnJvciIsImNyZWF0ZVRleHRWTm9kZSIsIlZOb2RlIiwiY2xvbmVWTm9kZSIsInZub2RlIiwiY2xvbmVkIiwidGFnIiwiZGF0YSIsImNoaWxkcmVuIiwidGV4dCIsImVsbSIsImNvbnRleHQiLCJjb21wb25lbnRPcHRpb25zIiwibnMiLCJpc1N0YXRpYyIsImlzQ2xvbmVkIiwiY2xvbmVWTm9kZXMiLCJ2bm9kZXMiLCJjcmVhdGVGbkludm9rZXIiLCJmbnMiLCJpbnZva2VyIiwiYXJndW1lbnRzJDEiLCJ1cGRhdGVMaXN0ZW5lcnMiLCJvbiIsIm9sZE9uIiwiYWRkIiwicmVtb3ZlJCQxIiwiY3VyIiwib2xkIiwiZXZlbnQiLCJub3JtYWxpemVFdmVudCIsImNhcHR1cmUiLCJtZXJnZVZOb2RlSG9vayIsImhvb2tLZXkiLCJob29rIiwid3JhcHBlZEhvb2siLCJ0aGlzIiwib2xkSG9vayIsIm1lcmdlZCIsInNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVBcnJheUNoaWxkcmVuIiwibmVzdGVkSW5kZXgiLCJsYXN0IiwiZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCIsImZpbHRlciIsImluaXRFdmVudHMiLCJfZXZlbnRzIiwiX2hhc0hvb2tFdmVudCIsImxpc3RlbmVycyIsIl9wYXJlbnRMaXN0ZW5lcnMiLCJvbmNlJCQxIiwiJG9uY2UiLCIkb24iLCJyZW1vdmUkMSIsIiRvZmYiLCJ1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMiLCJvbGRMaXN0ZW5lcnMiLCJyZXNvbHZlU2xvdHMiLCJzbG90cyIsImRlZmF1bHRTbG90IiwiZnVuY3Rpb25hbENvbnRleHQiLCJzbG90IiwiZXZlcnkiLCJpc1doaXRlc3BhY2UiLCJub2RlIiwiaXNDb21tZW50IiwicmVzb2x2ZVNjb3BlZFNsb3RzIiwiaW5pdExpZmVjeWNsZSIsImFic3RyYWN0IiwiJHBhcmVudCIsIiRjaGlsZHJlbiIsIiRyb290IiwiJHJlZnMiLCJfd2F0Y2hlciIsIl9pbmFjdGl2ZSIsIl9kaXJlY3RJbmFjdGl2ZSIsIl9pc01vdW50ZWQiLCJfaXNEZXN0cm95ZWQiLCJfaXNCZWluZ0Rlc3Ryb3llZCIsIm1vdW50Q29tcG9uZW50IiwiZWwiLCJoeWRyYXRpbmciLCIkZWwiLCJyZW5kZXIiLCJjcmVhdGVFbXB0eVZOb2RlIiwidXBkYXRlQ29tcG9uZW50IiwiX3VwZGF0ZSIsIl9yZW5kZXIiLCJXYXRjaGVyIiwiJHZub2RlIiwidXBkYXRlQ2hpbGRDb21wb25lbnQiLCJwYXJlbnRWbm9kZSIsInJlbmRlckNoaWxkcmVuIiwiaGFzQ2hpbGRyZW4iLCJfcmVuZGVyQ2hpbGRyZW4iLCJzY29wZWRTbG90cyIsIiRzY29wZWRTbG90cyIsImVtcHR5T2JqZWN0IiwiX3BhcmVudFZub2RlIiwiX3Zub2RlIiwicHJvcEtleXMiLCJfcHJvcEtleXMiLCIkc2xvdHMiLCIkZm9yY2VVcGRhdGUiLCJpc0luSW5hY3RpdmVUcmVlIiwiYWN0aXZhdGVDaGlsZENvbXBvbmVudCIsImRpcmVjdCIsImRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCIsImNhbGxIb29rIiwiaGFuZGxlcnMiLCJqIiwiJGVtaXQiLCJyZXNldFNjaGVkdWxlclN0YXRlIiwiZmx1c2hpbmciLCJmbHVzaFNjaGVkdWxlclF1ZXVlIiwid2F0Y2hlciIsInNvcnQiLCJxdWV1ZSIsInJ1biIsIm9sZFF1ZXVlIiwic2xpY2UiLCJkZXZ0b29scyIsImVtaXQiLCJxdWV1ZVdhdGNoZXIiLCJoYXMiLCJ3YWl0aW5nIiwidHJhdmVyc2UiLCJjbGVhciIsInNlZW5PYmplY3RzIiwiX3RyYXZlcnNlIiwic2VlbiIsImlzQSIsImRlcElkIiwicHJveHkiLCJzb3VyY2VLZXkiLCJzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24iLCJpbml0U3RhdGUiLCJfd2F0Y2hlcnMiLCJvcHRzIiwibWV0aG9kcyIsIl9kYXRhIiwiY29tcHV0ZWQiLCJ3YXRjaCIsImluaXRQcm9wcyIsInByb3BzT3B0aW9ucyIsImlzUm9vdCIsImluaXREYXRhIiwiZ2V0RGF0YSIsImluaXRDb21wdXRlZCIsIndhdGNoZXJzIiwiX2NvbXB1dGVkV2F0Y2hlcnMiLCJ1c2VyRGVmIiwiY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyIsImRlZmluZUNvbXB1dGVkIiwiY3JlYXRlQ29tcHV0ZWRHZXR0ZXIiLCJkaXJ0eSIsImV2YWx1YXRlIiwiaW5pdE1ldGhvZHMiLCJpbml0V2F0Y2giLCJoYW5kbGVyIiwiY3JlYXRlV2F0Y2hlciIsIiR3YXRjaCIsImNyZWF0ZUNvbXBvbmVudCIsImJhc2VDdG9yIiwiX2Jhc2UiLCJjaWQiLCJyZXNvbHZlZCIsInJlc29sdmVBc3luY0NvbXBvbmVudCIsIm1vZGVsIiwiZXh0cmFjdFByb3BzIiwiZnVuY3Rpb25hbCIsImNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQiLCJuYXRpdmVPbiIsIl9jb250ZXh0IiwiaCIsImQiLCJjcmVhdGVFbGVtZW50IiwiY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSIsInBhcmVudEVsbSIsInJlZkVsbSIsInZub2RlQ29tcG9uZW50T3B0aW9ucyIsImlubGluZVRlbXBsYXRlIiwic3RhdGljUmVuZGVyRm5zIiwiZmFjdG9yeSIsImNiIiwicmVxdWVzdGVkIiwiY2JzIiwicGVuZGluZ0NhbGxiYWNrcyIsInN5bmMiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVhc29uIiwidGhlbiIsImF0dHJzIiwiZG9tUHJvcHMiLCJhbHRLZXkiLCJjaGVja1Byb3AiLCJoYXNoIiwicHJlc2VydmUiLCJtZXJnZUhvb2tzIiwiaG9va3NUb01lcmdlIiwiZnJvbVBhcmVudCIsIm91cnMiLCJjb21wb25lbnRWTm9kZUhvb2tzIiwibWVyZ2VIb29rJDEiLCJvbmUiLCJ0d28iLCJ0cmFuc2Zvcm1Nb2RlbCIsImNhbGxiYWNrIiwibm9ybWFsaXphdGlvblR5cGUiLCJhbHdheXNOb3JtYWxpemUiLCJBTFdBWVNfTk9STUFMSVpFIiwiX2NyZWF0ZUVsZW1lbnQiLCJTSU1QTEVfTk9STUFMSVpFIiwiZ2V0VGFnTmFtZXNwYWNlIiwiaXNSZXNlcnZlZFRhZyIsInBhcnNlUGxhdGZvcm1UYWdOYW1lIiwiYXBwbHlOUyIsInJlbmRlckxpc3QiLCJyZW5kZXJTbG90IiwiZmFsbGJhY2siLCJiaW5kT2JqZWN0Iiwic2NvcGVkU2xvdEZuIiwic2xvdE5vZGVzIiwicmVzb2x2ZUZpbHRlciIsImlkZW50aXR5IiwiY2hlY2tLZXlDb2RlcyIsImV2ZW50S2V5Q29kZSIsImJ1aWx0SW5BbGlhcyIsImtleUNvZGVzIiwiYmluZE9iamVjdFByb3BzIiwiYXNQcm9wIiwibXVzdFVzZVByb3AiLCJyZW5kZXJTdGF0aWMiLCJpc0luRm9yIiwidHJlZSIsIl9zdGF0aWNUcmVlcyIsIl9yZW5kZXJQcm94eSIsIm1hcmtPbmNlIiwibWFya1N0YXRpYyIsImlzT25jZSIsIm1hcmtTdGF0aWNOb2RlIiwiaW5pdFJlbmRlciIsInJlbmRlckNvbnRleHQiLCJfYyIsIiRjcmVhdGVFbGVtZW50IiwiaW5pdFByb3ZpZGUiLCJwcm92aWRlIiwiX3Byb3ZpZGVkIiwiaW5pdEluamVjdGlvbnMiLCJpbmplY3QiLCJoYXNTeW1ib2wiLCJSZWZsZWN0Iiwib3duS2V5cyIsInByb3ZpZGVLZXkiLCJzb3VyY2UiLCJpbml0SW50ZXJuYWxDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsIl9jb21wb25lbnRUYWciLCJfcGFyZW50RWxtIiwiX3JlZkVsbSIsInJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMiLCJzdXBlciIsInN1cGVyT3B0aW9ucyIsIm1vZGlmaWVkT3B0aW9ucyIsInJlc29sdmVNb2RpZmllZE9wdGlvbnMiLCJleHRlbmRPcHRpb25zIiwiY29tcG9uZW50cyIsIm1vZGlmaWVkIiwibGF0ZXN0Iiwic2VhbGVkIiwic2VhbGVkT3B0aW9ucyIsImRlZHVwZSIsIl9pbml0IiwiaW5pdFVzZSIsIlZ1ZSIsInVzZSIsInBsdWdpbiIsImluc3RhbGxlZCIsImFyZ3MiLCJ1bnNoaWZ0IiwiaW5zdGFsbCIsImluaXRNaXhpbiQxIiwiaW5pdEV4dGVuZCIsIlN1cGVyIiwiU3VwZXJJZCIsImNhY2hlZEN0b3JzIiwiX0N0b3IiLCJTdWIiLCJfYXNzZXRUeXBlcyIsImZvckVhY2giLCJpbml0UHJvcHMkMSIsIkNvbXAiLCJpbml0Q29tcHV0ZWQkMSIsImluaXRBc3NldFJlZ2lzdGVycyIsImRlZmluaXRpb24iLCJnZXRDb21wb25lbnROYW1lIiwibWF0Y2hlcyIsInBhdHRlcm4iLCJSZWdFeHAiLCJwcnVuZUNhY2hlIiwiY2FjaGVkTm9kZSIsInBydW5lQ2FjaGVFbnRyeSIsImNvbXBvbmVudEluc3RhbmNlIiwiJGRlc3Ryb3kiLCJnZW5DbGFzc0ZvclZub2RlIiwicGFyZW50Tm9kZSIsImNoaWxkTm9kZSIsIm1lcmdlQ2xhc3NEYXRhIiwiZ2VuQ2xhc3NGcm9tRGF0YSIsInN0YXRpY0NsYXNzIiwiY2xhc3MiLCJkeW5hbWljQ2xhc3MiLCJzdHJpbmdpZnlDbGFzcyIsInN0cmluZ2lmaWVkIiwiaXNTVkciLCJpc1Vua25vd25FbGVtZW50IiwidW5rbm93bkVsZW1lbnRDYWNoZSIsImRvY3VtZW50Iiwid2luZG93IiwiSFRNTFVua25vd25FbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJxdWVyeSIsInNlbGVjdGVkIiwicXVlcnlTZWxlY3RvciIsImNyZWF0ZUVsZW1lbnQkMSIsInRhZ05hbWUiLCJtdWx0aXBsZSIsInNldEF0dHJpYnV0ZSIsImNyZWF0ZUVsZW1lbnROUyIsIm5hbWVzcGFjZSIsIm5hbWVzcGFjZU1hcCIsImNyZWF0ZVRleHROb2RlIiwiY3JlYXRlQ29tbWVudCIsImluc2VydEJlZm9yZSIsIm5ld05vZGUiLCJyZWZlcmVuY2VOb2RlIiwicmVtb3ZlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsIm5leHRTaWJsaW5nIiwic2V0VGV4dENvbnRlbnQiLCJ0ZXh0Q29udGVudCIsInJlZ2lzdGVyUmVmIiwiaXNSZW1vdmFsIiwicmVmIiwicmVmcyIsInJlZkluRm9yIiwiaXNVbmRlZiIsInYiLCJpc0RlZiIsImlzVHJ1ZSIsInNhbWVWbm9kZSIsInNhbWVJbnB1dFR5cGUiLCJjcmVhdGVLZXlUb09sZElkeCIsImJlZ2luSWR4IiwiZW5kSWR4IiwidXBkYXRlRGlyZWN0aXZlcyIsIm9sZFZub2RlIiwib2xkRGlyIiwiZGlyIiwiaXNDcmVhdGUiLCJlbXB0eU5vZGUiLCJpc0Rlc3Ryb3kiLCJvbGREaXJzIiwibm9ybWFsaXplRGlyZWN0aXZlcyQxIiwibmV3RGlycyIsImRpcnNXaXRoSW5zZXJ0IiwiZGlyc1dpdGhQb3N0cGF0Y2giLCJvbGRWYWx1ZSIsImNvbXBvbmVudFVwZGF0ZWQiLCJpbnNlcnRlZCIsImNhbGxJbnNlcnQiLCJtb2RpZmllcnMiLCJlbXB0eU1vZGlmaWVycyIsImdldFJhd0Rpck5hbWUiLCJyYXdOYW1lIiwiam9pbiIsImNhbGxIb29rJDEiLCJ1cGRhdGVBdHRycyIsIm9sZEF0dHJzIiwiaXNJRTkiLCJpc1hsaW5rIiwicmVtb3ZlQXR0cmlidXRlTlMiLCJ4bGlua05TIiwiZ2V0WGxpbmtQcm9wIiwiaXNFbnVtZXJhdGVkQXR0ciIsInJlbW92ZUF0dHJpYnV0ZSIsInNldEF0dHIiLCJpc0Jvb2xlYW5BdHRyIiwiaXNGYWxzeUF0dHJWYWx1ZSIsInNldEF0dHJpYnV0ZU5TIiwidXBkYXRlQ2xhc3MiLCJvbGREYXRhIiwiY2xzIiwidHJhbnNpdGlvbkNsYXNzIiwiX3RyYW5zaXRpb25DbGFzc2VzIiwiX3ByZXZDbGFzcyIsInBhcnNlRmlsdGVycyIsImV4cCIsInB1c2hGaWx0ZXIiLCJmaWx0ZXJzIiwibGFzdEZpbHRlckluZGV4IiwidHJpbSIsInByZXYiLCJleHByZXNzaW9uIiwiaW5TaW5nbGUiLCJpbkRvdWJsZSIsImluVGVtcGxhdGVTdHJpbmciLCJpblJlZ2V4IiwiY3VybHkiLCJzcXVhcmUiLCJwYXJlbiIsInAiLCJjaGFyQXQiLCJ2YWxpZERpdmlzaW9uQ2hhclJFIiwid3JhcEZpbHRlciIsImJhc2VXYXJuIiwibXNnIiwicGx1Y2tNb2R1bGVGdW5jdGlvbiIsIm1vZHVsZXMiLCJtIiwiXyIsImFkZFByb3AiLCJhZGRBdHRyIiwiYWRkRGlyZWN0aXZlIiwiYXJnIiwiYWRkSGFuZGxlciIsImltcG9ydGFudCIsImV2ZW50cyIsIm5hdGl2ZSIsIm5hdGl2ZUV2ZW50cyIsIm5ld0hhbmRsZXIiLCJnZXRCaW5kaW5nQXR0ciIsImdldFN0YXRpYyIsImR5bmFtaWNWYWx1ZSIsImdldEFuZFJlbW92ZUF0dHIiLCJzdGF0aWNWYWx1ZSIsImF0dHJzTWFwIiwiYXR0cnNMaXN0IiwiZ2VuQ29tcG9uZW50TW9kZWwiLCJudW1iZXIiLCJ2YWx1ZUV4cHJlc3Npb24iLCJhc3NpZ25tZW50IiwiZ2VuQXNzaWdubWVudENvZGUiLCJtb2RlbFJzIiwicGFyc2VNb2RlbCIsImlkeCIsImV4cHJlc3Npb25Qb3MiLCJleHByZXNzaW9uRW5kUG9zIiwibGFzdEluZGV4T2YiLCJlb2YiLCJuZXh0IiwiaXNTdHJpbmdTdGFydCIsImNociIsInN1YnN0cmluZyIsImluZGV4JDEiLCJwYXJzZUJyYWNrZXQiLCJpbkJyYWNrZXQiLCJwYXJzZVN0cmluZyIsInN0cmluZ1F1b3RlIiwiX3dhcm4iLCJnZW5DaGVja2JveE1vZGVsIiwidmFsdWVCaW5kaW5nIiwidHJ1ZVZhbHVlQmluZGluZyIsImZhbHNlVmFsdWVCaW5kaW5nIiwiQ0hFQ0tCT1hfUkFESU9fVE9LRU4iLCJnZW5SYWRpb01vZGVsIiwiZ2VuU2VsZWN0Iiwic2VsZWN0ZWRWYWwiLCJjb2RlIiwiZ2VuRGVmYXVsdE1vZGVsIiwibGF6eSIsIm5lZWRDb21wb3NpdGlvbkd1YXJkIiwiUkFOR0VfVE9LRU4iLCJub3JtYWxpemVFdmVudHMiLCJpc0lFIiwiaXNDaHJvbWUiLCJhZGQkMSIsIm9sZEhhbmRsZXIiLCJ0YXJnZXQkMSIsImV2IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZSQyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVwZGF0ZURPTUxpc3RlbmVycyIsInVwZGF0ZURPTVByb3BzIiwib2xkUHJvcHMiLCJfdmFsdWUiLCJzdHJDdXIiLCJzaG91bGRVcGRhdGVWYWx1ZSIsImNoZWNrVmFsIiwiY29tcG9zaW5nIiwiaXNEaXJ0eSIsImlzSW5wdXRDaGFuZ2VkIiwiYWN0aXZlRWxlbWVudCIsIl92TW9kaWZpZXJzIiwibm9ybWFsaXplU3R5bGVEYXRhIiwic3R5bGUiLCJub3JtYWxpemVTdHlsZUJpbmRpbmciLCJzdGF0aWNTdHlsZSIsImJpbmRpbmdTdHlsZSIsInBhcnNlU3R5bGVUZXh0IiwiZ2V0U3R5bGUiLCJjaGVja0NoaWxkIiwic3R5bGVEYXRhIiwidXBkYXRlU3R5bGUiLCJvbGRTdGF0aWNTdHlsZSIsIm9sZFN0eWxlQmluZGluZyIsIm9sZFN0eWxlIiwibmV3U3R5bGUiLCJhZGRDbGFzcyIsImNsYXNzTGlzdCIsImdldEF0dHJpYnV0ZSIsInJlbW92ZUNsYXNzIiwidGFyIiwicmVwbGFjZSIsInJlc29sdmVUcmFuc2l0aW9uIiwiZGVmJCQxIiwiY3NzIiwiYXV0b0Nzc1RyYW5zaXRpb24iLCJuZXh0RnJhbWUiLCJhZGRUcmFuc2l0aW9uQ2xhc3MiLCJyZW1vdmVUcmFuc2l0aW9uQ2xhc3MiLCJ3aGVuVHJhbnNpdGlvbkVuZHMiLCJleHBlY3RlZFR5cGUiLCJnZXRUcmFuc2l0aW9uSW5mbyIsInRpbWVvdXQiLCJwcm9wQ291bnQiLCJUUkFOU0lUSU9OIiwidHJhbnNpdGlvbkVuZEV2ZW50IiwiYW5pbWF0aW9uRW5kRXZlbnQiLCJlbmRlZCIsImVuZCIsIm9uRW5kIiwic3R5bGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInRyYW5zaXRpb25EZWxheXMiLCJ0cmFuc2l0aW9uUHJvcCIsInRyYW5zaXRpb25EdXJhdGlvbnMiLCJ0cmFuc2l0aW9uVGltZW91dCIsImdldFRpbWVvdXQiLCJhbmltYXRpb25EZWxheXMiLCJhbmltYXRpb25Qcm9wIiwiYW5pbWF0aW9uRHVyYXRpb25zIiwiYW5pbWF0aW9uVGltZW91dCIsIkFOSU1BVElPTiIsInRyYW5zZm9ybVJFIiwiZGVsYXlzIiwiZHVyYXRpb25zIiwidG9NcyIsInMiLCJOdW1iZXIiLCJlbnRlciIsInRvZ2dsZURpc3BsYXkiLCJfbGVhdmVDYiIsImNhbmNlbGxlZCIsInRyYW5zaXRpb24iLCJfZW50ZXJDYiIsIm5vZGVUeXBlIiwiZW50ZXJDbGFzcyIsImVudGVyVG9DbGFzcyIsImVudGVyQWN0aXZlQ2xhc3MiLCJhcHBlYXJDbGFzcyIsImFwcGVhclRvQ2xhc3MiLCJhcHBlYXJBY3RpdmVDbGFzcyIsImJlZm9yZUVudGVyIiwiYWZ0ZXJFbnRlciIsImVudGVyQ2FuY2VsbGVkIiwiYmVmb3JlQXBwZWFyIiwiYXBwZWFyIiwiYWZ0ZXJBcHBlYXIiLCJhcHBlYXJDYW5jZWxsZWQiLCJkdXJhdGlvbiIsImFjdGl2ZUluc3RhbmNlIiwidHJhbnNpdGlvbk5vZGUiLCJpc0FwcGVhciIsImlzUm9vdEluc2VydCIsInN0YXJ0Q2xhc3MiLCJhY3RpdmVDbGFzcyIsInRvQ2xhc3MiLCJiZWZvcmVFbnRlckhvb2siLCJlbnRlckhvb2siLCJhZnRlckVudGVySG9vayIsImVudGVyQ2FuY2VsbGVkSG9vayIsImV4cGxpY2l0RW50ZXJEdXJhdGlvbiIsImV4cGVjdHNDU1MiLCJ1c2VyV2FudHNDb250cm9sIiwiZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCIsInNob3ciLCJwZW5kaW5nTm9kZSIsIl9wZW5kaW5nIiwiaXNWYWxpZER1cmF0aW9uIiwibGVhdmUiLCJybSIsInBlcmZvcm1MZWF2ZSIsImJlZm9yZUxlYXZlIiwibGVhdmVDbGFzcyIsImxlYXZlQWN0aXZlQ2xhc3MiLCJsZWF2ZVRvQ2xhc3MiLCJleHBsaWNpdExlYXZlRHVyYXRpb24iLCJhZnRlckxlYXZlIiwibGVhdmVDYW5jZWxsZWQiLCJkZWxheUxlYXZlIiwiaW52b2tlckZucyIsIl9lbnRlciIsInNldFNlbGVjdGVkIiwiYmluZGluZyIsImlzTXVsdGlwbGUiLCJvcHRpb24iLCJnZXRWYWx1ZSIsInNlbGVjdGVkSW5kZXgiLCJoYXNOb01hdGNoaW5nT3B0aW9uIiwib25Db21wb3NpdGlvblN0YXJ0Iiwib25Db21wb3NpdGlvbkVuZCIsInRyaWdnZXIiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJsb2NhdGVOb2RlIiwiZ2V0UmVhbENoaWxkIiwiY29tcE9wdGlvbnMiLCJleHRyYWN0VHJhbnNpdGlvbkRhdGEiLCJjb21wIiwia2V5JDEiLCJwbGFjZWhvbGRlciIsInJhd0NoaWxkIiwiaGFzUGFyZW50VHJhbnNpdGlvbiIsImlzU2FtZUNoaWxkIiwib2xkQ2hpbGQiLCJjYWxsUGVuZGluZ0NicyIsIl9tb3ZlQ2IiLCJyZWNvcmRQb3NpdGlvbiIsIm5ld1BvcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImFwcGx5VHJhbnNsYXRpb24iLCJvbGRQb3MiLCJwb3MiLCJkeCIsImxlZnQiLCJkeSIsInRvcCIsIm1vdmVkIiwidHJhbnNmb3JtIiwiV2Via2l0VHJhbnNmb3JtIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwiZGVjb2RlIiwiaHRtbCIsImRlY29kZXIiLCJpbm5lckhUTUwiLCJkZWNvZGVBdHRyIiwic2hvdWxkRGVjb2RlTmV3bGluZXMiLCJyZSIsImVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIiwiZW5jb2RlZEF0dHIiLCJkZWNvZGluZ01hcCIsInBhcnNlSFRNTCIsImFkdmFuY2UiLCJwYXJzZUVuZFRhZyIsImxvd2VyQ2FzZWRUYWdOYW1lIiwic3RhY2siLCJsb3dlckNhc2VkVGFnIiwibGFzdFRhZyIsImV4cGVjdEhUTUwiLCJpc1VuYXJ5VGFnJCQxIiwiaXNVbmFyeVRhZyIsIm5vIiwiY2FuQmVMZWZ0T3BlblRhZyQkMSIsImNhbkJlTGVmdE9wZW5UYWciLCJpc1BsYWluVGV4dEVsZW1lbnQiLCJzdGFja2VkVGFnIiwicmVTdGFja2VkVGFnIiwicmVDYWNoZSIsImVuZFRhZ0xlbmd0aCIsInJlc3QiLCJhbGwiLCJlbmRUYWciLCJjaGFycyIsInRleHRFbmQiLCJjb21tZW50IiwiY29tbWVudEVuZCIsImNvbmRpdGlvbmFsQ29tbWVudCIsImNvbmRpdGlvbmFsRW5kIiwiZG9jdHlwZU1hdGNoIiwiZG9jdHlwZSIsImVuZFRhZ01hdGNoIiwiY3VySW5kZXgiLCJzdGFydFRhZ01hdGNoIiwic3RhcnRUYWdPcGVuIiwiYXR0ciIsInN0YXJ0VGFnQ2xvc2UiLCJhdHRyaWJ1dGUiLCJ1bmFyeVNsYXNoIiwiaXNOb25QaHJhc2luZ1RhZyIsInVuYXJ5IiwiSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiIsInJlc3QkMSIsInBhcnNlVGV4dCIsImRlbGltaXRlcnMiLCJ0YWdSRSIsImJ1aWxkUmVnZXgiLCJkZWZhdWx0VGFnUkUiLCJ0b2tlbnMiLCJsYXN0SW5kZXgiLCJleGVjIiwicGFyc2UiLCJ0ZW1wbGF0ZSIsImVuZFByZSIsImVsZW1lbnQiLCJwcmUiLCJwbGF0Zm9ybUlzUHJlVGFnIiwid2FybiIsImlzUHJlVGFnIiwicm9vdCIsImN1cnJlbnRQYXJlbnQiLCJwcmVzZXJ2ZVdoaXRlc3BhY2UiLCJpblZQcmUiLCJpblByZSIsIndhcm4kMiIsInBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlIiwiZ3VhcmRJRVNWR0J1ZyIsIm1ha2VBdHRyc01hcCIsImlzRm9yYmlkZGVuVGFnIiwiZm9yYmlkZGVuIiwicHJlVHJhbnNmb3JtcyIsInBsYWluIiwiaSQxIiwidHJhbnNmb3JtcyIsImlmIiwiZWxzZWlmIiwiZWxzZSIsInNsb3RTY29wZSIsInNsb3RUYXJnZXQiLCJpJDIiLCJwb3N0VHJhbnNmb3JtcyIsImxhc3ROb2RlIiwiZGVjb2RlSFRNTENhY2hlZCIsInByb2Nlc3NQcmUiLCJwcm9jZXNzUmF3QXR0cnMiLCJwcm9jZXNzS2V5IiwicHJvY2Vzc1JlZiIsImNoZWNrSW5Gb3IiLCJwcm9jZXNzRm9yIiwiaW5NYXRjaCIsImZvckFsaWFzUkUiLCJmb3IiLCJhbGlhcyIsIml0ZXJhdG9yTWF0Y2giLCJmb3JJdGVyYXRvclJFIiwiaXRlcmF0b3IxIiwiaXRlcmF0b3IyIiwicHJvY2Vzc0lmIiwicHJvY2Vzc0lmQ29uZGl0aW9ucyIsImZpbmRQcmV2RWxlbWVudCIsImFkZElmQ29uZGl0aW9uIiwiY29uZGl0aW9uIiwiaWZDb25kaXRpb25zIiwicHJvY2Vzc09uY2UiLCJwcm9jZXNzU2xvdCIsInNsb3ROYW1lIiwicHJvY2Vzc0NvbXBvbmVudCIsImNvbXBvbmVudCIsInByb2Nlc3NBdHRycyIsImlzUHJvcCIsImRpclJFIiwiaGFzQmluZGluZ3MiLCJwYXJzZU1vZGlmaWVycyIsIm1vZGlmaWVyUkUiLCJiaW5kUkUiLCJjYW1lbCIsInBsYXRmb3JtTXVzdFVzZVByb3AiLCJvblJFIiwiYXJnTWF0Y2giLCJhcmdSRSIsImllTlNCdWciLCJpZU5TUHJlZml4Iiwib3B0aW1pemUiLCJnZW5TdGF0aWNLZXlzQ2FjaGVkIiwic3RhdGljS2V5cyIsImdlblN0YXRpY0tleXMkMSIsIm1hcmtTdGF0aWMkMSIsInN0YXRpYyIsImlzUGxhdGZvcm1SZXNlcnZlZFRhZyIsIm1hcmtTdGF0aWNSb290cyIsInN0YXRpY0luRm9yIiwic3RhdGljUm9vdCIsIndhbGtUaHJvdWdoQ29uZGl0aW9uc0Jsb2NrcyIsImNvbmRpdGlvbkJsb2NrcyIsImJsb2NrIiwiaXNCdWlsdEluVGFnIiwiaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IiLCJpc1N0YXRpY0tleSIsImdlbkhhbmRsZXJzIiwiZ2VuSGFuZGxlciIsImlzTWV0aG9kUGF0aCIsInNpbXBsZVBhdGhSRSIsImlzRnVuY3Rpb25FeHByZXNzaW9uIiwiZm5FeHBSRSIsImdlbk1vZGlmaWVyQ29kZSIsIm1vZGlmaWVyQ29kZSIsImdlbktleUZpbHRlciIsImdlbkZpbHRlckNvZGUiLCJrZXlWYWwiLCJwYXJzZUludCIsImJpbmQkMSIsIndyYXBEYXRhIiwiZ2VuZXJhdGUiLCJhc3QiLCJwcmV2U3RhdGljUmVuZGVyRm5zIiwiY3VycmVudFN0YXRpY1JlbmRlckZucyIsInByZXZPbmNlQ291bnQiLCJvbmNlQ291bnQiLCJnZW5FbGVtZW50Iiwic3RhdGljUHJvY2Vzc2VkIiwiZ2VuU3RhdGljIiwib25jZVByb2Nlc3NlZCIsImdlbk9uY2UiLCJmb3JQcm9jZXNzZWQiLCJnZW5Gb3IiLCJpZlByb2Nlc3NlZCIsImdlbklmIiwiZ2VuU2xvdCIsImdlbkNvbXBvbmVudCIsImdlbkRhdGEiLCJnZW5DaGlsZHJlbiIsInRyYW5zZm9ybXMkMSIsImdlbklmQ29uZGl0aW9ucyIsImNvbmRpdGlvbnMiLCJnZW5UZXJuYXJ5RXhwIiwic2hpZnQiLCJnZW5EaXJlY3RpdmVzIiwiZGF0YUdlbkZucyIsImdlblByb3BzIiwiZ2VuU2NvcGVkU2xvdHMiLCJnZW5JbmxpbmVUZW1wbGF0ZSIsIm5lZWRSdW50aW1lIiwiaGFzUnVudGltZSIsImdlbiIsInBsYXRmb3JtRGlyZWN0aXZlcyQxIiwiYmFzZURpcmVjdGl2ZXMiLCJ3YXJuJDMiLCJpbmxpbmVSZW5kZXJGbnMiLCJjdXJyZW50T3B0aW9ucyIsImdlblNjb3BlZFNsb3QiLCJzY29wZSIsImNoZWNrU2tpcCIsImVsJDEiLCJnZXROb3JtYWxpemF0aW9uVHlwZSIsImdlbk5vZGUiLCJuZWVkc05vcm1hbGl6YXRpb24iLCJzb21lIiwibWF5YmVDb21wb25lbnQiLCJpc1BsYXRmb3JtUmVzZXJ2ZWRUYWckMSIsImdlblRleHQiLCJ0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMiLCJiaW5kJCQxIiwiY29tcG9uZW50TmFtZSIsImJhc2VDb21waWxlIiwibWFrZUZ1bmN0aW9uIiwiZXJyb3JzIiwiRnVuY3Rpb24iLCJ0cmFuc2Zvcm1Ob2RlIiwiY2xhc3NCaW5kaW5nIiwiZ2VuRGF0YSQxIiwidHJhbnNmb3JtTm9kZSQxIiwic3R5bGVCaW5kaW5nIiwiZ2VuRGF0YSQyIiwiZ2V0T3V0ZXJIVE1MIiwib3V0ZXJIVE1MIiwiY29udGFpbmVyIiwiY2xvbmVOb2RlIiwiX2lzU2VydmVyIiwiX1NldCIsInRvVXBwZXJDYXNlIiwiZnJlZXplIiwiaGFzUHJvdG8iLCJVQSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImlzRWRnZSIsImlzQW5kcm9pZCIsImlzSU9TIiwiZ2xvYmFsIiwiZW52IiwiVlVFX0VOViIsIl9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJTeW1ib2wiLCJuZXh0VGljayIsIm5leHRUaWNrSGFuZGxlciIsImNvcGllcyIsImNhbGxiYWNrcyIsInRpbWVyRnVuYyIsInBlbmRpbmciLCJQcm9taXNlIiwibG9nRXJyb3IiLCJjYXRjaCIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJjb3VudGVyIiwib2JzZXJ2ZXIiLCJ0ZXh0Tm9kZSIsIl9yZXNvbHZlIiwiU2V0IiwidWlkJDEiLCJzdWJzIiwiYWRkU3ViIiwic3ViIiwicmVtb3ZlU3ViIiwiYWRkRGVwIiwiYXJyYXlQcm90byIsImFycmF5TWV0aG9kcyIsIm1ldGhvZCIsIm9yaWdpbmFsIiwicmVzdWx0Iiwib2JzZXJ2ZUFycmF5IiwiYXJyYXlLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIndhbGsiLCJpdGVtcyIsIm9wdGlvbk1lcmdlU3RyYXRlZ2llcyIsImluc3RhbmNlRGF0YSIsImRlZmF1bHREYXRhIiwiX2xpZmVjeWNsZUhvb2tzIiwicmF3IiwicHJvdG90eXBlQWNjZXNzb3JzIiwiZGVmaW5lUHJvcGVydGllcyIsInVpZCQyIiwiZXhwT3JGbiIsImRlZXAiLCJ1c2VyIiwiYWN0aXZlIiwiZGVwcyIsIm5ld0RlcHMiLCJkZXBJZHMiLCJuZXdEZXBJZHMiLCJjbGVhbnVwRGVwcyIsInRoaXMkMSIsInRtcCIsInRlYXJkb3duIiwiJG1vdW50Iiwia2VlcEFsaXZlIiwibW91bnRlZE5vZGUiLCJwcmVwYXRjaCIsInVpZCIsIl91aWQiLCJfaXNDb21wb25lbnQiLCJfc2VsZiIsImRhdGFEZWYiLCJwcm9wc0RlZiIsIiRzZXQiLCIkZGVsZXRlIiwiaW1tZWRpYXRlIiwiaG9va1JFIiwicHJldkVsIiwicHJldlZub2RlIiwicHJldkFjdGl2ZUluc3RhbmNlIiwiX19wYXRjaF9fIiwiX192dWVfXyIsIiRuZXh0VGljayIsIl9vIiwiX24iLCJfcyIsIl9sIiwiX3QiLCJfcSIsIl9pIiwiX20iLCJfZiIsIl9rIiwiX2IiLCJfdiIsIl9lIiwiX3UiLCJwYXR0ZXJuVHlwZXMiLCJLZWVwQWxpdmUiLCJpbmNsdWRlIiwiZXhjbHVkZSIsImJ1aWx0SW5Db21wb25lbnRzIiwiY29uZmlnRGVmIiwidXRpbCIsImRlbGV0ZSIsInZlcnNpb24iLCJ3YXJuJDEiLCJ0ZXN0RWwiLCJhY2NlcHRWYWx1ZSIsImlzSFRNTFRhZyIsIm5vZGVPcHMiLCJob29rcyIsImJhc2VNb2R1bGVzIiwia2xhc3MiLCJjc3NUZXh0IiwiY3NzVmFyUkUiLCJpbXBvcnRhbnRSRSIsInNldFByb3AiLCJzZXRQcm9wZXJ0eSIsIm5vcm1hbGl6ZSIsInByZWZpeGVzIiwidXBwZXIiLCJwcmVmaXhlZCIsImhhc1RyYW5zaXRpb24iLCJvbnRyYW5zaXRpb25lbmQiLCJvbndlYmtpdHRyYW5zaXRpb25lbmQiLCJvbmFuaW1hdGlvbmVuZCIsIm9ud2Via2l0YW5pbWF0aW9uZW5kIiwicmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2V0VGltZW91dCIsInBsYXRmb3JtTW9kdWxlcyIsInBhdGNoIiwiYmFja2VuZCIsImVtcHR5Tm9kZUF0IiwiY3JlYXRlUm1DYiIsImNoaWxkRWxtIiwicmVtb3ZlTm9kZSIsImNyZWF0ZUVsbSIsImluc2VydGVkVm5vZGVRdWV1ZSIsIm5lc3RlZCIsImlzUmVhY3RpdmF0ZWQiLCJpbml0IiwiaW5pdENvbXBvbmVudCIsInBlbmRpbmdJbnNlcnQiLCJpc1BhdGNoYWJsZSIsInJlYWN0aXZhdGVDb21wb25lbnQiLCJpbm5lck5vZGUiLCJhY3RpdmF0ZSIsImluc2VydCIsImNyZWF0ZUNoaWxkcmVuIiwiaW52b2tlQ3JlYXRlSG9va3MiLCJzZXRTY29wZSIsImFuY2VzdG9yIiwiX3Njb3BlSWQiLCJhZGRWbm9kZXMiLCJzdGFydElkeCIsImludm9rZURlc3Ryb3lIb29rIiwiZGVzdHJveSIsInJlbW92ZVZub2RlcyIsImNoIiwicmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayIsInVwZGF0ZUNoaWxkcmVuIiwib2xkQ2giLCJuZXdDaCIsInJlbW92ZU9ubHkiLCJvbGRLZXlUb0lkeCIsImlkeEluT2xkIiwiZWxtVG9Nb3ZlIiwib2xkU3RhcnRJZHgiLCJuZXdTdGFydElkeCIsIm9sZEVuZElkeCIsIm9sZFN0YXJ0Vm5vZGUiLCJvbGRFbmRWbm9kZSIsIm5ld0VuZElkeCIsIm5ld1N0YXJ0Vm5vZGUiLCJuZXdFbmRWbm9kZSIsImNhbk1vdmUiLCJwYXRjaFZub2RlIiwicG9zdHBhdGNoIiwiaW52b2tlSW5zZXJ0SG9vayIsImluaXRpYWwiLCJoeWRyYXRlIiwiaGFzQ2hpbGROb2RlcyIsImNoaWxkcmVuTWF0Y2giLCJmaXJzdENoaWxkIiwiaXNSZW5kZXJlZE1vZHVsZSIsImlzSW5pdGlhbFBhdGNoIiwiaXNSZWFsRWxlbWVudCIsImhhc0F0dHJpYnV0ZSIsIm9sZEVsbSIsInBhcmVudEVsbSQxIiwidm1vZGVsIiwibW9kZWwkMSIsIm9yaWdpbmFsRGlzcGxheSIsIl9fdk9yaWdpbmFsRGlzcGxheSIsImRpc3BsYXkiLCJwbGF0Zm9ybURpcmVjdGl2ZXMiLCJ0cmFuc2l0aW9uUHJvcHMiLCJUcmFuc2l0aW9uIiwibW9kZSIsIl9sZWF2aW5nIiwib2xkUmF3Q2hpbGQiLCJkZWxheWVkTGVhdmUiLCJUcmFuc2l0aW9uR3JvdXAiLCJwcmV2Q2hpbGRyZW4iLCJyYXdDaGlsZHJlbiIsInRyYW5zaXRpb25EYXRhIiwia2VwdCIsInJlbW92ZWQiLCJjJDEiLCJtb3ZlQ2xhc3MiLCJoYXNNb3ZlIiwiYm9keSIsIm9mZnNldEhlaWdodCIsInByb3BlcnR5TmFtZSIsIl9oYXNNb3ZlIiwiY2xvbmUiLCJoYXNUcmFuc2Zvcm0iLCJwbGF0Zm9ybUNvbXBvbmVudHMiLCJjb250ZW50IiwiZW5jb2RlZCIsImRpdiIsInNpbmdsZUF0dHJWYWx1ZXMiLCJuY25hbWUiLCJnIiwib3BlbiIsImNsb3NlIiwiZ2VuR3VhcmQiLCJrbGFzcyQxIiwic3R5bGUkMSIsIm1vZHVsZXMkMSIsImRpcmVjdGl2ZXMkMSIsImJhc2VPcHRpb25zIiwicmVkdWNlIiwicmVmJDEiLCJjb21waWxlIiwiZmluYWxPcHRpb25zIiwidGlwcyIsInRpcCQkMSIsImNvbXBpbGVkIiwiY29tcGlsZVRvRnVuY3Rpb25zIiwiZnVuY3Rpb25Db21waWxlQ2FjaGUiLCJmbkdlbkVycm9ycyIsImlkVG9UZW1wbGF0ZSIsIm1vdW50IiwiZG9jdW1lbnRFbGVtZW50IiwicHJpY2VDdXJyZW5jaWVzIiwicHJpY2VNb2RlcyIsImRlY2tQYXJ0cyIsImFwcERhdGEiLCJkYXRhRGVja1BhcnRzIiwiZGF0YVByaWNlTW9kZXMiLCJkYXRhUHJpY2VDdXJyZW5jaWVzIiwidXJpTG9jYXRpb25Ob1BhcmFtIiwibG9jYXRpb24iLCJvcmlnaW4iLCJwYXRobmFtZSIsImVhY2hPYmplY3QiLCJvYmplY3QiLCJjdXJyZW50S2V5IiwiYXBpTG9hZE5hbWVzIiwiYWpheCIsImN1cnJlbnRseUxvYWRpbmciLCJuYW1lc0xvYWRlZCIsInJlc3BvbnNlIiwianNvbiIsInJlc3VsdERhdGEiLCJyZXN1bHRQYWlycyIsIm5hbWVTdG9yYWdlIiwiaW1hZ2VBUEkiLCJlbmNvZGVVUkkiLCJjYXJkcyIsInBhaXJzIiwibG9jYWxlQ29tcGFyZSIsImJ1aWxkZXJVcGRhdGVOYW1lcyIsImFwaUxvYWRQcmljZXMiLCJjYXJkSWRzIiwiZGVja0NhcmRzV2l0aG91dFByaWNlRGF0YSIsImNhcmROYW1lcyIsImNhcmRJZCIsInByaWNlUXVlcnkiLCJidG9hIiwicHJpY2VzTG9hZGVkIiwicHJpY2VEYXRhIiwiY2FyZCIsInByaWNlIiwibG93IiwiYXZlcmFnZSIsImhpZ2giLCJjb252ZXJ0RmlsZVRvRGVjayIsImZpbGVDb250ZW50IiwiZmlsZUNvbnRlbnRUcmltbWVkIiwiYXJyUGFydHMiLCJwYXJ0IiwibGluZSIsImRlY2twYXJ0IiwiZGVja0xvYWQiLCJmaWxlIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsIm9ubG9hZCIsImRlY2tMaXN0IiwiZGVjayIsImRlY2tVcGRhdGUiLCJyZWFkQXNUZXh0IiwidXJpRGVja0RlY29kZSIsImRlY2tVcmkiLCJkZWNrQXJyYXkiLCJhdG9iIiwiZGVja0xvYWRVcmkiLCJ1cmlEZWNrIiwidXJpRGVja0VuY29kZSIsInZhbHVlcyIsImRlY2tMaW5rIiwibGluayIsInByaWNlQ29udmVydCIsImN1cnJlbmN5IiwiY3VycmVuY2llcyIsImZpbmQiLCJhY3RpdmVDdXJyZW5jeSIsInRvRml4ZWQiLCJsYWJlbCIsInByaWNlRm9yQ2FyZCIsInByaWNlRm9yU2VjdGlvbiIsInNlY3Rpb24iLCJwcmljZVN1bSIsImNhcmREYXRhIiwiYnVpbGRlciIsInBhaXJzRmlsdGVyZWQiLCJidWlsZGVyRGVja0FkZCIsImRlY2tQYXJ0IiwiZGVja1BhcnRNYXgiLCJkZWNrcGFydHMiLCJzaXplIiwiYnVpbGRlckRlY2tSZW1vdmUiLCJmb3VuZENhcmQiLCJzYXZlQXMiLCJ2aWV3IiwiZG9jIiwiZ2V0X1VSTCIsIlVSTCIsIndlYmtpdFVSTCIsInNhdmVfbGluayIsImNhbl91c2Vfc2F2ZV9saW5rIiwiY2xpY2siLCJNb3VzZUV2ZW50IiwiaXNfc2FmYXJpIiwic2FmYXJpIiwiaXNfY2hyb21lX2lvcyIsInRocm93X291dHNpZGUiLCJleCIsInNldEltbWVkaWF0ZSIsInJldm9rZSIsInJldm9rZXIiLCJyZXZva2VPYmplY3RVUkwiLCJkaXNwYXRjaCIsImZpbGVzYXZlciIsImV2ZW50X3R5cGVzIiwibGlzdGVuZXIiLCJhdXRvX2JvbSIsImJsb2IiLCJCbG9iIiwiZnJvbUNoYXJDb2RlIiwiRmlsZVNhdmVyIiwibm9fYXV0b19ib20iLCJvYmplY3RfdXJsIiwiZm9yY2UiLCJkaXNwYXRjaF9hbGwiLCJyZWFkeVN0YXRlIiwiSU5JVCIsImNyZWF0ZU9iamVjdFVSTCIsImhyZWYiLCJkb3dubG9hZCIsIkRPTkUiLCJvbmxvYWRlbmQiLCJ1cmwiLCJyZWFkQXNEYXRhVVJMIiwiRlNfcHJvdG8iLCJtc1NhdmVPck9wZW5CbG9iIiwiYWJvcnQiLCJXUklUSU5HIiwib253cml0ZXN0YXJ0Iiwib25wcm9ncmVzcyIsIm9ud3JpdGUiLCJvbmFib3J0Iiwib25lcnJvciIsIm9ud3JpdGVlbmQiLCJzZWxmIiwibW9kdWxlIiwiZXhwb3J0cyIsImNvbnZlcnREZWNrVG9GaWxlIiwiZmlsZUlkIiwiZmlsZURvd25sb2FkRGVjayIsImZpbGVEYXRhIiwiRmlsZSIsImFwcE1ldGhvZHMiLCJmaWxlcyIsImRhdGFUcmFuc2ZlciIsInVybFF1ZXJ5Iiwic2VhcmNoIiwicHJpY2VBcHAiXSwibWFwcGluZ3MiOiJ3QkFVQSxTQUFTQSxHQUFXQyxTQUNKLE9BQVBBLEVBQ0gsR0FDZSxxQkFBUkEsaUJBQUFBLElBQ0xDLEtBQUtDLFVBQVVGLEVBQUssS0FBTSxHQUMxQkcsT0FBT0gsR0FPZixRQUFTSSxHQUFVSixNQUNiSyxHQUFJQyxXQUFXTixTQUNaTyxPQUFNRixHQUFLTCxFQUFNSyxFQU8xQixRQUFTRyxHQUNQQyxFQUNBQyxPQUlLLEdBRkRDLEdBQU1DLE9BQU9DLE9BQU8sTUFDcEJDLEVBQU9MLEVBQUlNLE1BQU0sS0FDWkMsRUFBSSxFQUFHQSxFQUFJRixFQUFLRyxPQUFRRCxNQUMzQkYsRUFBS0UsS0FBTSxRQUVWTixHQUNILFNBQVVWLFNBQWNXLEdBQUlYLEVBQUlrQixnQkFDaEMsU0FBVWxCLFNBQWNXLEdBQUlYLElBV2xDLFFBQVNtQixHQUFRQyxFQUFLQyxNQUNoQkQsRUFBSUgsT0FBUSxJQUNWSyxHQUFRRixFQUFJRyxRQUFRRixNQUNwQkMsR0FBUyxRQUNKRixHQUFJSSxPQUFPRixFQUFPLElBUy9CLFFBQVNHLEdBQVFDLEVBQUtDLFNBQ2JDLElBQWVDLEtBQUtILEVBQUtDLEdBTWxDLFFBQVNHLEdBQWFDLFNBQ0ksZ0JBQVZBLElBQXVDLGdCQUFWQSxHQU03QyxRQUFTQyxHQUFRQyxNQUNYQyxHQUFRdEIsT0FBT0MsT0FBTyxZQUNsQixVQUFtQkosU0FDZnlCLEdBQU16QixLQUNEeUIsRUFBTXpCLEdBQU93QixFQUFHeEIsS0FpQ25DLFFBQVMwQixHQUFNRixFQUFJRyxXQUNSQyxHQUFTQyxNQUNaQyxHQUFJQyxVQUFVdkIsYUFDWHNCLEdBQ0hBLEVBQUksRUFDRk4sRUFBR1EsTUFBTUwsRUFBS0ksV0FDZFAsRUFBR0osS0FBS08sRUFBS0UsR0FDZkwsRUFBR0osS0FBS08sWUFHTk0sUUFBVVQsRUFBR2hCLE9BQ2RvQixFQU1ULFFB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"}